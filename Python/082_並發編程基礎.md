[ä¸Šä¸€ç« ï¼šæ€§èƒ½å„ªåŒ–é€²éš](081_æ€§èƒ½å„ªåŒ–é€²éš.md) | [ä¸‹ä¸€ç« ï¼šä¸¦ç™¼ç·¨ç¨‹é€²éš](083_ä¸¦ç™¼ç·¨ç¨‹é€²éš.md)

# Python ä¸¦ç™¼ç·¨ç¨‹åŸºç¤ ğŸ”„

## ç·šç¨‹ç·¨ç¨‹

### 1. ç·šç¨‹ç®¡ç†å™¨

```python
import threading
import queue
import time
from typing import List, Dict, Any, Callable, Optional
import sys
import os

class ThreadManager:
    def __init__(self):
        """åˆå§‹åŒ–ç·šç¨‹ç®¡ç†å™¨"""
        self.threads: List[threading.Thread] = []
        self.task_queue = queue.Queue()
        self.result_queue = queue.Queue()
        self.is_running = False
        self.results: Dict[str, Any] = {}
        self.lock = threading.Lock()
    
    def start(self):
        """å•Ÿå‹•ç·šç¨‹ç®¡ç†å™¨"""
        self.is_running = True
        self._start_worker_threads()
    
    def stop(self):
        """åœæ­¢ç·šç¨‹ç®¡ç†å™¨"""
        self.is_running = False
        for _ in range(len(self.threads)):
            self.task_queue.put(None)
        
        for thread in self.threads:
            thread.join()
    
    def _start_worker_threads(self, num_threads: int = 4):
        """å•Ÿå‹•å·¥ä½œç·šç¨‹"""
        for _ in range(num_threads):
            thread = threading.Thread(target=self._worker_loop)
            thread.daemon = True
            thread.start()
            self.threads.append(thread)
    
    def submit_task(self, task_id: str, func: Callable, *args, **kwargs):
        """æäº¤ä»»å‹™"""
        self.task_queue.put((task_id, func, args, kwargs))
    
    def _worker_loop(self):
        """å·¥ä½œç·šç¨‹å¾ªç’°"""
        while self.is_running:
            try:
                task = self.task_queue.get(timeout=1)
                if task is None:
                    break
                
                task_id, func, args, kwargs = task
                
                try:
                    # åŸ·è¡Œä»»å‹™
                    result = func(*args, **kwargs)
                    self.result_queue.put((task_id, result, None))
                
                except Exception as e:
                    self.result_queue.put((task_id, None, e))
                
                finally:
                    self.task_queue.task_done()
            
            except queue.Empty:
                continue
    
    def get_result(self, task_id: str, timeout: float = None) -> Any:
        """ç²å–ä»»å‹™çµæœ"""
        while True:
            try:
                result_task_id, result, error = self.result_queue.get(timeout=timeout)
                if result_task_id == task_id:
                    if error:
                        raise error
                    return result
                else:
                    self.result_queue.put((result_task_id, result, error))
            
            except queue.Empty:
                raise TimeoutError(f"Timeout waiting for task {task_id}")
    
    def execute_with_lock(self, func: Callable, *args, **kwargs) -> Any:
        """ä½¿ç”¨é–åŸ·è¡Œä»»å‹™"""
        with self.lock:
            return func(*args, **kwargs)
    
    def wait_for_all_tasks(self):
        """ç­‰å¾…æ‰€æœ‰ä»»å‹™å®Œæˆ"""
        self.task_queue.join()

# ä½¿ç”¨ç¤ºä¾‹
def process_item(item: int) -> int:
    """è™•ç†å–®å€‹é …ç›®"""
    time.sleep(0.1)  # æ¨¡æ“¬è™•ç†æ™‚é–“
    return item * item

def main():
    # å‰µå»ºç·šç¨‹ç®¡ç†å™¨
    manager = ThreadManager()
    
    try:
        # å•Ÿå‹•ç·šç¨‹ç®¡ç†å™¨
        manager.start()
        
        # æäº¤å–®å€‹ä»»å‹™
        print("Submitting single task:")
        manager.submit_task("task1", process_item, 5)
        result = manager.get_result("task1")
        print(f"Result: {result}")
        
        # æäº¤å¤šå€‹ä»»å‹™
        print("\nSubmitting multiple tasks:")
        for i in range(5):
            manager.submit_task(f"task{i+2}", process_item, i)
        
        # ç²å–æ‰€æœ‰çµæœ
        for i in range(5):
            result = manager.get_result(f"task{i+2}")
            print(f"Task {i+2} result: {result}")
        
        # ä½¿ç”¨é–åŸ·è¡Œä»»å‹™
        print("\nExecuting with lock:")
        result = manager.execute_with_lock(process_item, 10)
        print(f"Locked result: {result}")
        
        # ç­‰å¾…æ‰€æœ‰ä»»å‹™å®Œæˆ
        manager.wait_for_all_tasks()
    
    finally:
        # åœæ­¢ç·šç¨‹ç®¡ç†å™¨
        manager.stop()

if __name__ == '__main__':
    main()
```

### 2. ç·šç¨‹åŒæ­¥å™¨

```python
import threading
import time
from typing import List, Dict, Any, Optional
import queue
import random

class ThreadSynchronizer:
    def __init__(self):
        """åˆå§‹åŒ–ç·šç¨‹åŒæ­¥å™¨"""
        self.threads: List[threading.Thread] = []
        self.conditions: Dict[str, threading.Condition] = {}
        self.events: Dict[str, threading.Event] = {}
        self.semaphores: Dict[str, threading.Semaphore] = {}
        self.barriers: Dict[str, threading.Barrier] = {}
        self.locks: Dict[str, threading.Lock] = {}
    
    def create_condition(self, name: str):
        """å‰µå»ºæ¢ä»¶è®Šé‡"""
        self.conditions[name] = threading.Condition()
    
    def create_event(self, name: str):
        """å‰µå»ºäº‹ä»¶"""
        self.events[name] = threading.Event()
    
    def create_semaphore(self, name: str, value: int = 1):
        """å‰µå»ºä¿¡è™Ÿé‡"""
        self.semaphores[name] = threading.Semaphore(value)
    
    def create_barrier(self, name: str, parties: int):
        """å‰µå»ºæŸµæ¬„"""
        self.barriers[name] = threading.Barrier(parties)
    
    def create_lock(self, name: str):
        """å‰µå»ºé–"""
        self.locks[name] = threading.Lock()
    
    def wait_for_condition(self, name: str, timeout: float = None):
        """ç­‰å¾…æ¢ä»¶è®Šé‡"""
        if name in self.conditions:
            self.conditions[name].wait(timeout)
    
    def notify_condition(self, name: str):
        """é€šçŸ¥æ¢ä»¶è®Šé‡"""
        if name in self.conditions:
            self.conditions[name].notify()
    
    def notify_all_condition(self, name: str):
        """é€šçŸ¥æ‰€æœ‰ç­‰å¾…çš„ç·šç¨‹"""
        if name in self.conditions:
            self.conditions[name].notify_all()
    
    def wait_for_event(self, name: str, timeout: float = None):
        """ç­‰å¾…äº‹ä»¶"""
        if name in self.events:
            self.events[name].wait(timeout)
    
    def set_event(self, name: str):
        """è¨­ç½®äº‹ä»¶"""
        if name in self.events:
            self.events[name].set()
    
    def clear_event(self, name: str):
        """æ¸…é™¤äº‹ä»¶"""
        if name in self.events:
            self.events[name].clear()
    
    def acquire_semaphore(self, name: str, blocking: bool = True, timeout: float = None):
        """ç²å–ä¿¡è™Ÿé‡"""
        if name in self.semaphores:
            return self.semaphores[name].acquire(blocking, timeout)
    
    def release_semaphore(self, name: str):
        """é‡‹æ”¾ä¿¡è™Ÿé‡"""
        if name in self.semaphores:
            self.semaphores[name].release()
    
    def wait_at_barrier(self, name: str, timeout: float = None):
        """ç­‰å¾…æŸµæ¬„"""
        if name in self.barriers:
            self.barriers[name].wait(timeout)
    
    def acquire_lock(self, name: str, blocking: bool = True, timeout: float = -1):
        """ç²å–é–"""
        if name in self.locks:
            return self.locks[name].acquire(blocking, timeout)
    
    def release_lock(self, name: str):
        """é‡‹æ”¾é–"""
        if name in self.locks:
            self.locks[name].release()

# ä½¿ç”¨ç¤ºä¾‹
def producer(sync: ThreadSynchronizer, queue: queue.Queue):
    """ç”Ÿç”¢è€…ç·šç¨‹"""
    for i in range(5):
        # ç²å–ä¿¡è™Ÿé‡
        sync.acquire_semaphore('items')
        
        # ç”Ÿç”¢æ•¸æ“š
        item = random.randint(1, 100)
        queue.put(item)
        print(f"Produced: {item}")
        
        # é‡‹æ”¾ä¿¡è™Ÿé‡
        sync.release_semaphore('space')
        
        # é€šçŸ¥æ¶ˆè²»è€…
        sync.notify_condition('queue')
        
        time.sleep(1)

def consumer(sync: ThreadSynchronizer, queue: queue.Queue):
    """æ¶ˆè²»è€…ç·šç¨‹"""
    for _ in range(5):
        # ç­‰å¾…æ¢ä»¶è®Šé‡
        sync.wait_for_condition('queue')
        
        # ç²å–ä¿¡è™Ÿé‡
        sync.acquire_semaphore('space')
        
        # æ¶ˆè²»æ•¸æ“š
        item = queue.get()
        print(f"Consumed: {item}")
        
        # é‡‹æ”¾ä¿¡è™Ÿé‡
        sync.release_semaphore('items')
        
        time.sleep(1)

def main():
    # å‰µå»ºåŒæ­¥å™¨
    sync = ThreadSynchronizer()
    
    # å‰µå»ºåŒæ­¥åŸèª
    sync.create_condition('queue')
    sync.create_semaphore('items', 0)
    sync.create_semaphore('space', 5)
    
    # å‰µå»ºéšŠåˆ—
    queue = queue.Queue()
    
    # å‰µå»ºç·šç¨‹
    producer_thread = threading.Thread(
        target=producer,
        args=(sync, queue)
    )
    
    consumer_thread = threading.Thread(
        target=consumer,
        args=(sync, queue)
    )
    
    # å•Ÿå‹•ç·šç¨‹
    producer_thread.start()
    consumer_thread.start()
    
    # ç­‰å¾…ç·šç¨‹å®Œæˆ
    producer_thread.join()
    consumer_thread.join()

if __name__ == '__main__':
    main()
```

## ç·´ç¿’é¡Œ

1. **ç·šç¨‹ç®¡ç†å™¨**
   é–‹ç™¼ä¸€å€‹ç·šç¨‹ç®¡ç†å™¨ï¼š
   - ç®¡ç†ç·šç¨‹ç”Ÿå‘½é€±æœŸ
   - è™•ç†ç·šç¨‹é€šä¿¡
   - å„ªåŒ–ç·šç¨‹èª¿åº¦
   - æä¾›éŒ¯èª¤è™•ç†

2. **ç·šç¨‹åŒæ­¥å™¨**
   å‰µå»ºä¸€å€‹ç·šç¨‹åŒæ­¥å™¨ï¼š
   - æ”¯æŒå¤šç¨®åŒæ­¥åŸèª
   - è™•ç†è¤‡é›œåŒæ­¥å ´æ™¯
   - é¿å…æ­»é–
   - æä¾›èª¿è©¦åŠŸèƒ½

3. **ä¸¦ç™¼æ¡†æ¶**
   å¯¦ç¾ä¸€å€‹ä¸¦ç™¼æ¡†æ¶ï¼š
   - æ”¯æŒå¤šç¨®ä¸¦ç™¼æ¨¡å‹
   - æä¾›é«˜ç´šAPI
   - å„ªåŒ–æ€§èƒ½
   - è™•ç†è¤‡é›œå ´æ™¯

## å°æé†’ ğŸ’¡

1. ç·šç¨‹ç®¡ç†
   - æ§åˆ¶ç·šç¨‹æ•¸é‡
   - è™•ç†ç·šç¨‹é€šä¿¡
   - å„ªåŒ–ç·šç¨‹èª¿åº¦
   - ç›£æ§ç·šç¨‹ç‹€æ…‹

2. åŒæ­¥æ©Ÿåˆ¶
   - é¸æ“‡åˆé©åŸèª
   - é¿å…æ­»é–
   - å„ªåŒ–åŒæ­¥é–‹éŠ·
   - è™•ç†ç«¶æ…‹æ¢ä»¶

3. æ€§èƒ½å„ªåŒ–
   - æ¸›å°‘ç·šç¨‹é–‹éŠ·
   - å„ªåŒ–è³‡æºä½¿ç”¨
   - å¹³è¡¡è² è¼‰
   - æé«˜ååé‡

4. èª¿è©¦æŠ€å·§
   - ä½¿ç”¨èª¿è©¦å·¥å…·
   - åˆ†ææ­»é–å•é¡Œ
   - å„ªåŒ–åŒæ­¥é‚è¼¯
   - ç›£æ§ç³»çµ±è³‡æº

[ä¸Šä¸€ç« ï¼šæ€§èƒ½å„ªåŒ–é€²éš](081_æ€§èƒ½å„ªåŒ–é€²éš.md) | [ä¸‹ä¸€ç« ï¼šä¸¦ç™¼ç·¨ç¨‹é€²éš](083_ä¸¦ç™¼ç·¨ç¨‹é€²éš.md) 