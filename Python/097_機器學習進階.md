[ä¸Šä¸€ç« ï¼šæ©Ÿå™¨å­¸ç¿’åŸºç¤](096_æ©Ÿå™¨å­¸ç¿’åŸºç¤.md) | [ä¸‹ä¸€ç« ï¼šæ·±åº¦å­¸ç¿’åŸºç¤](098_æ·±åº¦å­¸ç¿’åŸºç¤.md)

# Python æ©Ÿå™¨å­¸ç¿’é€²éš ğŸ¤–

## é«˜ç´šæ¨¡å‹

### 1. æ¨¡å‹å„ªåŒ–

```python
import numpy as np
from sklearn.model_selection import GridSearchCV, cross_val_score
from sklearn.ensemble import RandomForestClassifier
from sklearn.metrics import make_scorer, accuracy_score
import time
from typing import List, Dict, Any, Optional, Tuple
import sys
import os

class ModelOptimization:
    def __init__(self):
        """åˆå§‹åŒ–æ¨¡å‹å„ªåŒ–"""
        self.model = None
        self.best_params = None
        self.best_score = 0
    
    def create_model(self, model_type: str = 'random_forest'):
        """å‰µå»ºæ¨¡å‹"""
        try:
            if model_type == 'random_forest':
                self.model = RandomForestClassifier(random_state=42)
            else:
                raise ValueError(f"Unsupported model type: {model_type}")
            
            print(f"Model {model_type} created")
            return self.model
            
        except Exception as e:
            print(f"Error creating model: {e}")
            return None
    
    def define_param_grid(self) -> Dict[str, List[Any]]:
        """å®šç¾©åƒæ•¸ç¶²æ ¼"""
        try:
            param_grid = {
                'n_estimators': [100, 200, 300],
                'max_depth': [10, 20, 30, None],
                'min_samples_split': [2, 5, 10],
                'min_samples_leaf': [1, 2, 4]
            }
            print("Parameter grid defined")
            return param_grid
            
        except Exception as e:
            print(f"Error defining parameter grid: {e}")
            return {}
    
    def grid_search(self, X_train: np.ndarray, y_train: np.ndarray):
        """ç¶²æ ¼æœç´¢"""
        if self.model is None:
            print("No model created")
            return None
        
        try:
            # å®šç¾©åƒæ•¸ç¶²æ ¼
            param_grid = self.define_param_grid()
            
            # å‰µå»ºè©•åˆ†å™¨
            scorer = make_scorer(accuracy_score)
            
            # å‰µå»ºç¶²æ ¼æœç´¢
            grid_search = GridSearchCV(
                estimator=self.model,
                param_grid=param_grid,
                scoring=scorer,
                cv=5,
                n_jobs=-1,
                verbose=1
            )
            
            # åŸ·è¡Œç¶²æ ¼æœç´¢
            start_time = time.time()
            grid_search.fit(X_train, y_train)
            search_time = time.time() - start_time
            
            # ä¿å­˜æœ€ä½³çµæœ
            self.best_params = grid_search.best_params_
            self.best_score = grid_search.best_score_
            
            print(f"Grid search completed in {search_time:.2f} seconds")
            print(f"Best parameters: {self.best_params}")
            print(f"Best score: {self.best_score:.4f}")
            
            return grid_search.best_estimator_
            
        except Exception as e:
            print(f"Error performing grid search: {e}")
            return None
    
    def cross_validation(self, X: np.ndarray, y: np.ndarray, cv: int = 5):
        """äº¤å‰é©—è­‰"""
        if self.model is None:
            print("No model created")
            return None
        
        try:
            # åŸ·è¡Œäº¤å‰é©—è­‰
            scores = cross_val_score(
                self.model,
                X,
                y,
                cv=cv,
                scoring='accuracy'
            )
            
            print(f"Cross-validation scores: {scores}")
            print(f"Average score: {scores.mean():.4f} (+/- {scores.std() * 2:.4f})")
            
            return scores
            
        except Exception as e:
            print(f"Error performing cross validation: {e}")
            return None

# ä½¿ç”¨ç¤ºä¾‹
def main():
    # å‰µå»ºæ¨¡å‹å„ªåŒ–å™¨
    optimizer = ModelOptimization()
    
    try:
        # å‰µå»ºæ¨¡å‹
        optimizer.create_model('random_forest')
        
        # å‰µå»ºç¤ºä¾‹æ•¸æ“š
        X = np.random.rand(100, 5)  # 100å€‹æ¨£æœ¬ï¼Œ5å€‹ç‰¹å¾µ
        y = np.random.randint(0, 3, 100)  # 3å€‹é¡åˆ¥
        
        # åŸ·è¡Œç¶²æ ¼æœç´¢
        best_model = optimizer.grid_search(X, y)
        
        if best_model is not None:
            # åŸ·è¡Œäº¤å‰é©—è­‰
            scores = optimizer.cross_validation(X, y)
    
    except Exception as e:
        print(f"Error in main: {e}")

if __name__ == '__main__':
    main()
```

### 2. æ¨¡å‹é›†æˆ

```python
import numpy as np
from sklearn.ensemble import VotingClassifier, StackingClassifier
from sklearn.linear_model import LogisticRegression
from sklearn.tree import DecisionTreeClassifier
from sklearn.svm import SVC
from sklearn.metrics import accuracy_score
import time
from typing import List, Dict, Any, Optional, Tuple
import sys
import os

class ModelEnsemble:
    def __init__(self):
        """åˆå§‹åŒ–æ¨¡å‹é›†æˆ"""
        self.models = {}
        self.ensemble = None
        self.best_score = 0
    
    def create_base_models(self):
        """å‰µå»ºåŸºç¤æ¨¡å‹"""
        try:
            # å‰µå»ºåŸºç¤æ¨¡å‹
            self.models = {
                'logistic': LogisticRegression(random_state=42),
                'decision_tree': DecisionTreeClassifier(random_state=42),
                'svm': SVC(random_state=42)
            }
            print("Base models created")
            return True
            
        except Exception as e:
            print(f"Error creating base models: {e}")
            return False
    
    def create_voting_ensemble(self):
        """å‰µå»ºæŠ•ç¥¨é›†æˆ"""
        try:
            # å‰µå»ºæŠ•ç¥¨åˆ†é¡å™¨
            self.ensemble = VotingClassifier(
                estimators=[
                    ('logistic', self.models['logistic']),
                    ('decision_tree', self.models['decision_tree']),
                    ('svm', self.models['svm'])
                ],
                voting='hard'
            )
            print("Voting ensemble created")
            return True
            
        except Exception as e:
            print(f"Error creating voting ensemble: {e}")
            return False
    
    def create_stacking_ensemble(self):
        """å‰µå»ºå †ç–Šé›†æˆ"""
        try:
            # å‰µå»ºå †ç–Šåˆ†é¡å™¨
            estimators = [
                ('logistic', self.models['logistic']),
                ('decision_tree', self.models['decision_tree']),
                ('svm', self.models['svm'])
            ]
            
            final_estimator = LogisticRegression()
            
            self.ensemble = StackingClassifier(
                estimators=estimators,
                final_estimator=final_estimator,
                cv=5
            )
            print("Stacking ensemble created")
            return True
            
        except Exception as e:
            print(f"Error creating stacking ensemble: {e}")
            return False
    
    def train_ensemble(self, X_train: np.ndarray, y_train: np.ndarray):
        """è¨“ç·´é›†æˆæ¨¡å‹"""
        if self.ensemble is None:
            print("No ensemble created")
            return None
        
        try:
            # è¨“ç·´é›†æˆæ¨¡å‹
            start_time = time.time()
            self.ensemble.fit(X_train, y_train)
            training_time = time.time() - start_time
            
            print(f"Ensemble trained in {training_time:.2f} seconds")
            return self.ensemble
            
        except Exception as e:
            print(f"Error training ensemble: {e}")
            return None
    
    def evaluate_ensemble(self, X_test: np.ndarray, y_test: np.ndarray):
        """è©•ä¼°é›†æˆæ¨¡å‹"""
        if self.ensemble is None:
            print("No ensemble created")
            return None
        
        try:
            # é æ¸¬
            y_pred = self.ensemble.predict(X_test)
            
            # è¨ˆç®—æº–ç¢ºç‡
            accuracy = accuracy_score(y_test, y_pred)
            
            print(f"Ensemble accuracy: {accuracy:.4f}")
            return accuracy
            
        except Exception as e:
            print(f"Error evaluating ensemble: {e}")
            return None

# ä½¿ç”¨ç¤ºä¾‹
def main():
    # å‰µå»ºæ¨¡å‹é›†æˆå™¨
    ensemble = ModelEnsemble()
    
    try:
        # å‰µå»ºåŸºç¤æ¨¡å‹
        ensemble.create_base_models()
        
        # å‰µå»ºæŠ•ç¥¨é›†æˆ
        ensemble.create_voting_ensemble()
        
        # å‰µå»ºç¤ºä¾‹æ•¸æ“š
        X_train = np.random.rand(80, 5)  # 80å€‹è¨“ç·´æ¨£æœ¬
        y_train = np.random.randint(0, 3, 80)
        X_test = np.random.rand(20, 5)   # 20å€‹æ¸¬è©¦æ¨£æœ¬
        y_test = np.random.randint(0, 3, 20)
        
        # è¨“ç·´é›†æˆæ¨¡å‹
        trained_ensemble = ensemble.train_ensemble(X_train, y_train)
        
        if trained_ensemble is not None:
            # è©•ä¼°é›†æˆæ¨¡å‹
            accuracy = ensemble.evaluate_ensemble(X_test, y_test)
    
    except Exception as e:
        print(f"Error in main: {e}")

if __name__ == '__main__':
    main()
```

## ç·´ç¿’é¡Œ

1. **æ¨¡å‹å„ªåŒ–**
   é–‹ç™¼æ¨¡å‹å„ªåŒ–ï¼š
   - ç¶²æ ¼æœç´¢
   - äº¤å‰é©—è­‰
   - åƒæ•¸èª¿å„ª
   - å„ªåŒ–æ€§èƒ½

2. **æ¨¡å‹é›†æˆ**
   å‰µå»ºæ¨¡å‹é›†æˆï¼š
   - æŠ•ç¥¨é›†æˆ
   - å †ç–Šé›†æˆ
   - å„ªåŒ–æ€§èƒ½
   - è™•ç†ç•°å¸¸

3. **æ©Ÿå™¨å­¸ç¿’**
   å¯¦ç¾æ©Ÿå™¨å­¸ç¿’ï¼š
   - è™•ç†æ•¸æ“š
   - å„ªåŒ–æ¨¡å‹
   - é›†æˆæ¨¡å‹
   - è™•ç†ç•°å¸¸

## å°æé†’ ğŸ’¡

1. æ¨¡å‹å„ªåŒ–
   - é¸æ“‡åˆé©æ–¹æ³•
   - å„ªåŒ–åƒæ•¸
   - è™•ç†ç•°å¸¸
   - æä¾›ç›£æ§

2. æ¨¡å‹é›†æˆ
   - é¸æ“‡åˆé©æ–¹æ³•
   - å„ªåŒ–æ€§èƒ½
   - è™•ç†ç•°å¸¸
   - æä¾›çµæœ

3. æ©Ÿå™¨å­¸ç¿’
   - é¸æ“‡åˆé©ç®—æ³•
   - å„ªåŒ–æ€§èƒ½
   - è™•ç†ç•°å¸¸
   - æä¾›ç›£æ§

4. èª¿è©¦æŠ€å·§
   - ä½¿ç”¨é–‹ç™¼å·¥å…·
   - åˆ†ææ€§èƒ½
   - å„ªåŒ–é—œéµè·¯å¾‘
   - ç›£æ§è¨“ç·´ç‹€æ…‹

[ä¸Šä¸€ç« ï¼šæ©Ÿå™¨å­¸ç¿’åŸºç¤](096_æ©Ÿå™¨å­¸ç¿’åŸºç¤.md) | [ä¸‹ä¸€ç« ï¼šæ·±åº¦å­¸ç¿’åŸºç¤](098_æ·±åº¦å­¸ç¿’åŸºç¤.md) 