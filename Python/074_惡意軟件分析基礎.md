[ä¸Šä¸€ç« ï¼šç¶²çµ¡æ”»é˜²é€²éš](073_ç¶²çµ¡æ”»é˜²é€²éš.md) | [ä¸‹ä¸€ç« ï¼šæƒ¡æ„è»Ÿä»¶åˆ†æé€²éš](075_æƒ¡æ„è»Ÿä»¶åˆ†æé€²éš.md)

# Python æƒ¡æ„è»Ÿä»¶åˆ†æåŸºç¤ ğŸ”

## éœæ…‹åˆ†æ

### 1. PEæ–‡ä»¶åˆ†æå™¨

```python
import pefile
import os
from typing import Dict, List, Optional
import datetime

class PEAnalyzer:
    def __init__(self, file_path: str):
        """åˆå§‹åŒ–PEæ–‡ä»¶åˆ†æå™¨"""
        self.file_path = file_path
        self.pe = None
        self.load_file()
    
    def load_file(self):
        """åŠ è¼‰PEæ–‡ä»¶"""
        try:
            self.pe = pefile.PE(self.file_path)
        except Exception as e:
            print(f"Error loading PE file: {e}")
    
    def get_basic_info(self) -> Dict:
        """ç²å–åŸºæœ¬ä¿¡æ¯"""
        if not self.pe:
            return {}
        
        try:
            return {
                'machine': hex(self.pe.FILE_HEADER.Machine),
                'number_of_sections': self.pe.FILE_HEADER.NumberOfSections,
                'timestamp': datetime.datetime.fromtimestamp(
                    self.pe.FILE_HEADER.TimeDateStamp
                ).strftime('%Y-%m-%d %H:%M:%S'),
                'characteristics': hex(self.pe.FILE_HEADER.Characteristics),
                'optional_header_size': self.pe.FILE_HEADER.SizeOfOptionalHeader,
                'entry_point': hex(self.pe.OPTIONAL_HEADER.AddressOfEntryPoint),
                'image_base': hex(self.pe.OPTIONAL_HEADER.ImageBase),
                'section_alignment': hex(self.pe.OPTIONAL_HEADER.SectionAlignment),
                'file_alignment': hex(self.pe.OPTIONAL_HEADER.FileAlignment),
                'subsystem': hex(self.pe.OPTIONAL_HEADER.Subsystem),
                'dll_characteristics': hex(self.pe.OPTIONAL_HEADER.DllCharacteristics)
            }
        except Exception as e:
            print(f"Error getting basic info: {e}")
            return {}
    
    def get_sections(self) -> List[Dict]:
        """ç²å–ç¯€ä¿¡æ¯"""
        if not self.pe:
            return []
        
        try:
            sections = []
            for section in self.pe.sections:
                sections.append({
                    'name': section.Name.decode().rstrip('\x00'),
                    'virtual_address': hex(section.VirtualAddress),
                    'virtual_size': hex(section.Misc_VirtualSize),
                    'raw_size': hex(section.SizeOfRawData),
                    'raw_address': hex(section.PointerToRawData),
                    'characteristics': hex(section.Characteristics)
                })
            return sections
        except Exception as e:
            print(f"Error getting sections: {e}")
            return []
    
    def get_imports(self) -> Dict[str, List[str]]:
        """ç²å–å°å…¥å‡½æ•¸"""
        if not self.pe:
            return {}
        
        try:
            imports = {}
            if hasattr(self.pe, 'DIRECTORY_ENTRY_IMPORT'):
                for entry in self.pe.DIRECTORY_ENTRY_IMPORT:
                    dll_name = entry.dll.decode()
                    imports[dll_name] = []
                    
                    for imp in entry.imports:
                        if imp.name:
                            imports[dll_name].append(imp.name.decode())
            
            return imports
        except Exception as e:
            print(f"Error getting imports: {e}")
            return {}
    
    def get_exports(self) -> List[str]:
        """ç²å–å°å‡ºå‡½æ•¸"""
        if not self.pe:
            return []
        
        try:
            exports = []
            if hasattr(self.pe, 'DIRECTORY_ENTRY_EXPORT'):
                for exp in self.pe.DIRECTORY_ENTRY_EXPORT.symbols:
                    if exp.name:
                        exports.append(exp.name.decode())
            return exports
        except Exception as e:
            print(f"Error getting exports: {e}")
            return []
    
    def get_resources(self) -> List[Dict]:
        """ç²å–è³‡æºä¿¡æ¯"""
        if not self.pe:
            return []
        
        try:
            resources = []
            if hasattr(self.pe, 'DIRECTORY_ENTRY_RESOURCE'):
                for entry in self.pe.DIRECTORY_ENTRY_RESOURCE.entries:
                    if entry.name:
                        name = entry.name.__str__()
                    else:
                        name = str(entry.struct.Id)
                    
                    for entry_name, entry_data in entry.directory.entries.items():
                        if entry_data.data:
                            resources.append({
                                'name': name,
                                'type': str(entry_name),
                                'size': hex(entry_data.data.struct.Size),
                                'offset': hex(entry_data.data.struct.OffsetToData)
                            })
            return resources
        except Exception as e:
            print(f"Error getting resources: {e}")
            return []

# ä½¿ç”¨ç¤ºä¾‹
def main():
    # å‰µå»ºåˆ†æå™¨
    analyzer = PEAnalyzer("test.exe")
    
    # ç²å–åŸºæœ¬ä¿¡æ¯
    print("\nBasic Information:")
    basic_info = analyzer.get_basic_info()
    for key, value in basic_info.items():
        print(f"{key}: {value}")
    
    # ç²å–ç¯€ä¿¡æ¯
    print("\nSections:")
    sections = analyzer.get_sections()
    for section in sections:
        print(f"\nSection: {section['name']}")
        for key, value in section.items():
            if key != 'name':
                print(f"{key}: {value}")
    
    # ç²å–å°å…¥å‡½æ•¸
    print("\nImports:")
    imports = analyzer.get_imports()
    for dll, functions in imports.items():
        print(f"\n{dll}:")
        for func in functions:
            print(f"  {func}")
    
    # ç²å–å°å‡ºå‡½æ•¸
    print("\nExports:")
    exports = analyzer.get_exports()
    for func in exports:
        print(f"  {func}")
    
    # ç²å–è³‡æºä¿¡æ¯
    print("\nResources:")
    resources = analyzer.get_resources()
    for resource in resources:
        print(f"\nResource: {resource['name']}")
        for key, value in resource.items():
            if key != 'name':
                print(f"{key}: {value}")

if __name__ == '__main__':
    main()
```

### 2. å­—ç¬¦ä¸²åˆ†æå™¨

```python
import re
from typing import List, Dict, Optional
import binascii

class StringAnalyzer:
    def __init__(self, file_path: str):
        """åˆå§‹åŒ–å­—ç¬¦ä¸²åˆ†æå™¨"""
        self.file_path = file_path
        self.strings: List[str] = []
        self.suspicious_patterns = {
            'urls': r'https?://[^\s<>"]+|www\.[^\s<>"]+',
            'ip_addresses': r'\b(?:\d{1,3}\.){3}\d{1,3}\b',
            'email_addresses': r'[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}',
            'file_paths': r'[a-zA-Z]:\\[^\\\n]+|/[^/\n]+',
            'api_keys': r'[a-zA-Z0-9]{32,}',
            'base64': r'[A-Za-z0-9+/=]{40,}'
        }
    
    def extract_strings(self, min_length: int = 4) -> List[str]:
        """æå–å­—ç¬¦ä¸²"""
        try:
            with open(self.file_path, 'rb') as f:
                data = f.read()
            
            # ä½¿ç”¨æ­£å‰‡è¡¨é”å¼åŒ¹é…å¯æ‰“å°å­—ç¬¦
            pattern = b'[\x20-\x7E]{%d,}' % min_length
            matches = re.finditer(pattern, data)
            
            strings = []
            for match in matches:
                try:
                    string = match.group().decode('ascii')
                    strings.append(string)
                except:
                    continue
            
            self.strings = strings
            return strings
        
        except Exception as e:
            print(f"Error extracting strings: {e}")
            return []
    
    def analyze_suspicious_patterns(self) -> Dict[str, List[str]]:
        """åˆ†æå¯ç–‘æ¨¡å¼"""
        if not self.strings:
            self.extract_strings()
        
        results = {}
        for pattern_name, pattern in self.suspicious_patterns.items():
            matches = []
            for string in self.strings:
                if re.search(pattern, string):
                    matches.append(string)
            results[pattern_name] = matches
        
        return results
    
    def analyze_encoding(self) -> Dict[str, List[str]]:
        """åˆ†æç·¨ç¢¼"""
        if not self.strings:
            self.extract_strings()
        
        results = {
            'base64': [],
            'hex': [],
            'unicode': []
        }
        
        for string in self.strings:
            # æª¢æŸ¥Base64
            try:
                if re.match(r'^[A-Za-z0-9+/=]+$', string):
                    decoded = binascii.a2b_base64(string)
                    results['base64'].append(f"{string} -> {decoded}")
            except:
                pass
            
            # æª¢æŸ¥åå…­é€²åˆ¶
            try:
                if re.match(r'^[0-9A-Fa-f]+$', string):
                    decoded = binascii.unhexlify(string)
                    results['hex'].append(f"{string} -> {decoded}")
            except:
                pass
            
            # æª¢æŸ¥Unicode
            try:
                if re.match(r'^\\u[0-9A-Fa-f]{4}$', string):
                    decoded = string.encode().decode('unicode-escape')
                    results['unicode'].append(f"{string} -> {decoded}")
            except:
                pass
        
        return results

# ä½¿ç”¨ç¤ºä¾‹
def main():
    # å‰µå»ºåˆ†æå™¨
    analyzer = StringAnalyzer("test.exe")
    
    # æå–å­—ç¬¦ä¸²
    print("Extracting strings...")
    strings = analyzer.extract_strings()
    print(f"Found {len(strings)} strings")
    
    # åˆ†æå¯ç–‘æ¨¡å¼
    print("\nAnalyzing suspicious patterns...")
    patterns = analyzer.analyze_suspicious_patterns()
    for pattern_name, matches in patterns.items():
        print(f"\n{pattern_name}:")
        for match in matches:
            print(f"  {match}")
    
    # åˆ†æç·¨ç¢¼
    print("\nAnalyzing encodings...")
    encodings = analyzer.analyze_encoding()
    for encoding_type, matches in encodings.items():
        print(f"\n{encoding_type}:")
        for match in matches:
            print(f"  {match}")

if __name__ == '__main__':
    main()
```

## ç·´ç¿’é¡Œ

1. **PEæ–‡ä»¶åˆ†æå·¥å…·**
   é–‹ç™¼ä¸€å€‹PEæ–‡ä»¶åˆ†æå·¥å…·ï¼š
   - åˆ†ææ–‡ä»¶çµæ§‹
   - æå–è³‡æºä¿¡æ¯
   - åˆ†æå°å…¥å°å‡º
   - æª¢æ¸¬åŠ æ®¼

2. **å­—ç¬¦ä¸²åˆ†æå·¥å…·**
   å‰µå»ºä¸€å€‹å­—ç¬¦ä¸²åˆ†æå·¥å…·ï¼š
   - æå–å¯è®€å­—ç¬¦ä¸²
   - è­˜åˆ¥ç·¨ç¢¼æ–¹å¼
   - æª¢æ¸¬æ•æ„Ÿä¿¡æ¯
   - ç”Ÿæˆåˆ†æå ±å‘Š

3. **æƒ¡æ„è»Ÿä»¶åˆ†ææ¡†æ¶**
   å¯¦ç¾ä¸€å€‹æƒ¡æ„è»Ÿä»¶åˆ†ææ¡†æ¶ï¼š
   - æ”¯æŒå¤šç¨®æ–‡ä»¶æ ¼å¼
   - æä¾›åˆ†æAPI
   - ç”Ÿæˆåˆ†æå ±å‘Š
   - ç®¡ç†åˆ†æçµæœ

## å°æé†’ ğŸ’¡

1. å®‰å…¨è€ƒæ…®
   - ä½¿ç”¨éš”é›¢ç’°å¢ƒ
   - ä¿è­·åˆ†ææ•¸æ“š
   - é¿å…åŸ·è¡Œæƒ¡æ„ä»£ç¢¼
   - å®šæœŸæ›´æ–°å·¥å…·

2. æ€§èƒ½å„ªåŒ–
   - å„ªåŒ–æ–‡ä»¶è®€å–
   - ä½¿ç”¨ç·©å­˜æ©Ÿåˆ¶
   - æ§åˆ¶å…§å­˜ä½¿ç”¨
   - ä¸¦è¡Œè™•ç†

3. å¯é æ€§
   - è™•ç†æ–‡ä»¶éŒ¯èª¤
   - é©—è­‰æ–‡ä»¶æ ¼å¼
   - è¨˜éŒ„åˆ†ææ—¥èªŒ
   - å‚™ä»½é‡è¦æ•¸æ“š

4. èª¿è©¦æŠ€å·§
   - ä½¿ç”¨èª¿è©¦å·¥å…·
   - åˆ†æéŒ¯èª¤ä¿¡æ¯
   - æ¨¡æ“¬é‹è¡Œç’°å¢ƒ
   - å£“åŠ›æ¸¬è©¦

[ä¸Šä¸€ç« ï¼šç¶²çµ¡æ”»é˜²é€²éš](073_ç¶²çµ¡æ”»é˜²é€²éš.md) | [ä¸‹ä¸€ç« ï¼šæƒ¡æ„è»Ÿä»¶åˆ†æé€²éš](075_æƒ¡æ„è»Ÿä»¶åˆ†æé€²éš.md) 