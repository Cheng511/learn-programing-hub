[ä¸Šä¸€ç« ï¼šå¤šç·šç¨‹åŸºç¤](043_å¤šç·šç¨‹åŸºç¤.md) | [ä¸‹ä¸€ç« ï¼šå¤šé€²ç¨‹ç·¨ç¨‹](045_å¤šé€²ç¨‹ç·¨ç¨‹.md)

# Python å¤šç·šç¨‹é€²éš ğŸ”„

## ç·šç¨‹å®‰å…¨

### 1. ç·šç¨‹å±€éƒ¨å­˜å„²

```python
import threading
from threading import local

# å‰µå»ºç·šç¨‹å±€éƒ¨å­˜å„²
thread_data = local()

def worker():
    """ç·šç¨‹å·¥ä½œå‡½æ•¸"""
    # è¨­ç½®ç·šç¨‹å±€éƒ¨æ•¸æ“š
    thread_data.value = threading.current_thread().name
    print(f"ç·šç¨‹ {thread_data.value} è¨­ç½®äº†å±€éƒ¨æ•¸æ“š")
    process_data()

def process_data():
    """è™•ç†æ•¸æ“š"""
    # è¨ªå•ç·šç¨‹å±€éƒ¨æ•¸æ“š
    print(f"è™•ç†ä¾†è‡ªç·šç¨‹ {thread_data.value} çš„æ•¸æ“š")

# å‰µå»ºå¤šå€‹ç·šç¨‹
threads = [threading.Thread(target=worker) for _ in range(3)]
for thread in threads:
    thread.start()
for thread in threads:
    thread.join()
```

### 2. é‡å…¥é–

```python
import threading

class ReentrantLockExample:
    def __init__(self):
        self.lock = threading.RLock()
        self.data = 0
    
    def outer_method(self):
        with self.lock:
            print("é€²å…¥å¤–éƒ¨æ–¹æ³•")
            self.inner_method()
    
    def inner_method(self):
        with self.lock:
            print("é€²å…¥å…§éƒ¨æ–¹æ³•")
            self.data += 1

# ä½¿ç”¨é‡å…¥é–
example = ReentrantLockExample()
threads = []

for _ in range(5):
    thread = threading.Thread(target=example.outer_method)
    threads.append(thread)
    thread.start()

for thread in threads:
    thread.join()
```

## é«˜ç´šåŒæ­¥åŸèª

### 1. ä¿¡è™Ÿé‡

```python
import threading
import time
from threading import Semaphore

class ResourcePool:
    def __init__(self, size):
        self.semaphore = Semaphore(size)
        self.resources = list(range(size))
        self.lock = threading.Lock()
    
    def acquire_resource(self):
        """ç²å–è³‡æº"""
        self.semaphore.acquire()
        with self.lock:
            resource = self.resources.pop()
            print(f"ç²å–è³‡æº {resource}")
            return resource
    
    def release_resource(self, resource):
        """é‡‹æ”¾è³‡æº"""
        with self.lock:
            self.resources.append(resource)
            print(f"é‡‹æ”¾è³‡æº {resource}")
        self.semaphore.release()

def worker(pool):
    """å·¥ä½œç·šç¨‹"""
    resource = pool.acquire_resource()
    time.sleep(1)  # ä½¿ç”¨è³‡æº
    pool.release_resource(resource)

# ä½¿ç”¨è³‡æºæ± 
pool = ResourcePool(3)
threads = []

for i in range(5):
    thread = threading.Thread(target=worker, args=(pool,))
    threads.append(thread)
    thread.start()

for thread in threads:
    thread.join()
```

### 2. å±éšœ

```python
from threading import Barrier, Thread
import time

class DataProcessor:
    def __init__(self, num_threads):
        self.barrier = Barrier(num_threads)
        self.data = []
    
    def process_phase(self, thread_id):
        """è™•ç†éšæ®µ"""
        print(f"ç·šç¨‹ {thread_id} é–‹å§‹ç¬¬ä¸€éšæ®µ")
        time.sleep(1)
        self.data.append(f"Data from thread {thread_id}")
        
        # ç­‰å¾…æ‰€æœ‰ç·šç¨‹å®Œæˆç¬¬ä¸€éšæ®µ
        self.barrier.wait()
        
        print(f"ç·šç¨‹ {thread_id} é–‹å§‹ç¬¬äºŒéšæ®µ")
        time.sleep(1)
        
        # ç­‰å¾…æ‰€æœ‰ç·šç¨‹å®Œæˆç¬¬äºŒéšæ®µ
        self.barrier.wait()
        
        print(f"ç·šç¨‹ {thread_id} å®Œæˆæ‰€æœ‰è™•ç†")

# ä½¿ç”¨å±éšœåŒæ­¥
processor = DataProcessor(3)
threads = []

for i in range(3):
    thread = Thread(target=processor.process_phase, args=(i,))
    threads.append(thread)
    thread.start()

for thread in threads:
    thread.join()
```

## ç·šç¨‹èª¿åº¦

### 1. å„ªå…ˆç´šéšŠåˆ—

```python
from queue import PriorityQueue
import threading
import time

class Task:
    def __init__(self, priority, name):
        self.priority = priority
        self.name = name
    
    def __lt__(self, other):
        return self.priority < other.priority

class PriorityTaskScheduler:
    def __init__(self):
        self.queue = PriorityQueue()
        self.running = True
    
    def add_task(self, task):
        """æ·»åŠ ä»»å‹™"""
        self.queue.put(task)
    
    def process_tasks(self):
        """è™•ç†ä»»å‹™"""
        while self.running:
            try:
                task = self.queue.get(timeout=1)
                print(f"è™•ç†ä»»å‹™: {task.name} (å„ªå…ˆç´š: {task.priority})")
                time.sleep(0.5)
                self.queue.task_done()
            except:
                continue
    
    def stop(self):
        """åœæ­¢è™•ç†"""
        self.running = False

# ä½¿ç”¨å„ªå…ˆç´šèª¿åº¦å™¨
scheduler = PriorityTaskScheduler()

# å‰µå»ºè™•ç†ç·šç¨‹
processor = threading.Thread(target=scheduler.process_tasks)
processor.start()

# æ·»åŠ ä»»å‹™
tasks = [
    Task(3, "Low priority task"),
    Task(1, "High priority task"),
    Task(2, "Medium priority task")
]

for task in tasks:
    scheduler.add_task(task)

time.sleep(3)
scheduler.stop()
processor.join()
```

### 2. å®šæ™‚åŸ·è¡Œ

```python
import threading
import time
from datetime import datetime, timedelta

class TimedTaskScheduler:
    def __init__(self):
        self.tasks = []
        self.condition = threading.Condition()
        self.running = True
    
    def schedule_task(self, task, delay):
        """èª¿åº¦ä»»å‹™"""
        execution_time = datetime.now() + timedelta(seconds=delay)
        with self.condition:
            self.tasks.append((execution_time, task))
            self.tasks.sort()  # æŒ‰åŸ·è¡Œæ™‚é–“æ’åº
            self.condition.notify()
    
    def run(self):
        """é‹è¡Œèª¿åº¦å™¨"""
        while self.running:
            with self.condition:
                while self.running and (not self.tasks or 
                      self.tasks[0][0] > datetime.now()):
                    if not self.tasks:
                        self.condition.wait()
                    else:
                        wait_time = (self.tasks[0][0] - datetime.now()).total_seconds()
                        if wait_time > 0:
                            self.condition.wait(wait_time)
                
                if not self.running:
                    break
                
                if self.tasks:
                    execution_time, task = self.tasks.pop(0)
                    threading.Thread(target=task).start()
    
    def stop(self):
        """åœæ­¢èª¿åº¦å™¨"""
        with self.condition:
            self.running = False
            self.condition.notify()

# ä½¿ç”¨å®šæ™‚ä»»å‹™èª¿åº¦å™¨
def task1():
    print(f"åŸ·è¡Œä»»å‹™1: {datetime.now()}")

def task2():
    print(f"åŸ·è¡Œä»»å‹™2: {datetime.now()}")

scheduler = TimedTaskScheduler()
scheduler_thread = threading.Thread(target=scheduler.run)
scheduler_thread.start()

# èª¿åº¦ä»»å‹™
scheduler.schedule_task(task1, 2)  # 2ç§’å¾ŒåŸ·è¡Œ
scheduler.schedule_task(task2, 4)  # 4ç§’å¾ŒåŸ·è¡Œ

time.sleep(5)
scheduler.stop()
scheduler_thread.join()
```

## æ€§èƒ½å„ªåŒ–

### 1. ç·šç¨‹æ± å„ªåŒ–

```python
from concurrent.futures import ThreadPoolExecutor
import threading
import time

class OptimizedThreadPool:
    def __init__(self, max_workers):
        self.executor = ThreadPoolExecutor(
            max_workers=max_workers,
            thread_name_prefix="Worker"
        )
        self.tasks_completed = 0
        self.lock = threading.Lock()
    
    def process_task(self, task_id):
        """è™•ç†ä»»å‹™"""
        start_time = time.time()
        result = self._execute_task(task_id)
        duration = time.time() - start_time
        
        with self.lock:
            self.tasks_completed += 1
            print(f"ä»»å‹™ {task_id} å®Œæˆï¼Œè€—æ™‚: {duration:.2f}ç§’")
        
        return result
    
    def _execute_task(self, task_id):
        """åŸ·è¡Œå…·é«”ä»»å‹™"""
        time.sleep(0.1)  # æ¨¡æ“¬å·¥ä½œè² è¼‰
        return f"Task {task_id} result"
    
    def submit_tasks(self, num_tasks):
        """æäº¤å¤šå€‹ä»»å‹™"""
        futures = []
        for i in range(num_tasks):
            future = self.executor.submit(self.process_task, i)
            futures.append(future)
        return futures

# ä½¿ç”¨å„ªåŒ–çš„ç·šç¨‹æ± 
pool = OptimizedThreadPool(4)
futures = pool.submit_tasks(10)

# ç­‰å¾…æ‰€æœ‰ä»»å‹™å®Œæˆ
for future in futures:
    result = future.result()
    print(f"ç²å¾—çµæœ: {result}")
```

### 2. è³‡æºç›£æ§

```python
import psutil
import threading
import time
from collections import deque

class ThreadMonitor:
    def __init__(self, interval=1):
        self.interval = interval
        self.history = deque(maxlen=60)  # ä¿å­˜æœ€è¿‘60ç§’çš„æ•¸æ“š
        self.running = True
    
    def start_monitoring(self):
        """é–‹å§‹ç›£æ§"""
        self.monitor_thread = threading.Thread(target=self._monitor)
        self.monitor_thread.start()
    
    def stop_monitoring(self):
        """åœæ­¢ç›£æ§"""
        self.running = False
        self.monitor_thread.join()
    
    def _monitor(self):
        """ç›£æ§ç·šç¨‹"""
        while self.running:
            stats = self._collect_stats()
            self.history.append(stats)
            time.sleep(self.interval)
    
    def _collect_stats(self):
        """æ”¶é›†çµ±è¨ˆæ•¸æ“š"""
        process = psutil.Process()
        return {
            'timestamp': time.time(),
            'cpu_percent': process.cpu_percent(),
            'memory_percent': process.memory_percent(),
            'num_threads': process.num_threads(),
            'connections': len(process.connections())
        }
    
    def get_stats(self):
        """ç²å–çµ±è¨ˆæ•¸æ“š"""
        if not self.history:
            return None
        
        latest = self.history[-1]
        avg_cpu = sum(s['cpu_percent'] for s in self.history) / len(self.history)
        avg_memory = sum(s['memory_percent'] for s in self.history) / len(self.history)
        
        return {
            'current': latest,
            'averages': {
                'cpu_percent': avg_cpu,
                'memory_percent': avg_memory
            }
        }

# ä½¿ç”¨ç·šç¨‹ç›£æ§å™¨
monitor = ThreadMonitor()
monitor.start_monitoring()

# åŸ·è¡Œä¸€äº›å·¥ä½œ
def heavy_task():
    time.sleep(2)
    data = [i * i for i in range(1000000)]

threads = []
for _ in range(3):
    thread = threading.Thread(target=heavy_task)
    threads.append(thread)
    thread.start()

# ç­‰å¾…ä»»å‹™å®Œæˆ
for thread in threads:
    thread.join()

# ç²å–çµ±è¨ˆæ•¸æ“š
stats = monitor.get_stats()
print("æ€§èƒ½çµ±è¨ˆ:")
print(f"CPU ä½¿ç”¨ç‡: {stats['current']['cpu_percent']}%")
print(f"å…§å­˜ä½¿ç”¨ç‡: {stats['current']['memory_percent']}%")
print(f"ç·šç¨‹æ•¸: {stats['current']['num_threads']}")

monitor.stop_monitoring()
```

## å¯¦éš›æ‡‰ç”¨ç¯„ä¾‹

### 1. ä¸¦è¡Œæ—¥èªŒè™•ç†å™¨

```python
import threading
from queue import Queue
import logging
from concurrent.futures import ThreadPoolExecutor
import time

class LogProcessor:
    def __init__(self, num_workers=3):
        self.log_queue = Queue()
        self.processed_logs = []
        self.lock = threading.Lock()
        self.num_workers = num_workers
        self.executor = ThreadPoolExecutor(max_workers=num_workers)
        
        # è¨­ç½®æ—¥èªŒ
        logging.basicConfig(level=logging.INFO)
        self.logger = logging.getLogger(__name__)
    
    def process_log(self, log_entry):
        """è™•ç†å–®æ¢æ—¥èªŒ"""
        try:
            # æ¨¡æ“¬æ—¥èªŒè™•ç†
            time.sleep(0.1)
            processed = f"Processed: {log_entry}"
            
            with self.lock:
                self.processed_logs.append(processed)
                self.logger.info(f"è™•ç†æ—¥èªŒ: {log_entry}")
            
            return processed
        except Exception as e:
            self.logger.error(f"è™•ç†æ—¥èªŒæ™‚å‡ºéŒ¯: {e}")
            return None
    
    def batch_process(self, log_entries):
        """æ‰¹é‡è™•ç†æ—¥èªŒ"""
        futures = []
        for entry in log_entries:
            future = self.executor.submit(self.process_log, entry)
            futures.append(future)
        
        results = []
        for future in futures:
            try:
                result = future.result(timeout=5)
                if result:
                    results.append(result)
            except Exception as e:
                self.logger.error(f"ç²å–çµæœæ™‚å‡ºéŒ¯: {e}")
        
        return results
    
    def get_statistics(self):
        """ç²å–è™•ç†çµ±è¨ˆ"""
        with self.lock:
            return {
                'total_processed': len(self.processed_logs),
                'last_10_logs': self.processed_logs[-10:]
            }

# ä½¿ç”¨æ—¥èªŒè™•ç†å™¨
processor = LogProcessor()

# ç”Ÿæˆæ¸¬è©¦æ—¥èªŒ
test_logs = [f"Log entry {i}" for i in range(20)]

# è™•ç†æ—¥èªŒ
results = processor.batch_process(test_logs)

# è¼¸å‡ºçµ±è¨ˆä¿¡æ¯
stats = processor.get_statistics()
print(f"è™•ç†çš„æ—¥èªŒç¸½æ•¸: {stats['total_processed']}")
print("æœ€è¿‘è™•ç†çš„10æ¢æ—¥èªŒ:")
for log in stats['last_10_logs']:
    print(log)
```

### 2. ä¸¦è¡Œä»»å‹™èª¿åº¦ç³»çµ±

```python
import threading
import time
from queue import PriorityQueue
from dataclasses import dataclass, field
from typing import Any, Callable
from datetime import datetime, timedelta

@dataclass(order=True)
class PrioritizedTask:
    priority: int
    execute_time: datetime
    task: Callable = field(compare=False)
    args: tuple = field(default=(), compare=False)
    kwargs: dict = field(default_factory=dict, compare=False)

class TaskScheduler:
    def __init__(self):
        self.task_queue = PriorityQueue()
        self.running = True
        self.lock = threading.Lock()
        self.condition = threading.Condition(self.lock)
        self.workers = []
    
    def schedule_task(self, task, priority=0, delay=0, *args, **kwargs):
        """èª¿åº¦ä»»å‹™"""
        execute_time = datetime.now() + timedelta(seconds=delay)
        task_item = PrioritizedTask(
            priority=priority,
            execute_time=execute_time,
            task=task,
            args=args,
            kwargs=kwargs
        )
        
        with self.lock:
            self.task_queue.put(task_item)
            self.condition.notify()
    
    def _worker(self):
        """å·¥ä½œç·šç¨‹"""
        while self.running:
            with self.lock:
                while self.running and self.task_queue.empty():
                    self.condition.wait()
                
                if not self.running:
                    break
                
                task_item = self.task_queue.get()
                
                # æª¢æŸ¥æ˜¯å¦åˆ°é”åŸ·è¡Œæ™‚é–“
                now = datetime.now()
                if task_item.execute_time > now:
                    wait_time = (task_item.execute_time - now).total_seconds()
                    self.condition.wait(wait_time)
            
            try:
                # åŸ·è¡Œä»»å‹™
                task_item.task(*task_item.args, **task_item.kwargs)
            except Exception as e:
                print(f"åŸ·è¡Œä»»å‹™æ™‚å‡ºéŒ¯: {e}")
    
    def start(self, num_workers=3):
        """å•Ÿå‹•èª¿åº¦å™¨"""
        for _ in range(num_workers):
            worker = threading.Thread(target=self._worker)
            worker.start()
            self.workers.append(worker)
    
    def stop(self):
        """åœæ­¢èª¿åº¦å™¨"""
        self.running = False
        with self.lock:
            self.condition.notify_all()
        
        for worker in self.workers:
            worker.join()

# ä½¿ç”¨ä»»å‹™èª¿åº¦ç³»çµ±
def task1(name):
    print(f"åŸ·è¡Œä»»å‹™1: {name} at {datetime.now()}")

def task2(x, y):
    print(f"åŸ·è¡Œä»»å‹™2: {x} + {y} = {x + y} at {datetime.now()}")

scheduler = TaskScheduler()
scheduler.start(num_workers=2)

# èª¿åº¦ä¸€äº›ä»»å‹™
scheduler.schedule_task(task1, priority=1, delay=2, args=("Task A",))
scheduler.schedule_task(task2, priority=2, delay=1, args=(5, 3))
scheduler.schedule_task(task1, priority=3, delay=3, args=("Task B",))

# é‹è¡Œä¸€æ®µæ™‚é–“å¾Œåœæ­¢
time.sleep(5)
scheduler.stop()
```

## ç·´ç¿’é¡Œ

1. **ä¸¦è¡Œæ•¸æ“šè™•ç†å™¨**
   å¯¦ç¾ä¸€å€‹ä¸¦è¡Œæ•¸æ“šè™•ç†ç³»çµ±ï¼š
   - å¤šç·šç¨‹æ•¸æ“šè®€å–
   - ä¸¦è¡Œæ•¸æ“šè½‰æ›
   - çµæœèšåˆ
   - æ€§èƒ½ç›£æ§

2. **é«˜ç´šä»»å‹™èª¿åº¦å™¨**
   å‰µå»ºä¸€å€‹é«˜ç´šä»»å‹™èª¿åº¦ç³»çµ±ï¼š
   - å„ªå…ˆç´šç®¡ç†
   - å®šæ™‚åŸ·è¡Œ
   - ä¾è³´é—œä¿‚è™•ç†
   - å¤±æ•—é‡è©¦æ©Ÿåˆ¶

3. **è³‡æºæ± ç®¡ç†å™¨**
   é–‹ç™¼ä¸€å€‹è³‡æºæ± ç®¡ç†ç³»çµ±ï¼š
   - å‹•æ…‹èª¿æ•´æ± å¤§å°
   - è³‡æºåˆ†é…ç­–ç•¥
   - ä½¿ç”¨çµ±è¨ˆ
   - æ€§èƒ½å„ªåŒ–

## å°æé†’ ğŸ’¡

1. ä½¿ç”¨é©ç•¶çš„åŒæ­¥æ©Ÿåˆ¶
2. é¿å…éåº¦åŒæ­¥
3. æ³¨æ„æ­»é–é é˜²
4. åˆç†è¨­ç½®è¶…æ™‚
5. ç›£æ§è³‡æºä½¿ç”¨
6. å„ªåŒ–ç·šç¨‹æ•¸é‡

[ä¸Šä¸€ç« ï¼šå¤šç·šç¨‹åŸºç¤](043_å¤šç·šç¨‹åŸºç¤.md) | [ä¸‹ä¸€ç« ï¼šå¤šé€²ç¨‹ç·¨ç¨‹](045_å¤šé€²ç¨‹ç·¨ç¨‹.md) 