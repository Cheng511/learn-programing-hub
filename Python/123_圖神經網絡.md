[ä¸Šä¸€ç« ï¼šç”Ÿæˆå°æŠ—ç¶²çµ¡æ‡‰ç”¨](122_ç”Ÿæˆå°æŠ—ç¶²çµ¡æ‡‰ç”¨.md) | [ä¸‹ä¸€ç« ï¼šè¯é‚¦å­¸ç¿’åŸºç¤](124_è¯é‚¦å­¸ç¿’åŸºç¤.md)

# Python åœ–ç¥ç¶“ç¶²çµ¡ ğŸ•¸ï¸

## 1. åœ–ç¥ç¶“ç¶²çµ¡åŸºç¤

### 1.1 åœ–æ•¸æ“šçµæ§‹

```python
import torch
import torch.nn as nn
import torch.nn.functional as F
from torch_geometric.data import Data
from typing import List, Dict, Tuple
import networkx as nx
import numpy as np

class GraphDataset:
    def __init__(self):
        self.graphs = []
        self.labels = []
    
    def add_graph(self, nodes: torch.Tensor,
                  edges: torch.Tensor,
                  label: torch.Tensor):
        """æ·»åŠ åœ–æ•¸æ“š"""
        graph = Data(
            x=nodes,
            edge_index=edges,
            y=label
        )
        self.graphs.append(graph)
        self.labels.append(label)
    
    def to_networkx(self, idx: int) -> nx.Graph:
        """è½‰æ›ç‚ºNetworkXæ ¼å¼"""
        graph = self.graphs[idx]
        G = nx.Graph()
        
        # æ·»åŠ ç¯€é»
        for i in range(len(graph.x)):
            G.add_node(i, features=graph.x[i].numpy())
        
        # æ·»åŠ é‚Š
        edges = graph.edge_index.t().numpy()
        for edge in edges:
            G.add_edge(edge[0], edge[1])
        
        return G
```

### 1.2 åœ–å·ç©å±¤

```python
class GraphConvolution(nn.Module):
    def __init__(self, in_features: int, out_features: int):
        super().__init__()
        self.weight = nn.Parameter(torch.FloatTensor(in_features, out_features))
        self.bias = nn.Parameter(torch.FloatTensor(out_features))
        self.reset_parameters()
    
    def reset_parameters(self):
        """åˆå§‹åŒ–åƒæ•¸"""
        nn.init.kaiming_uniform_(self.weight)
        nn.init.zeros_(self.bias)
    
    def forward(self, x: torch.Tensor,
                adj: torch.Tensor) -> torch.Tensor:
        """å‰å‘å‚³æ’­"""
        support = torch.mm(x, self.weight)
        output = torch.spmm(adj, support)
        return output + self.bias
```

## 2. é«˜ç´šåœ–ç¥ç¶“ç¶²çµ¡æ¨¡å‹

### 2.1 GraphSAGEå¯¦ç¾

```python
class SAGEConv(nn.Module):
    def __init__(self, in_channels: int, out_channels: int,
                 aggr: str = 'mean'):
        super().__init__()
        self.in_channels = in_channels
        self.out_channels = out_channels
        self.aggr = aggr
        
        self.message_nn = nn.Linear(in_channels * 2, out_channels)
        self.update_nn = nn.Linear(in_channels + out_channels, out_channels)
    
    def forward(self, x: torch.Tensor,
                edge_index: torch.Tensor) -> torch.Tensor:
        """æ¶ˆæ¯å‚³éèˆ‡æ›´æ–°"""
        # æ”¶é›†é„°å±…ä¿¡æ¯
        row, col = edge_index
        x_neighbors = x[col]
        x_central = x[row]
        
        # æ¶ˆæ¯å‚³é
        messages = self.message_nn(torch.cat([x_central, x_neighbors], dim=1))
        
        # èšåˆ
        if self.aggr == 'mean':
            aggr_messages = scatter_mean(messages, row, dim=0, dim_size=len(x))
        elif self.aggr == 'sum':
            aggr_messages = scatter_add(messages, row, dim=0, dim_size=len(x))
        else:
            raise ValueError(f'Unknown aggregation type: {self.aggr}')
        
        # æ›´æ–°
        return self.update_nn(torch.cat([x, aggr_messages], dim=1))
```

### 2.2 GATå¯¦ç¾

```python
class GATConv(nn.Module):
    def __init__(self, in_features: int, out_features: int,
                 heads: int = 1, dropout: float = 0.6,
                 negative_slope: float = 0.2):
        super().__init__()
        self.in_features = in_features
        self.out_features = out_features
        self.heads = heads
        self.dropout = dropout
        self.negative_slope = negative_slope
        
        self.weight = nn.Parameter(
            torch.FloatTensor(in_features, heads * out_features))
        self.att = nn.Parameter(torch.FloatTensor(1, heads, 2 * out_features))
        self.reset_parameters()
    
    def reset_parameters(self):
        """åˆå§‹åŒ–åƒæ•¸"""
        nn.init.xavier_uniform_(self.weight)
        nn.init.xavier_uniform_(self.att)
    
    def forward(self, x: torch.Tensor,
                edge_index: torch.Tensor) -> torch.Tensor:
        """æ³¨æ„åŠ›æ©Ÿåˆ¶çš„æ¶ˆæ¯å‚³é"""
        x = torch.mm(x, self.weight).view(-1, self.heads, self.out_features)
        
        # è¨ˆç®—æ³¨æ„åŠ›ä¿‚æ•¸
        row, col = edge_index
        alpha = torch.cat([x[row], x[col]], dim=-1)
        alpha = (alpha * self.att).sum(dim=-1)
        alpha = F.leaky_relu(alpha, self.negative_slope)
        alpha = softmax(alpha, row, num_nodes=len(x))
        
        # æ‡‰ç”¨æ³¨æ„åŠ›
        out = scatter_add(
            alpha.view(-1, self.heads, 1) * x[col],
            row,
            dim=0,
            dim_size=len(x)
        )
        
        return out.mean(dim=1)
```

## 3. åœ–è¡¨ç¤ºå­¸ç¿’

### 3.1 Node2Vecå¯¦ç¾

```python
class Node2Vec:
    def __init__(self, graph: nx.Graph, dimensions: int = 128,
                 walk_length: int = 80, num_walks: int = 10,
                 p: float = 1.0, q: float = 1.0):
        self.graph = graph
        self.dimensions = dimensions
        self.walk_length = walk_length
        self.num_walks = num_walks
        self.p = p
        self.q = q
        
        self.preprocess_transition_probs()
    
    def node2vec_walk(self, start_node: int) -> List[int]:
        """ç”Ÿæˆéš¨æ©ŸéŠèµ°åºåˆ—"""
        walk = [start_node]
        
        while len(walk) < self.walk_length:
            cur = walk[-1]
            cur_nbrs = list(self.graph.neighbors(cur))
            if len(cur_nbrs) > 0:
                if len(walk) == 1:
                    walk.append(np.random.choice(cur_nbrs))
                else:
                    prev = walk[-2]
                    next_node = self._get_next_node(prev, cur, cur_nbrs)
                    walk.append(next_node)
            else:
                break
        
        return walk
    
    def _get_next_node(self, prev: int, cur: int,
                       neighbors: List[int]) -> int:
        """æ ¹æ“šè½‰ç§»æ¦‚ç‡é¸æ“‡ä¸‹ä¸€å€‹ç¯€é»"""
        probs = []
        for nbr in neighbors:
            if nbr == prev:
                probs.append(1/self.p)
            elif self.graph.has_edge(nbr, prev):
                probs.append(1)
            else:
                probs.append(1/self.q)
        
        probs = np.array(probs)
        probs = probs / probs.sum()
        
        return np.random.choice(neighbors, p=probs)
```

### 3.2 åœ–è‡ªç·¨ç¢¼å™¨

```python
class GraphAutoencoder(nn.Module):
    def __init__(self, input_dim: int, hidden_dim: int):
        super().__init__()
        
        # ç·¨ç¢¼å™¨
        self.encoder = nn.Sequential(
            GraphConvolution(input_dim, 2 * hidden_dim),
            nn.ReLU(),
            GraphConvolution(2 * hidden_dim, hidden_dim)
        )
        
        # è§£ç¢¼å™¨
        self.decoder = nn.Sequential(
            nn.Linear(hidden_dim, 2 * hidden_dim),
            nn.ReLU(),
            nn.Linear(2 * hidden_dim, input_dim),
            nn.Sigmoid()
        )
    
    def forward(self, x: torch.Tensor,
                adj: torch.Tensor) -> Tuple[torch.Tensor, torch.Tensor]:
        """å‰å‘å‚³æ’­"""
        # ç·¨ç¢¼
        z = self.encoder(x, adj)
        
        # è§£ç¢¼
        adj_pred = torch.mm(z, z.t())
        x_pred = self.decoder(z)
        
        return x_pred, adj_pred
```

## ç·´ç¿’é¡Œ ğŸƒ

1. å¯¦ç¾ä¸€å€‹åŸºæ–¼GCNçš„ç¯€é»åˆ†é¡å™¨ã€‚
2. ä½¿ç”¨GraphSAGEé€²è¡Œåœ–åˆ†é¡ä»»å‹™ã€‚
3. é–‹ç™¼ä¸€å€‹åŸºæ–¼GATçš„éˆæ¥é æ¸¬ç³»çµ±ã€‚
4. å¯¦ç¾Node2Vecä¸¦å¯è¦–åŒ–ç¯€é»åµŒå…¥ã€‚
5. è¨­è¨ˆä¸€å€‹åœ–è‡ªç·¨ç¢¼å™¨é€²è¡Œç•°å¸¸æª¢æ¸¬ã€‚

## å°çµ ğŸ“

- å­¸ç¿’äº†åœ–ç¥ç¶“ç¶²çµ¡çš„åŸºæœ¬æ¦‚å¿µ
- æŒæ¡äº†ä¸åŒé¡å‹çš„åœ–å·ç©å±¤
- ç†è§£äº†æ³¨æ„åŠ›æ©Ÿåˆ¶åœ¨åœ–ä¸Šçš„æ‡‰ç”¨
- å­¸æœƒäº†åœ–è¡¨ç¤ºå­¸ç¿’æ–¹æ³•
- äº†è§£äº†åœ–è‡ªç·¨ç¢¼å™¨çš„å¯¦ç¾

## å»¶ä¼¸é–±è®€ ğŸ“š

1. Graph Neural Networks: Foundations and Applications
2. Deep Learning on Graphs
3. Graph Representation Learning
4. Network Science
5. Graph Mining Algorithms

[ä¸Šä¸€ç« ï¼šç”Ÿæˆå°æŠ—ç¶²çµ¡æ‡‰ç”¨](122_ç”Ÿæˆå°æŠ—ç¶²çµ¡æ‡‰ç”¨.md) | [ä¸‹ä¸€ç« ï¼šè¯é‚¦å­¸ç¿’åŸºç¤](124_è¯é‚¦å­¸ç¿’åŸºç¤.md) 