[ä¸Šä¸€ç« ï¼šé€†å‘å·¥ç¨‹åŸºç¤](076_é€†å‘å·¥ç¨‹åŸºç¤.md) | [ä¸‹ä¸€ç« ï¼šè»Ÿä»¶æ¸¬è©¦åŸºç¤](078_è»Ÿä»¶æ¸¬è©¦åŸºç¤.md)

# Python é€†å‘å·¥ç¨‹é€²éš ğŸ”

## ç¨‹åºåˆ†æ

### 1. æ§åˆ¶æµåˆ†æå™¨

```python
import capstone
from typing import List, Dict, Set, Optional
import networkx as nx
import matplotlib.pyplot as plt

class ControlFlowAnalyzer:
    def __init__(self, arch: str = 'x86', mode: str = '32'):
        """åˆå§‹åŒ–æ§åˆ¶æµåˆ†æå™¨"""
        self.arch = arch
        self.mode = mode
        
        # å‰µå»ºCapstoneå¼•æ“
        if arch == 'x86':
            if mode == '32':
                self.cs = capstone.Cs(capstone.CS_ARCH_X86, capstone.CS_MODE_32)
            else:
                self.cs = capstone.Cs(capstone.CS_ARCH_X86, capstone.CS_MODE_64)
        elif arch == 'arm':
            if mode == '32':
                self.cs = capstone.Cs(capstone.CS_ARCH_ARM, capstone.CS_MODE_ARM)
            else:
                self.cs = capstone.Cs(capstone.CS_ARCH_ARM64, capstone.CS_MODE_ARM)
        else:
            raise ValueError(f"Unsupported architecture: {arch}")
        
        # é…ç½®åå½™ç·¨å™¨
        self.cs.detail = True
        self.cs.syntax = capstone.CS_OPT_SYNTAX_ATT
        
        # å‰µå»ºæ§åˆ¶æµåœ–
        self.cfg = nx.DiGraph()
    
    def build_cfg(self, code: bytes, start_address: int = 0x1000) -> nx.DiGraph:
        """æ§‹å»ºæ§åˆ¶æµåœ–"""
        try:
            # æ¸…ç©ºåœ–
            self.cfg.clear()
            
            # åå½™ç·¨ä»£ç¢¼
            instructions = []
            for insn in self.cs.disasm(code, start_address):
                instructions.append({
                    'address': insn.address,
                    'size': insn.size,
                    'mnemonic': insn.mnemonic,
                    'op_str': insn.op_str,
                    'groups': [group.name for group in insn.groups]
                })
            
            # æ·»åŠ ç¯€é»
            for insn in instructions:
                self.cfg.add_node(
                    insn['address'],
                    mnemonic=insn['mnemonic'],
                    op_str=insn['op_str']
                )
            
            # æ·»åŠ é‚Š
            for i, insn in enumerate(instructions):
                current_addr = insn['address']
                next_addr = current_addr + insn['size']
                
                # æ·»åŠ åŸºæœ¬é‚Š
                if i < len(instructions) - 1:
                    self.cfg.add_edge(current_addr, next_addr)
                
                # æ·»åŠ è·³è½‰é‚Š
                if insn['mnemonic'].startswith('j'):
                    target = self._get_jump_target(insn)
                    if target is not None:
                        self.cfg.add_edge(current_addr, target)
                
                # æ·»åŠ èª¿ç”¨é‚Š
                elif insn['mnemonic'] == 'call':
                    target = self._get_call_target(insn)
                    if target is not None:
                        self.cfg.add_edge(current_addr, target)
                        # æ·»åŠ è¿”å›é‚Š
                        if i < len(instructions) - 1:
                            self.cfg.add_edge(target, next_addr)
            
            return self.cfg
        
        except Exception as e:
            print(f"Error building CFG: {e}")
            return nx.DiGraph()
    
    def _get_jump_target(self, insn: Dict) -> Optional[int]:
        """ç²å–è·³è½‰ç›®æ¨™åœ°å€"""
        try:
            if 'immediate' in insn['op_str']:
                # è§£æç«‹å³æ•¸
                target = int(insn['op_str'].split('$')[1], 16)
                return target
            elif '[' in insn['op_str']:
                # è§£æå…§å­˜å¼•ç”¨
                # é€™è£¡éœ€è¦æ›´è¤‡é›œçš„è§£æé‚è¼¯
                return None
            return None
        except:
            return None
    
    def _get_call_target(self, insn: Dict) -> Optional[int]:
        """ç²å–èª¿ç”¨ç›®æ¨™åœ°å€"""
        try:
            if 'immediate' in insn['op_str']:
                # è§£æç«‹å³æ•¸
                target = int(insn['op_str'].split('$')[1], 16)
                return target
            elif '[' in insn['op_str']:
                # è§£æå…§å­˜å¼•ç”¨
                # é€™è£¡éœ€è¦æ›´è¤‡é›œçš„è§£æé‚è¼¯
                return None
            return None
        except:
            return None
    
    def analyze_basic_blocks(self) -> List[Dict]:
        """åˆ†æåŸºæœ¬å¡Š"""
        try:
            blocks = []
            current_block = []
            
            for node in self.cfg.nodes():
                insn = self.cfg.nodes[node]
                
                # æª¢æŸ¥æ˜¯å¦ç‚ºåŸºæœ¬å¡Šçš„é–‹å§‹
                if not current_block or self._is_block_start(node):
                    if current_block:
                        blocks.append(self._create_block(current_block))
                    current_block = []
                
                current_block.append({
                    'address': node,
                    'mnemonic': insn['mnemonic'],
                    'op_str': insn['op_str']
                })
            
            if current_block:
                blocks.append(self._create_block(current_block))
            
            return blocks
        except Exception as e:
            print(f"Error analyzing basic blocks: {e}")
            return []
    
    def _is_block_start(self, address: int) -> bool:
        """æª¢æŸ¥æ˜¯å¦ç‚ºåŸºæœ¬å¡Šçš„é–‹å§‹"""
        # æª¢æŸ¥æ˜¯å¦æœ‰å…¶ä»–é‚ŠæŒ‡å‘æ­¤ç¯€é»
        return len(list(self.cfg.predecessors(address))) > 1
    
    def _create_block(self, instructions: List[Dict]) -> Dict:
        """å‰µå»ºåŸºæœ¬å¡Š"""
        return {
            'start_address': instructions[0]['address'],
            'end_address': instructions[-1]['address'],
            'instructions': instructions,
            'size': instructions[-1]['address'] - instructions[0]['address'] + instructions[-1]['size']
        }
    
    def visualize_cfg(self, output_file: str = 'cfg.png'):
        """å¯è¦–åŒ–æ§åˆ¶æµåœ–"""
        try:
            plt.figure(figsize=(12, 8))
            pos = nx.spring_layout(self.cfg)
            
            # ç¹ªè£½ç¯€é»
            nx.draw_networkx_nodes(
                self.cfg,
                pos,
                node_color='lightblue',
                node_size=1000
            )
            
            # ç¹ªè£½é‚Š
            nx.draw_networkx_edges(
                self.cfg,
                pos,
                edge_color='gray',
                arrows=True
            )
            
            # æ·»åŠ æ¨™ç±¤
            labels = {
                node: f"{hex(node)}\n{self.cfg.nodes[node]['mnemonic']}"
                for node in self.cfg.nodes()
            }
            nx.draw_networkx_labels(self.cfg, pos, labels, font_size=8)
            
            plt.title("Control Flow Graph")
            plt.axis('off')
            plt.savefig(output_file)
            plt.close()
        
        except Exception as e:
            print(f"Error visualizing CFG: {e}")

# ä½¿ç”¨ç¤ºä¾‹
def main():
    # å‰µå»ºåˆ†æå™¨
    analyzer = ControlFlowAnalyzer('x86', '64')
    
    # ç¤ºä¾‹ä»£ç¢¼
    code = bytes([
        0x55,                   # push rbp
        0x48, 0x89, 0xe5,       # mov rbp, rsp
        0x48, 0x83, 0xec, 0x20, # sub rsp, 0x20
        0x48, 0x8b, 0x05, 0x00, # mov rax, qword ptr [rip + 0x0]
        0x00, 0x00, 0x00,
        0x48, 0x89, 0x45, 0xf8, # mov qword ptr [rbp - 0x8], rax
        0x48, 0x8b, 0x45, 0xf8, # mov rax, qword ptr [rbp - 0x8]
        0x48, 0x83, 0xc4, 0x20, # add rsp, 0x20
        0x5d,                   # pop rbp
        0xc3                    # ret
    ])
    
    # æ§‹å»ºæ§åˆ¶æµåœ–
    print("Building control flow graph...")
    cfg = analyzer.build_cfg(code)
    
    # åˆ†æåŸºæœ¬å¡Š
    print("\nAnalyzing basic blocks...")
    blocks = analyzer.analyze_basic_blocks()
    
    print(f"\nFound {len(blocks)} basic blocks:")
    for i, block in enumerate(blocks):
        print(f"\nBlock {i + 1}:")
        print(f"Start address: {hex(block['start_address'])}")
        print(f"End address: {hex(block['end_address'])}")
        print(f"Size: {block['size']} bytes")
        print("Instructions:")
        for insn in block['instructions']:
            print(f"  {hex(insn['address'])}: {insn['mnemonic']} {insn['op_str']}")
    
    # å¯è¦–åŒ–æ§åˆ¶æµåœ–
    print("\nVisualizing control flow graph...")
    analyzer.visualize_cfg()

if __name__ == '__main__':
    main()
```

### 2. æ•¸æ“šæµåˆ†æå™¨

```python
import capstone
from typing import List, Dict, Set, Optional
import networkx as nx
import matplotlib.pyplot as plt

class DataFlowAnalyzer:
    def __init__(self, arch: str = 'x86', mode: str = '32'):
        """åˆå§‹åŒ–æ•¸æ“šæµåˆ†æå™¨"""
        self.arch = arch
        self.mode = mode
        
        # å‰µå»ºCapstoneå¼•æ“
        if arch == 'x86':
            if mode == '32':
                self.cs = capstone.Cs(capstone.CS_ARCH_X86, capstone.CS_MODE_32)
            else:
                self.cs = capstone.Cs(capstone.CS_ARCH_X86, capstone.CS_MODE_64)
        elif arch == 'arm':
            if mode == '32':
                self.cs = capstone.Cs(capstone.CS_ARCH_ARM, capstone.CS_MODE_ARM)
            else:
                self.cs = capstone.Cs(capstone.CS_ARCH_ARM64, capstone.CS_MODE_ARM)
        else:
            raise ValueError(f"Unsupported architecture: {arch}")
        
        # é…ç½®åå½™ç·¨å™¨
        self.cs.detail = True
        self.cs.syntax = capstone.CS_OPT_SYNTAX_ATT
        
        # å‰µå»ºæ•¸æ“šæµåœ–
        self.dfg = nx.DiGraph()
        
        # å®šç¾©å¯„å­˜å™¨
        self.registers = {
            'x86': {
                '32': ['eax', 'ebx', 'ecx', 'edx', 'esi', 'edi', 'ebp', 'esp'],
                '64': ['rax', 'rbx', 'rcx', 'rdx', 'rsi', 'rdi', 'rbp', 'rsp']
            },
            'arm': {
                '32': ['r0', 'r1', 'r2', 'r3', 'r4', 'r5', 'r6', 'r7'],
                '64': ['x0', 'x1', 'x2', 'x3', 'x4', 'x5', 'x6', 'x7']
            }
        }
    
    def build_dfg(self, code: bytes, start_address: int = 0x1000) -> nx.DiGraph:
        """æ§‹å»ºæ•¸æ“šæµåœ–"""
        try:
            # æ¸…ç©ºåœ–
            self.dfg.clear()
            
            # åå½™ç·¨ä»£ç¢¼
            instructions = []
            for insn in self.cs.disasm(code, start_address):
                instructions.append({
                    'address': insn.address,
                    'size': insn.size,
                    'mnemonic': insn.mnemonic,
                    'op_str': insn.op_str,
                    'groups': [group.name for group in insn.groups],
                    'regs_read': [reg.name for reg in insn.regs_read],
                    'regs_write': [reg.name for reg in insn.regs_write]
                })
            
            # æ·»åŠ ç¯€é»
            for insn in instructions:
                self.dfg.add_node(
                    insn['address'],
                    mnemonic=insn['mnemonic'],
                    op_str=insn['op_str'],
                    regs_read=insn['regs_read'],
                    regs_write=insn['regs_write']
                )
            
            # æ·»åŠ é‚Š
            for i, insn in enumerate(instructions):
                current_addr = insn['address']
                
                # åˆ†ææ•¸æ“šä¾è³´
                for reg in insn['regs_read']:
                    # æŸ¥æ‰¾æœ€è¿‘çš„å¯«å…¥
                    for j in range(i - 1, -1, -1):
                        prev_insn = instructions[j]
                        if reg in prev_insn['regs_write']:
                            self.dfg.add_edge(
                                prev_insn['address'],
                                current_addr,
                                reg=reg
                            )
                            break
            
            return self.dfg
        
        except Exception as e:
            print(f"Error building DFG: {e}")
            return nx.DiGraph()
    
    def analyze_data_dependencies(self) -> List[Dict]:
        """åˆ†ææ•¸æ“šä¾è³´"""
        try:
            dependencies = []
            
            # éæ­·æ‰€æœ‰ç¯€é»
            for node in self.dfg.nodes():
                insn = self.dfg.nodes[node]
                
                # æª¢æŸ¥è®€å–
                for reg in insn['regs_read']:
                    # æŸ¥æ‰¾å¯«å…¥è©²å¯„å­˜å™¨çš„æŒ‡ä»¤
                    for pred in self.dfg.predecessors(node):
                        pred_insn = self.dfg.nodes[pred]
                        if reg in pred_insn['regs_write']:
                            dependencies.append({
                                'type': 'read_after_write',
                                'register': reg,
                                'write_instruction': {
                                    'address': pred,
                                    'mnemonic': pred_insn['mnemonic'],
                                    'op_str': pred_insn['op_str']
                                },
                                'read_instruction': {
                                    'address': node,
                                    'mnemonic': insn['mnemonic'],
                                    'op_str': insn['op_str']
                                }
                            })
            
            return dependencies
        except Exception as e:
            print(f"Error analyzing data dependencies: {e}")
            return []
    
    def analyze_register_usage(self) -> Dict[str, List[Dict]]:
        """åˆ†æå¯„å­˜å™¨ä½¿ç”¨"""
        try:
            usage = {}
            
            # åˆå§‹åŒ–å¯„å­˜å™¨ä½¿ç”¨è¨˜éŒ„
            for reg in self.registers[self.arch][self.mode]:
                usage[reg] = []
            
            # éæ­·æ‰€æœ‰ç¯€é»
            for node in self.dfg.nodes():
                insn = self.dfg.nodes[node]
                
                # è¨˜éŒ„è®€å–
                for reg in insn['regs_read']:
                    if reg in usage:
                        usage[reg].append({
                            'type': 'read',
                            'address': node,
                            'mnemonic': insn['mnemonic'],
                            'op_str': insn['op_str']
                        })
                
                # è¨˜éŒ„å¯«å…¥
                for reg in insn['regs_write']:
                    if reg in usage:
                        usage[reg].append({
                            'type': 'write',
                            'address': node,
                            'mnemonic': insn['mnemonic'],
                            'op_str': insn['op_str']
                        })
            
            return usage
        except Exception as e:
            print(f"Error analyzing register usage: {e}")
            return {}
    
    def visualize_dfg(self, output_file: str = 'dfg.png'):
        """å¯è¦–åŒ–æ•¸æ“šæµåœ–"""
        try:
            plt.figure(figsize=(12, 8))
            pos = nx.spring_layout(self.dfg)
            
            # ç¹ªè£½ç¯€é»
            nx.draw_networkx_nodes(
                self.dfg,
                pos,
                node_color='lightgreen',
                node_size=1000
            )
            
            # ç¹ªè£½é‚Š
            nx.draw_networkx_edges(
                self.dfg,
                pos,
                edge_color='gray',
                arrows=True
            )
            
            # æ·»åŠ æ¨™ç±¤
            labels = {
                node: f"{hex(node)}\n{self.dfg.nodes[node]['mnemonic']}"
                for node in self.dfg.nodes()
            }
            nx.draw_networkx_labels(self.dfg, pos, labels, font_size=8)
            
            plt.title("Data Flow Graph")
            plt.axis('off')
            plt.savefig(output_file)
            plt.close()
        
        except Exception as e:
            print(f"Error visualizing DFG: {e}")

# ä½¿ç”¨ç¤ºä¾‹
def main():
    # å‰µå»ºåˆ†æå™¨
    analyzer = DataFlowAnalyzer('x86', '64')
    
    # ç¤ºä¾‹ä»£ç¢¼
    code = bytes([
        0x55,                   # push rbp
        0x48, 0x89, 0xe5,       # mov rbp, rsp
        0x48, 0x83, 0xec, 0x20, # sub rsp, 0x20
        0x48, 0x8b, 0x05, 0x00, # mov rax, qword ptr [rip + 0x0]
        0x00, 0x00, 0x00,
        0x48, 0x89, 0x45, 0xf8, # mov qword ptr [rbp - 0x8], rax
        0x48, 0x8b, 0x45, 0xf8, # mov rax, qword ptr [rbp - 0x8]
        0x48, 0x83, 0xc4, 0x20, # add rsp, 0x20
        0x5d,                   # pop rbp
        0xc3                    # ret
    ])
    
    # æ§‹å»ºæ•¸æ“šæµåœ–
    print("Building data flow graph...")
    dfg = analyzer.build_dfg(code)
    
    # åˆ†ææ•¸æ“šä¾è³´
    print("\nAnalyzing data dependencies...")
    dependencies = analyzer.analyze_data_dependencies()
    
    print(f"\nFound {len(dependencies)} data dependencies:")
    for dep in dependencies:
        print(f"\nType: {dep['type']}")
        print(f"Register: {dep['register']}")
        print("Write instruction:")
        print(f"  {hex(dep['write_instruction']['address'])}: {dep['write_instruction']['mnemonic']} {dep['write_instruction']['op_str']}")
        print("Read instruction:")
        print(f"  {hex(dep['read_instruction']['address'])}: {dep['read_instruction']['mnemonic']} {dep['read_instruction']['op_str']}")
    
    # åˆ†æå¯„å­˜å™¨ä½¿ç”¨
    print("\nAnalyzing register usage...")
    usage = analyzer.analyze_register_usage()
    
    for reg, operations in usage.items():
        print(f"\nRegister {reg}:")
        for op in operations:
            print(f"  {op['type']}: {hex(op['address'])}: {op['mnemonic']} {op['op_str']}")
    
    # å¯è¦–åŒ–æ•¸æ“šæµåœ–
    print("\nVisualizing data flow graph...")
    analyzer.visualize_dfg()

if __name__ == '__main__':
    main()
```

## ç·´ç¿’é¡Œ

1. **æ§åˆ¶æµåˆ†æå·¥å…·**
   é–‹ç™¼ä¸€å€‹æ§åˆ¶æµåˆ†æå·¥å…·ï¼š
   - æ§‹å»ºæ§åˆ¶æµåœ–
   - åˆ†æåŸºæœ¬å¡Š
   - è­˜åˆ¥å¾ªç’°çµæ§‹
   - ç”Ÿæˆåˆ†æå ±å‘Š

2. **æ•¸æ“šæµåˆ†æå·¥å…·**
   å‰µå»ºä¸€å€‹æ•¸æ“šæµåˆ†æå·¥å…·ï¼š
   - æ§‹å»ºæ•¸æ“šæµåœ–
   - åˆ†ææ•¸æ“šä¾è³´
   - è¿½è¹¤è®Šé‡ä½¿ç”¨
   - ç”Ÿæˆåˆ†æå ±å‘Š

3. **ç¨‹åºåˆ†ææ¡†æ¶**
   å¯¦ç¾ä¸€å€‹ç¨‹åºåˆ†ææ¡†æ¶ï¼š
   - æ”¯æŒå¤šç¨®åˆ†æ
   - æä¾›åˆ†æAPI
   - ç”Ÿæˆåˆ†æå ±å‘Š
   - ç®¡ç†åˆ†æçµæœ

## å°æé†’ ğŸ’¡

1. å®‰å…¨è€ƒæ…®
   - ä½¿ç”¨éš”é›¢ç’°å¢ƒ
   - ä¿è­·åˆ†ææ•¸æ“š
   - é¿å…åŸ·è¡Œä»£ç¢¼
   - å®šæœŸæ›´æ–°å·¥å…·

2. æ€§èƒ½å„ªåŒ–
   - å„ªåŒ–åœ–ç®—æ³•
   - ä½¿ç”¨ç·©å­˜æ©Ÿåˆ¶
   - æ§åˆ¶å…§å­˜ä½¿ç”¨
   - ä¸¦è¡Œè™•ç†

3. å¯é æ€§
   - è™•ç†æ–‡ä»¶éŒ¯èª¤
   - é©—è­‰æ–‡ä»¶æ ¼å¼
   - è¨˜éŒ„åˆ†ææ—¥èªŒ
   - å‚™ä»½é‡è¦æ•¸æ“š

4. èª¿è©¦æŠ€å·§
   - ä½¿ç”¨èª¿è©¦å·¥å…·
   - åˆ†æéŒ¯èª¤ä¿¡æ¯
   - æ¨¡æ“¬é‹è¡Œç’°å¢ƒ
   - å£“åŠ›æ¸¬è©¦

[ä¸Šä¸€ç« ï¼šé€†å‘å·¥ç¨‹åŸºç¤](076_é€†å‘å·¥ç¨‹åŸºç¤.md) | [ä¸‹ä¸€ç« ï¼šè»Ÿä»¶æ¸¬è©¦åŸºç¤](078_è»Ÿä»¶æ¸¬è©¦åŸºç¤.md) 