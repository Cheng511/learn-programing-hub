[ä¸Šä¸€ç« ï¼šæ•¸æ“šåº«å„ªåŒ–](112_æ•¸æ“šåº«å„ªåŒ–.md) | [ä¸‹ä¸€ç« ï¼šNoSQLæ•¸æ“šåº«æ‡‰ç”¨](114_NoSQLæ•¸æ“šåº«æ‡‰ç”¨.md)

# Python æ•¸æ“šåº«åˆ†ç‰‡èˆ‡é›†ç¾¤ ğŸ”„

## 1. æ•¸æ“šåº«åˆ†ç‰‡åŸºç¤

### 1.1 åˆ†ç‰‡ç­–ç•¥è¨­è¨ˆ

```python
from typing import List, Dict, Any
import hashlib

class ShardingStrategy:
    def __init__(self, shard_count: int):
        self.shard_count = shard_count
    
    def get_shard_id(self, key: Any) -> int:
        """æ ¹æ“šéµå€¼ç¢ºå®šåˆ†ç‰‡ID"""
        # ä½¿ç”¨ä¸€è‡´æ€§å“ˆå¸Œ
        key_hash = int(hashlib.md5(str(key).encode()).hexdigest(), 16)
        return key_hash % self.shard_count
    
    def get_shard_info(self, key: Any) -> Dict:
        """ç²å–åˆ†ç‰‡ä¿¡æ¯"""
        shard_id = self.get_shard_id(key)
        return {
            'shard_id': shard_id,
            'shard_server': f"shard_{shard_id}.example.com",
            'shard_db': f"db_{shard_id}"
        }
```

### 1.2 åˆ†ç‰‡è·¯ç”±

```python
from typing import List, Dict, Optional
import mysql.connector
from mysql.connector import pooling

class ShardRouter:
    def __init__(self, shard_config: List[Dict]):
        self.shard_config = shard_config
        self.connection_pools = {}
        self._init_connection_pools()
    
    def _init_connection_pools(self):
        """åˆå§‹åŒ–æ‰€æœ‰åˆ†ç‰‡çš„é€£æ¥æ± """
        for shard in self.shard_config:
            pool_config = {
                'pool_name': f"shard_{shard['id']}",
                'pool_size': 5,
                'host': shard['host'],
                'user': shard['user'],
                'password': shard['password'],
                'database': shard['database']
            }
            self.connection_pools[shard['id']] = mysql.connector.pooling.MySQLConnectionPool(**pool_config)
    
    def get_connection(self, shard_id: int):
        """ç²å–æŒ‡å®šåˆ†ç‰‡çš„æ•¸æ“šåº«é€£æ¥"""
        if shard_id in self.connection_pools:
            return self.connection_pools[shard_id].get_connection()
        raise ValueError(f"Invalid shard ID: {shard_id}")
```

## 2. é›†ç¾¤ç®¡ç†

### 2.1 ä¸»å¾è¤‡è£½é…ç½®

```python
from typing import List, Dict
import pymysql

class ReplicationManager:
    def __init__(self, master_config: Dict, slave_configs: List[Dict]):
        self.master_config = master_config
        self.slave_configs = slave_configs
        self.master_conn = None
        self.slave_conns = []
    
    def setup_replication(self):
        """è¨­ç½®ä¸»å¾è¤‡è£½"""
        # é€£æ¥ä¸»æœå‹™å™¨
        self.master_conn = pymysql.connect(**self.master_config)
        
        # ç²å–ä¸»æœå‹™å™¨ç‹€æ…‹
        with self.master_conn.cursor() as cursor:
            cursor.execute("SHOW MASTER STATUS")
            master_status = cursor.fetchone()
        
        # é…ç½®å¾æœå‹™å™¨
        for slave_config in self.slave_configs:
            slave_conn = pymysql.connect(**slave_config)
            with slave_conn.cursor() as cursor:
                # è¨­ç½®ä¸»æœå‹™å™¨ä¿¡æ¯
                cursor.execute(f"""
                    CHANGE MASTER TO
                    MASTER_HOST='{self.master_config['host']}',
                    MASTER_USER='{self.master_config['user']}',
                    MASTER_PASSWORD='{self.master_config['password']}',
                    MASTER_LOG_FILE='{master_status[0]}',
                    MASTER_LOG_POS={master_status[1]}
                """)
                cursor.execute("START SLAVE")
            self.slave_conns.append(slave_conn)
```

### 2.2 è² è¼‰å‡è¡¡

```python
import random
from typing import List, Dict, Optional
from collections import deque

class LoadBalancer:
    def __init__(self, nodes: List[Dict]):
        self.nodes = nodes
        self.active_nodes = nodes.copy()
        self.current = 0  # ç”¨æ–¼è¼ªè©¢ç®—æ³•
        
    def round_robin(self) -> Dict:
        """è¼ªè©¢ç®—æ³•"""
        if not self.active_nodes:
            raise Exception("No available nodes")
        
        node = self.active_nodes[self.current]
        self.current = (self.current + 1) % len(self.active_nodes)
        return node
    
    def random_select(self) -> Dict:
        """éš¨æ©Ÿé¸æ“‡ç®—æ³•"""
        if not self.active_nodes:
            raise Exception("No available nodes")
        return random.choice(self.active_nodes)
    
    def weighted_round_robin(self) -> Dict:
        """åŠ æ¬Šè¼ªè©¢ç®—æ³•"""
        if not self.active_nodes:
            raise Exception("No available nodes")
        
        total_weight = sum(node['weight'] for node in self.active_nodes)
        point = random.randint(0, total_weight - 1)
        
        for node in self.active_nodes:
            if point < node['weight']:
                return node
            point -= node['weight']
```

## 3. æ•¸æ“šåŒæ­¥

### 3.1 å¢é‡åŒæ­¥

```python
from datetime import datetime
from typing import List, Dict, Any

class IncrementalSync:
    def __init__(self, source_db, target_db):
        self.source_db = source_db
        self.target_db = target_db
        self.last_sync_time = None
    
    def sync_changes(self, table_name: str):
        """åŒæ­¥è¡¨çš„è®Šæ›´"""
        if self.last_sync_time is None:
            # é¦–æ¬¡åŒæ­¥ï¼ŒåŸ·è¡Œå®Œæ•´åŒæ­¥
            self._full_sync(table_name)
        else:
            # å¢é‡åŒæ­¥
            changes = self._get_changes(table_name, self.last_sync_time)
            self._apply_changes(table_name, changes)
        
        self.last_sync_time = datetime.now()
    
    def _get_changes(self, table_name: str, since: datetime) -> List[Dict]:
        """ç²å–è¡¨çš„è®Šæ›´è¨˜éŒ„"""
        query = f"""
        SELECT * FROM {table_name}
        WHERE updated_at >= %s
        """
        with self.source_db.cursor() as cursor:
            cursor.execute(query, (since,))
            return cursor.fetchall()
    
    def _apply_changes(self, table_name: str, changes: List[Dict]):
        """æ‡‰ç”¨è®Šæ›´åˆ°ç›®æ¨™æ•¸æ“šåº«"""
        for change in changes:
            self._upsert_record(table_name, change)
```

### 3.2 è¡çªè§£æ±º

```python
from enum import Enum
from typing import Any, Dict, Optional

class ConflictResolutionStrategy(Enum):
    LAST_WRITE_WINS = "last_write_wins"
    MANUAL_RESOLUTION = "manual_resolution"
    MERGE = "merge"

class ConflictResolver:
    def __init__(self, strategy: ConflictResolutionStrategy):
        self.strategy = strategy
    
    def resolve_conflict(self, record1: Dict, record2: Dict) -> Dict:
        """è§£æ±ºæ•¸æ“šè¡çª"""
        if self.strategy == ConflictResolutionStrategy.LAST_WRITE_WINS:
            return self._resolve_last_write_wins(record1, record2)
        elif self.strategy == ConflictResolutionStrategy.MERGE:
            return self._resolve_merge(record1, record2)
        else:
            return self._manual_resolution(record1, record2)
    
    def _resolve_last_write_wins(self, record1: Dict, record2: Dict) -> Dict:
        """ä½¿ç”¨æœ€å¾Œå¯«å…¥ç²å‹ç­–ç•¥"""
        return record1 if record1['updated_at'] > record2['updated_at'] else record2
    
    def _resolve_merge(self, record1: Dict, record2: Dict) -> Dict:
        """åˆä½µå…©æ¢è¨˜éŒ„"""
        merged = {}
        for key in set(record1.keys()) | set(record2.keys()):
            if key not in record2:
                merged[key] = record1[key]
            elif key not in record1:
                merged[key] = record2[key]
            else:
                merged[key] = max(record1[key], record2[key])
        return merged
```

## 4. ç›£æ§èˆ‡ç¶­è­·

### 4.1 é›†ç¾¤ç›£æ§

```python
import time
from typing import Dict, List
import json

class ClusterMonitor:
    def __init__(self, cluster_nodes: List[Dict]):
        self.cluster_nodes = cluster_nodes
        self.metrics = {}
    
    def collect_metrics(self):
        """æ”¶é›†é›†ç¾¤æŒ‡æ¨™"""
        for node in self.cluster_nodes:
            node_metrics = self._get_node_metrics(node)
            self.metrics[node['id']] = node_metrics
    
    def _get_node_metrics(self, node: Dict) -> Dict:
        """ç²å–ç¯€é»æŒ‡æ¨™"""
        with pymysql.connect(**node['connection_info']) as conn:
            cursor = conn.cursor()
            metrics = {}
            
            # æ”¶é›†é€£æ¥æ•¸
            cursor.execute("SHOW STATUS LIKE 'Threads_connected'")
            metrics['connections'] = cursor.fetchone()[1]
            
            # æ”¶é›†æŸ¥è©¢çµ±è¨ˆ
            cursor.execute("SHOW STATUS LIKE 'Queries'")
            metrics['queries'] = cursor.fetchone()[1]
            
            # æ”¶é›†è¤‡è£½ç‹€æ…‹
            if node.get('is_slave', False):
                cursor.execute("SHOW SLAVE STATUS")
                slave_status = cursor.fetchone()
                metrics['replication_lag'] = slave_status[32]  # Seconds_Behind_Master
            
            return metrics
```

### 4.2 æ•…éšœè½‰ç§»

```python
from typing import Optional, Dict
import time

class FailoverManager:
    def __init__(self, cluster_config: Dict):
        self.cluster_config = cluster_config
        self.current_master = cluster_config['master']
        self.slaves = cluster_config['slaves']
    
    def check_master_health(self) -> bool:
        """æª¢æŸ¥ä¸»ç¯€é»å¥åº·ç‹€æ…‹"""
        try:
            conn = pymysql.connect(**self.current_master['connection_info'])
            with conn.cursor() as cursor:
                cursor.execute("SELECT 1")
                return True
        except:
            return False
    
    def perform_failover(self) -> Optional[Dict]:
        """åŸ·è¡Œæ•…éšœè½‰ç§»"""
        # é¸æ“‡æ–°çš„ä¸»ç¯€é»
        new_master = self._select_new_master()
        if not new_master:
            return None
        
        try:
            # åœæ­¢æ‰€æœ‰å¾ç¯€é»çš„è¤‡è£½
            self._stop_all_slaves()
            
            # æå‡æ–°çš„ä¸»ç¯€é»
            self._promote_to_master(new_master)
            
            # é‡æ–°é…ç½®å…¶ä»–å¾ç¯€é»
            self._reconfigure_slaves(new_master)
            
            return new_master
        except Exception as e:
            print(f"Failover failed: {e}")
            return None
```

## ç·´ç¿’é¡Œ ğŸƒ

1. å¯¦ç¾ä¸€å€‹åŸºæ–¼ç¯„åœçš„åˆ†ç‰‡ç­–ç•¥ã€‚
2. è¨­è¨ˆä¸¦å¯¦ç¾ä¸€å€‹ç°¡å–®çš„è®€å¯«åˆ†é›¢ç³»çµ±ã€‚
3. é–‹ç™¼ä¸€å€‹è‡ªå‹•æ•…éšœè½‰ç§»çš„è…³æœ¬ã€‚
4. å¯¦ç¾ä¸€å€‹åˆ†å¸ƒå¼äº‹å‹™ç®¡ç†å™¨ã€‚
5. å‰µå»ºä¸€å€‹é›†ç¾¤æ€§èƒ½ç›£æ§å„€è¡¨æ¿ã€‚

## å°çµ ğŸ“

- å­¸ç¿’äº†æ•¸æ“šåº«åˆ†ç‰‡çš„åŸºæœ¬æ¦‚å¿µå’Œå¯¦ç¾
- æŒæ¡äº†ä¸»å¾è¤‡è£½çš„é…ç½®æ–¹æ³•
- ç†è§£äº†è² è¼‰å‡è¡¡çš„ä¸åŒç­–ç•¥
- å­¸æœƒäº†è™•ç†æ•¸æ“šåŒæ­¥å’Œè¡çªè§£æ±º
- äº†è§£äº†é›†ç¾¤ç›£æ§å’Œæ•…éšœè½‰ç§»çš„å¯¦ç¾

## å»¶ä¼¸é–±è®€ ğŸ“š

1. åˆ†å¸ƒå¼æ•¸æ“šåº«ç³»çµ±åŸç†
2. MySQLé›†ç¾¤éƒ¨ç½²æœ€ä½³å¯¦è¸
3. æ•¸æ“šåº«é«˜å¯ç”¨æ¶æ§‹è¨­è¨ˆ
4. åˆ†å¸ƒå¼äº‹å‹™å¯¦ç¾æ–¹æ¡ˆ
5. æ•¸æ“šåº«ç½é›£æ¢å¾©ç­–ç•¥

[ä¸Šä¸€ç« ï¼šæ•¸æ“šåº«å„ªåŒ–](112_æ•¸æ“šåº«å„ªåŒ–.md) | [ä¸‹ä¸€ç« ï¼šNoSQLæ•¸æ“šåº«æ‡‰ç”¨](114_NoSQLæ•¸æ“šåº«æ‡‰ç”¨.md) 