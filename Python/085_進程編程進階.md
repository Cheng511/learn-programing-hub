[ä¸Šä¸€ç« ï¼šé€²ç¨‹ç·¨ç¨‹åŸºç¤](084_é€²ç¨‹ç·¨ç¨‹åŸºç¤.md) | [ä¸‹ä¸€ç« ï¼šç¶²çµ¡ç·¨ç¨‹åŸºç¤](086_ç¶²çµ¡ç·¨ç¨‹åŸºç¤.md)

# Python é€²ç¨‹ç·¨ç¨‹é€²éš ğŸ”„

## é€²ç¨‹æ± å„ªåŒ–

### 1. é€²ç¨‹æ± ç®¡ç†å™¨

```python
import multiprocessing
from multiprocessing import Pool, Process, Queue, Manager
import time
from typing import List, Dict, Any, Callable, Optional
import sys
import os
from concurrent.futures import ProcessPoolExecutor

class ProcessPoolManager:
    def __init__(self, max_workers: int = None):
        """åˆå§‹åŒ–é€²ç¨‹æ± ç®¡ç†å™¨"""
        self.max_workers = max_workers or os.cpu_count() or 1
        self.executor = ProcessPoolExecutor(max_workers=self.max_workers)
        self.manager = Manager()
        self.shared_data = self.manager.dict()
        self.task_queue = self.manager.Queue()
        self.result_queue = self.manager.Queue()
        self.is_running = False
        self.results: Dict[str, Any] = {}
    
    def start(self):
        """å•Ÿå‹•é€²ç¨‹æ± ç®¡ç†å™¨"""
        self.is_running = True
        self._start_worker_processes()
    
    def stop(self):
        """åœæ­¢é€²ç¨‹æ± ç®¡ç†å™¨"""
        self.is_running = False
        for _ in range(self.max_workers):
            self.task_queue.put(None)
        
        self.executor.shutdown()
    
    def _start_worker_processes(self):
        """å•Ÿå‹•å·¥ä½œé€²ç¨‹"""
        for _ in range(self.max_workers):
            process = Process(
                target=self._worker_loop,
                args=(self.task_queue, self.result_queue, self.shared_data)
            )
            process.daemon = True
            process.start()
    
    def submit_task(self, task_id: str, func: Callable, *args, **kwargs):
        """æäº¤ä»»å‹™"""
        self.task_queue.put((task_id, func, args, kwargs))
    
    @staticmethod
    def _worker_loop(task_queue: Queue, result_queue: Queue, shared_data: Dict):
        """å·¥ä½œé€²ç¨‹å¾ªç’°"""
        while True:
            try:
                task = task_queue.get(timeout=1)
                if task is None:
                    break
                
                task_id, func, args, kwargs = task
                
                try:
                    # ä½¿ç”¨é€²ç¨‹æ± åŸ·è¡Œä»»å‹™
                    result = func(*args, **kwargs)
                    result_queue.put((task_id, result, None))
                
                except Exception as e:
                    result_queue.put((task_id, None, e))
                
                finally:
                    task_queue.task_done()
            
            except queue.Empty:
                continue
    
    def get_result(self, task_id: str, timeout: float = None) -> Any:
        """ç²å–ä»»å‹™çµæœ"""
        while True:
            try:
                result_task_id, result, error = self.result_queue.get(timeout=timeout)
                if result_task_id == task_id:
                    if error:
                        raise error
                    return result
                else:
                    self.result_queue.put((result_task_id, result, error))
            
            except queue.Empty:
                raise TimeoutError(f"Timeout waiting for task {task_id}")
    
    def map_tasks(self, func: Callable, items: List[Any], **kwargs) -> List[Any]:
        """ä¸¦è¡Œè™•ç†å¤šå€‹ä»»å‹™"""
        futures = []
        for item in items:
            future = self.executor.submit(func, item, **kwargs)
            futures.append(future)
        
        return [future.result() for future in futures]
    
    def batch_process(self, func: Callable, items: List[Any], batch_size: int = 10, **kwargs) -> List[Any]:
        """æ‰¹é‡è™•ç†ä»»å‹™"""
        results = []
        for i in range(0, len(items), batch_size):
            batch = items[i:i + batch_size]
            batch_results = self.map_tasks(func, batch, **kwargs)
            results.extend(batch_results)
        return results
    
    def set_shared_data(self, key: str, value: Any):
        """è¨­ç½®å…±äº«æ•¸æ“š"""
        self.shared_data[key] = value
    
    def get_shared_data(self, key: str) -> Any:
        """ç²å–å…±äº«æ•¸æ“š"""
        return self.shared_data.get(key)

# ä½¿ç”¨ç¤ºä¾‹
def process_item(item: int) -> int:
    """è™•ç†å–®å€‹é …ç›®"""
    time.sleep(0.1)  # æ¨¡æ“¬è™•ç†æ™‚é–“
    return item * item

def main():
    # å‰µå»ºé€²ç¨‹æ± ç®¡ç†å™¨
    manager = ProcessPoolManager(max_workers=4)
    
    try:
        # å•Ÿå‹•é€²ç¨‹æ± ç®¡ç†å™¨
        manager.start()
        
        # æäº¤å–®å€‹ä»»å‹™
        print("Submitting single task:")
        manager.submit_task("task1", process_item, 5)
        result = manager.get_result("task1")
        print(f"Result: {result}")
        
        # ä¸¦è¡Œè™•ç†å¤šå€‹ä»»å‹™
        print("\nProcessing multiple tasks:")
        items = list(range(10))
        results = manager.map_tasks(process_item, items)
        print(f"Results: {results}")
        
        # æ‰¹é‡è™•ç†ä»»å‹™
        print("\nBatch processing tasks:")
        items = list(range(20))
        results = manager.batch_process(process_item, items, batch_size=5)
        print(f"Results: {results}")
        
        # ä½¿ç”¨å…±äº«æ•¸æ“š
        print("\nUsing shared data:")
        manager.set_shared_data("counter", 0)
        print(f"Shared counter: {manager.get_shared_data('counter')}")
    
    finally:
        # åœæ­¢é€²ç¨‹æ± ç®¡ç†å™¨
        manager.stop()

if __name__ == '__main__':
    main()
```

### 2. é€²ç¨‹ç›£æ§å™¨

```python
import multiprocessing
from multiprocessing import Process, Queue, Manager
import time
import psutil
from typing import List, Dict, Any, Optional
import sys
import os

class ProcessMonitor:
    def __init__(self):
        """åˆå§‹åŒ–é€²ç¨‹ç›£æ§å™¨"""
        self.processes: List[Process] = []
        self.monitor_queue = Queue()
        self.manager = Manager()
        self.monitoring_data = self.manager.dict()
        self.is_running = False
    
    def start(self):
        """å•Ÿå‹•é€²ç¨‹ç›£æ§å™¨"""
        self.is_running = True
        self._start_monitor_process()
    
    def stop(self):
        """åœæ­¢é€²ç¨‹ç›£æ§å™¨"""
        self.is_running = False
        self.monitor_queue.put(None)
    
    def _start_monitor_process(self):
        """å•Ÿå‹•ç›£æ§é€²ç¨‹"""
        process = Process(
            target=self._monitor_loop,
            args=(self.monitor_queue, self.monitoring_data)
        )
        process.daemon = True
        process.start()
        self.processes.append(process)
    
    @staticmethod
    def _monitor_loop(monitor_queue: Queue, monitoring_data: Dict):
        """ç›£æ§å¾ªç’°"""
        while True:
            try:
                command = monitor_queue.get(timeout=1)
                if command is None:
                    break
                
                if command == "get_stats":
                    # ç²å–ç³»çµ±çµ±è¨ˆä¿¡æ¯
                    stats = {
                        'cpu_percent': psutil.cpu_percent(),
                        'memory_percent': psutil.virtual_memory().percent,
                        'disk_usage': psutil.disk_usage('/').percent,
                        'process_count': len(psutil.pids())
                    }
                    monitoring_data['system_stats'] = stats
                
                elif command == "get_process_info":
                    # ç²å–é€²ç¨‹ä¿¡æ¯
                    process_info = []
                    for proc in psutil.process_iter(['pid', 'name', 'cpu_percent', 'memory_percent']):
                        try:
                            process_info.append(proc.info)
                        except (psutil.NoSuchProcess, psutil.AccessDenied):
                            pass
                    monitoring_data['process_info'] = process_info
                
                elif command == "get_network_info":
                    # ç²å–ç¶²çµ¡ä¿¡æ¯
                    network_info = {
                        'bytes_sent': psutil.net_io_counters().bytes_sent,
                        'bytes_recv': psutil.net_io_counters().bytes_recv,
                        'packets_sent': psutil.net_io_counters().packets_sent,
                        'packets_recv': psutil.net_io_counters().packets_recv
                    }
                    monitoring_data['network_info'] = network_info
                
                monitor_queue.task_done()
            
            except queue.Empty:
                continue
    
    def get_system_stats(self) -> Dict[str, float]:
        """ç²å–ç³»çµ±çµ±è¨ˆä¿¡æ¯"""
        self.monitor_queue.put("get_stats")
        while 'system_stats' not in self.monitoring_data:
            time.sleep(0.1)
        return self.monitoring_data['system_stats']
    
    def get_process_info(self) -> List[Dict[str, Any]]:
        """ç²å–é€²ç¨‹ä¿¡æ¯"""
        self.monitor_queue.put("get_process_info")
        while 'process_info' not in self.monitoring_data:
            time.sleep(0.1)
        return self.monitoring_data['process_info']
    
    def get_network_info(self) -> Dict[str, int]:
        """ç²å–ç¶²çµ¡ä¿¡æ¯"""
        self.monitor_queue.put("get_network_info")
        while 'network_info' not in self.monitoring_data:
            time.sleep(0.1)
        return self.monitoring_data['network_info']
    
    def wait_for_all_processes(self):
        """ç­‰å¾…æ‰€æœ‰é€²ç¨‹å®Œæˆ"""
        for process in self.processes:
            process.join()

# ä½¿ç”¨ç¤ºä¾‹
def main():
    # å‰µå»ºé€²ç¨‹ç›£æ§å™¨
    monitor = ProcessMonitor()
    
    try:
        # å•Ÿå‹•ç›£æ§å™¨
        monitor.start()
        
        # ç²å–ç³»çµ±çµ±è¨ˆä¿¡æ¯
        print("System Statistics:")
        stats = monitor.get_system_stats()
        print(f"CPU Usage: {stats['cpu_percent']}%")
        print(f"Memory Usage: {stats['memory_percent']}%")
        print(f"Disk Usage: {stats['disk_usage']}%")
        print(f"Process Count: {stats['process_count']}")
        
        # ç²å–é€²ç¨‹ä¿¡æ¯
        print("\nProcess Information:")
        process_info = monitor.get_process_info()
        for proc in process_info[:5]:  # åªé¡¯ç¤ºå‰5å€‹é€²ç¨‹
            print(f"PID: {proc['pid']}, Name: {proc['name']}, "
                  f"CPU: {proc['cpu_percent']}%, Memory: {proc['memory_percent']}%")
        
        # ç²å–ç¶²çµ¡ä¿¡æ¯
        print("\nNetwork Information:")
        network_info = monitor.get_network_info()
        print(f"Bytes Sent: {network_info['bytes_sent']}")
        print(f"Bytes Received: {network_info['bytes_recv']}")
        print(f"Packets Sent: {network_info['packets_sent']}")
        print(f"Packets Received: {network_info['packets_recv']}")
        
        # ç­‰å¾…ä¸€æ®µæ™‚é–“
        time.sleep(2)
    
    finally:
        # åœæ­¢ç›£æ§å™¨
        monitor.stop()
        monitor.wait_for_all_processes()

if __name__ == '__main__':
    main()
```

## ç·´ç¿’é¡Œ

1. **é€²ç¨‹æ± ç®¡ç†å™¨**
   é–‹ç™¼ä¸€å€‹é€²ç¨‹æ± ç®¡ç†å™¨ï¼š
   - æ”¯æŒä»»å‹™èª¿åº¦
   - è™•ç†ä»»å‹™å–æ¶ˆ
   - å„ªåŒ–è³‡æºä½¿ç”¨
   - æä¾›éŒ¯èª¤è™•ç†

2. **é€²ç¨‹ç›£æ§å™¨**
   å‰µå»ºä¸€å€‹é€²ç¨‹ç›£æ§å™¨ï¼š
   - ç›£æ§ç³»çµ±è³‡æº
   - è¿½è¹¤é€²ç¨‹ç‹€æ…‹
   - å„ªåŒ–ç›£æ§æ•ˆç‡
   - æä¾›è­¦å ±åŠŸèƒ½

3. **é€²ç¨‹æ¡†æ¶**
   å¯¦ç¾ä¸€å€‹é€²ç¨‹æ¡†æ¶ï¼š
   - æ”¯æŒå¤šç¨®é€²ç¨‹æ¨¡å‹
   - æä¾›é«˜ç´šAPI
   - å„ªåŒ–æ€§èƒ½
   - è™•ç†è¤‡é›œå ´æ™¯

## å°æé†’ ğŸ’¡

1. é€²ç¨‹æ± å„ªåŒ–
   - æ§åˆ¶é€²ç¨‹æ•¸é‡
   - å„ªåŒ–è³‡æºåˆ†é…
   - è™•ç†ä»»å‹™èª¿åº¦
   - ç›£æ§é€²ç¨‹ç‹€æ…‹

2. é€²ç¨‹ç›£æ§
   - é¸æ“‡ç›£æ§æŒ‡æ¨™
   - å„ªåŒ–ç›£æ§é–‹éŠ·
   - è™•ç†ç•°å¸¸æƒ…æ³
   - æä¾›è­¦å ±æ©Ÿåˆ¶

3. æ€§èƒ½å„ªåŒ–
   - æ¸›å°‘é€²ç¨‹é–‹éŠ·
   - å„ªåŒ–è³‡æºä½¿ç”¨
   - å¹³è¡¡è² è¼‰
   - æé«˜ååé‡

4. èª¿è©¦æŠ€å·§
   - ä½¿ç”¨èª¿è©¦å·¥å…·
   - åˆ†ææ€§èƒ½ç“¶é ¸
   - å„ªåŒ–é—œéµè·¯å¾‘
   - ç›£æ§ç³»çµ±è³‡æº

[ä¸Šä¸€ç« ï¼šé€²ç¨‹ç·¨ç¨‹åŸºç¤](084_é€²ç¨‹ç·¨ç¨‹åŸºç¤.md) | [ä¸‹ä¸€ç« ï¼šç¶²çµ¡ç·¨ç¨‹åŸºç¤](086_ç¶²çµ¡ç·¨ç¨‹åŸºç¤.md) 