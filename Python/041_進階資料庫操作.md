[ä¸Šä¸€ç« ï¼šè³‡æ–™åº«åŸºç¤](040_è³‡æ–™åº«åŸºç¤.md) | [ä¸‹ä¸€ç« ï¼šè³‡æ–™åº«æœ€ä½³å¯¦è¸](042_è³‡æ–™åº«æœ€ä½³å¯¦è¸.md)

# Python é€²éšè³‡æ–™åº«æ“ä½œ ğŸ¯

## è³‡æ–™åº«é€£æ¥æ± 

### 1. ä½¿ç”¨é€£æ¥æ± 

```python
from sqlalchemy import create_engine
from sqlalchemy.orm import sessionmaker
from sqlalchemy.pool import QueuePool

# å‰µå»ºå¸¶é€£æ¥æ± çš„å¼•æ“
engine = create_engine('postgresql://user:password@localhost/dbname',
                      poolclass=QueuePool,
                      pool_size=5,
                      max_overflow=10,
                      pool_timeout=30)

# å‰µå»ºæœƒè©±å·¥å» 
Session = sessionmaker(bind=engine)

def get_connection():
    """ç²å–æ•¸æ“šåº«é€£æ¥"""
    session = Session()
    try:
        yield session
    finally:
        session.close()
```

### 2. é€£æ¥æ± ç›£æ§

```python
from sqlalchemy import event
from sqlalchemy.engine import Engine
import time

@event.listens_for(Engine, "checkout")
def receive_checkout(dbapi_connection, connection_record, connection_proxy):
    """ç›£æ§é€£æ¥æ± ä½¿ç”¨æƒ…æ³"""
    print(f"Connection checkout: {connection_record}")
    connection_record.info['checkout_time'] = time.time()

@event.listens_for(Engine, "checkin")
def receive_checkin(dbapi_connection, connection_record):
    """ç›£æ§é€£æ¥æ­¸é‚„æƒ…æ³"""
    checkout_time = connection_record.info.get('checkout_time')
    if checkout_time is not None:
        connection_record.info['checkout_time'] = None
        total_time = time.time() - checkout_time
        print(f"Connection checkin: {connection_record}")
        print(f"Connection was checked out for {total_time:.2f} sec")
```

## äº‹å‹™ç®¡ç†

### 1. äº‹å‹™è£é£¾å™¨

```python
from functools import wraps
from sqlalchemy.exc import SQLAlchemyError

def transactional(session):
    def decorator(func):
        @wraps(func)
        def wrapper(*args, **kwargs):
            try:
                result = func(*args, **kwargs)
                session.commit()
                return result
            except Exception as e:
                session.rollback()
                raise e
        return wrapper
    return decorator

# ä½¿ç”¨äº‹å‹™è£é£¾å™¨
@transactional(session)
def transfer_money(from_account, to_account, amount):
    from_account.balance -= amount
    to_account.balance += amount
```

### 2. åµŒå¥—äº‹å‹™

```python
from sqlalchemy.orm import Session
from contextlib import contextmanager

@contextmanager
def nested_transaction(session: Session):
    """è™•ç†åµŒå¥—äº‹å‹™"""
    try:
        if not session.in_transaction():
            with session.begin():
                yield
        else:
            with session.begin_nested():
                yield
    except Exception as e:
        print(f"Transaction failed: {e}")
        raise
```

## æ‰¹é‡æ“ä½œ

### 1. æ‰¹é‡æ’å…¥

```python
from sqlalchemy import insert

def bulk_insert(session, model, data, batch_size=1000):
    """æ‰¹é‡æ’å…¥æ•¸æ“š"""
    for i in range(0, len(data), batch_size):
        batch = data[i:i + batch_size]
        session.execute(
            insert(model),
            batch
        )
        session.commit()
```

### 2. æ‰¹é‡æ›´æ–°

```python
from sqlalchemy import update

def bulk_update(session, model, criteria, values, batch_size=1000):
    """æ‰¹é‡æ›´æ–°æ•¸æ“š"""
    total = session.query(model).filter(criteria).count()
    for offset in range(0, total, batch_size):
        session.execute(
            update(model)
            .where(criteria)
            .values(values)
            .offset(offset)
            .limit(batch_size)
        )
        session.commit()
```

## æŸ¥è©¢å„ªåŒ–

### 1. å»¶é²åŠ è¼‰èˆ‡å³æ™‚åŠ è¼‰

```python
from sqlalchemy.orm import joinedload, selectinload

# å»¶é²åŠ è¼‰
users = session.query(User).all()
for user in users:
    print(user.orders)  # è§¸ç™¼é¡å¤–æŸ¥è©¢

# å³æ™‚åŠ è¼‰
users = session.query(User).options(joinedload(User.orders)).all()
for user in users:
    print(user.orders)  # ä¸æœƒè§¸ç™¼é¡å¤–æŸ¥è©¢
```

### 2. æŸ¥è©¢ç·©å­˜

```python
from functools import lru_cache
from sqlalchemy import text

class QueryCache:
    def __init__(self, session):
        self.session = session
    
    @lru_cache(maxsize=100)
    def get_user_by_id(self, user_id):
        return self.session.query(User).get(user_id)
    
    @lru_cache(maxsize=100)
    def get_active_users(self):
        return self.session.query(User).filter_by(is_active=True).all()
```

## å¯¦éš›æ‡‰ç”¨ç¯„ä¾‹

### 1. é›»å­å•†å‹™è¨‚å–®ç³»çµ±

```python
from datetime import datetime
from sqlalchemy import Column, Integer, String, Float, DateTime, ForeignKey
from sqlalchemy.orm import relationship
from sqlalchemy.ext.declarative import declarative_base

Base = declarative_base()

class Order(Base):
    __tablename__ = 'orders'
    
    id = Column(Integer, primary_key=True)
    user_id = Column(Integer, ForeignKey('users.id'))
    total_amount = Column(Float)
    status = Column(String)
    created_at = Column(DateTime, default=datetime.now)
    
    items = relationship("OrderItem", back_populates="order")
    user = relationship("User", back_populates="orders")

class OrderManager:
    def __init__(self, session):
        self.session = session
    
    @transactional
    def create_order(self, user_id, items):
        order = Order(user_id=user_id)
        for item in items:
            order_item = OrderItem(
                product_id=item['product_id'],
                quantity=item['quantity'],
                price=item['price']
            )
            order.items.append(order_item)
        
        self.session.add(order)
        return order
    
    def get_user_orders(self, user_id):
        return self.session.query(Order)\
            .filter_by(user_id=user_id)\
            .options(joinedload(Order.items))\
            .all()
```

### 2. æ—¥èªŒè¨˜éŒ„ç³»çµ±

```python
from sqlalchemy import Column, Integer, String, DateTime, Text
from datetime import datetime

class LogEntry(Base):
    __tablename__ = 'logs'
    
    id = Column(Integer, primary_key=True)
    level = Column(String)
    message = Column(Text)
    timestamp = Column(DateTime, default=datetime.now)

class LogManager:
    def __init__(self, session):
        self.session = session
    
    def log(self, level, message):
        entry = LogEntry(level=level, message=message)
        self.session.add(entry)
        self.session.commit()
    
    def get_recent_logs(self, limit=100):
        return self.session.query(LogEntry)\
            .order_by(LogEntry.timestamp.desc())\
            .limit(limit)\
            .all()
    
    def clear_old_logs(self, days=30):
        cutoff = datetime.now() - timedelta(days=days)
        self.session.query(LogEntry)\
            .filter(LogEntry.timestamp < cutoff)\
            .delete()
        self.session.commit()
```

## ç·´ç¿’é¡Œ

1. **é€£æ¥æ± ç®¡ç†å™¨**
   å¯¦ç¾ä¸€å€‹é€£æ¥æ± ç®¡ç†å™¨ï¼š
   - è‡ªå‹•æ“´å±•å’Œæ”¶ç¸®æ± å¤§å°
   - ç›£æ§é€£æ¥ä½¿ç”¨æƒ…æ³
   - è™•ç†é€£æ¥è¶…æ™‚
   - å¯¦ç¾é€£æ¥é‡è©¦æ©Ÿåˆ¶

2. **äº‹å‹™ç®¡ç†å™¨**
   å‰µå»ºä¸€å€‹äº‹å‹™ç®¡ç†å™¨ï¼š
   - æ”¯æ´åµŒå¥—äº‹å‹™
   - è‡ªå‹•é‡è©¦æ©Ÿåˆ¶
   - æ­»é–æª¢æ¸¬
   - äº‹å‹™è¶…æ™‚è™•ç†

3. **æŸ¥è©¢å„ªåŒ–å™¨**
   é–‹ç™¼ä¸€å€‹æŸ¥è©¢å„ªåŒ–å·¥å…·ï¼š
   - è‡ªå‹•é¸æ“‡æœ€ä½³åŠ è¼‰ç­–ç•¥
   - å¯¦ç¾æŸ¥è©¢ç·©å­˜
   - ç”ŸæˆåŸ·è¡Œè¨ˆåŠƒ
   - æä¾›å„ªåŒ–å»ºè­°

## å°æé†’ ğŸ’¡

1. åˆç†ä½¿ç”¨é€£æ¥æ± 
2. æ­£ç¢ºç®¡ç†äº‹å‹™ç¯„åœ
3. æ³¨æ„æŸ¥è©¢æ€§èƒ½å„ªåŒ–
4. å¯¦ç¾é©ç•¶çš„éŒ¯èª¤è™•ç†
5. å®šæœŸç¶­è­·æ•¸æ“šåº«
6. ç›£æ§ç³»çµ±æ€§èƒ½

[ä¸Šä¸€ç« ï¼šè³‡æ–™åº«åŸºç¤](040_è³‡æ–™åº«åŸºç¤.md) | [ä¸‹ä¸€ç« ï¼šè³‡æ–™åº«æœ€ä½³å¯¦è¸](042_è³‡æ–™åº«æœ€ä½³å¯¦è¸.md) 