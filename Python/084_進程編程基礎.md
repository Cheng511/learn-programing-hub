[ä¸Šä¸€ç« ï¼šä¸¦ç™¼ç·¨ç¨‹é€²éš](083_ä¸¦ç™¼ç·¨ç¨‹é€²éš.md) | [ä¸‹ä¸€ç« ï¼šé€²ç¨‹ç·¨ç¨‹é€²éš](085_é€²ç¨‹ç·¨ç¨‹é€²éš.md)

# Python é€²ç¨‹ç·¨ç¨‹åŸºç¤ ğŸ”„

## é€²ç¨‹ç®¡ç†

### 1. é€²ç¨‹ç®¡ç†å™¨

```python
import multiprocessing
from multiprocessing import Process, Queue, Pool
import time
from typing import List, Dict, Any, Callable, Optional
import sys
import os

class ProcessManager:
    def __init__(self, num_processes: int = None):
        """åˆå§‹åŒ–é€²ç¨‹ç®¡ç†å™¨"""
        self.num_processes = num_processes or os.cpu_count() or 1
        self.processes: List[Process] = []
        self.task_queue = Queue()
        self.result_queue = Queue()
        self.is_running = False
        self.results: Dict[str, Any] = {}
        self.pool = Pool(processes=self.num_processes)
    
    def start(self):
        """å•Ÿå‹•é€²ç¨‹ç®¡ç†å™¨"""
        self.is_running = True
        self._start_worker_processes()
    
    def stop(self):
        """åœæ­¢é€²ç¨‹ç®¡ç†å™¨"""
        self.is_running = False
        for _ in range(len(self.processes)):
            self.task_queue.put(None)
        
        for process in self.processes:
            process.join()
        
        self.pool.close()
        self.pool.join()
    
    def _start_worker_processes(self):
        """å•Ÿå‹•å·¥ä½œé€²ç¨‹"""
        for _ in range(self.num_processes):
            process = Process(target=self._worker_loop)
            process.daemon = True
            process.start()
            self.processes.append(process)
    
    def submit_task(self, task_id: str, func: Callable, *args, **kwargs):
        """æäº¤ä»»å‹™"""
        self.task_queue.put((task_id, func, args, kwargs))
    
    def _worker_loop(self):
        """å·¥ä½œé€²ç¨‹å¾ªç’°"""
        while self.is_running:
            try:
                task = self.task_queue.get(timeout=1)
                if task is None:
                    break
                
                task_id, func, args, kwargs = task
                
                try:
                    # ä½¿ç”¨é€²ç¨‹æ± åŸ·è¡Œä»»å‹™
                    result = self.pool.apply(func, args=args, kwds=kwargs)
                    self.result_queue.put((task_id, result, None))
                
                except Exception as e:
                    self.result_queue.put((task_id, None, e))
                
                finally:
                    self.task_queue.task_done()
            
            except queue.Empty:
                continue
    
    def get_result(self, task_id: str, timeout: float = None) -> Any:
        """ç²å–ä»»å‹™çµæœ"""
        while True:
            try:
                result_task_id, result, error = self.result_queue.get(timeout=timeout)
                if result_task_id == task_id:
                    if error:
                        raise error
                    return result
                else:
                    self.result_queue.put((result_task_id, result, error))
            
            except queue.Empty:
                raise TimeoutError(f"Timeout waiting for task {task_id}")
    
    def map_tasks(self, func: Callable, items: List[Any], **kwargs) -> List[Any]:
        """ä¸¦è¡Œè™•ç†å¤šå€‹ä»»å‹™"""
        return self.pool.map(func, items)
    
    def batch_process(self, func: Callable, items: List[Any], batch_size: int = 10, **kwargs) -> List[Any]:
        """æ‰¹é‡è™•ç†ä»»å‹™"""
        results = []
        for i in range(0, len(items), batch_size):
            batch = items[i:i + batch_size]
            batch_results = self.map_tasks(func, batch, **kwargs)
            results.extend(batch_results)
        return results
    
    def starmap_tasks(self, func: Callable, items: List[tuple], **kwargs) -> List[Any]:
        """ä¸¦è¡Œè™•ç†å¤šåƒæ•¸ä»»å‹™"""
        return self.pool.starmap(func, items)

# ä½¿ç”¨ç¤ºä¾‹
def process_item(item: int) -> int:
    """è™•ç†å–®å€‹é …ç›®"""
    time.sleep(0.1)  # æ¨¡æ“¬è™•ç†æ™‚é–“
    return item * item

def process_items(item1: int, item2: int) -> int:
    """è™•ç†å…©å€‹é …ç›®"""
    time.sleep(0.1)  # æ¨¡æ“¬è™•ç†æ™‚é–“
    return item1 + item2

def main():
    # å‰µå»ºé€²ç¨‹ç®¡ç†å™¨
    manager = ProcessManager(num_processes=4)
    
    try:
        # å•Ÿå‹•é€²ç¨‹ç®¡ç†å™¨
        manager.start()
        
        # æäº¤å–®å€‹ä»»å‹™
        print("Submitting single task:")
        manager.submit_task("task1", process_item, 5)
        result = manager.get_result("task1")
        print(f"Result: {result}")
        
        # ä¸¦è¡Œè™•ç†å¤šå€‹ä»»å‹™
        print("\nProcessing multiple tasks:")
        items = list(range(10))
        results = manager.map_tasks(process_item, items)
        print(f"Results: {results}")
        
        # æ‰¹é‡è™•ç†ä»»å‹™
        print("\nBatch processing tasks:")
        items = list(range(20))
        results = manager.batch_process(process_item, items, batch_size=5)
        print(f"Results: {results}")
        
        # è™•ç†å¤šåƒæ•¸ä»»å‹™
        print("\nProcessing multi-parameter tasks:")
        items = [(i, i+1) for i in range(5)]
        results = manager.starmap_tasks(process_items, items)
        print(f"Results: {results}")
    
    finally:
        # åœæ­¢é€²ç¨‹ç®¡ç†å™¨
        manager.stop()

if __name__ == '__main__':
    main()
```

### 2. é€²ç¨‹é€šä¿¡å™¨

```python
import multiprocessing
from multiprocessing import Process, Queue, Pipe, Manager
import time
from typing import List, Dict, Any, Optional
import sys
import os

class ProcessCommunicator:
    def __init__(self):
        """åˆå§‹åŒ–é€²ç¨‹é€šä¿¡å™¨"""
        self.processes: List[Process] = []
        self.queues: Dict[str, Queue] = {}
        self.pipes: Dict[str, tuple] = {}
        self.shared_data = Manager().dict()
        self.is_running = False
    
    def create_queue(self, name: str):
        """å‰µå»ºéšŠåˆ—"""
        self.queues[name] = Queue()
    
    def create_pipe(self, name: str):
        """å‰µå»ºç®¡é“"""
        self.pipes[name] = Pipe()
    
    def send_message(self, queue_name: str, message: Any):
        """ç™¼é€æ¶ˆæ¯"""
        if queue_name in self.queues:
            self.queues[queue_name].put(message)
    
    def receive_message(self, queue_name: str, timeout: float = None) -> Any:
        """æ¥æ”¶æ¶ˆæ¯"""
        if queue_name in self.queues:
            return self.queues[queue_name].get(timeout=timeout)
        raise KeyError(f"Queue {queue_name} not found")
    
    def send_data(self, pipe_name: str, data: Any):
        """é€šéç®¡é“ç™¼é€æ•¸æ“š"""
        if pipe_name in self.pipes:
            self.pipes[pipe_name][0].send(data)
    
    def receive_data(self, pipe_name: str) -> Any:
        """é€šéç®¡é“æ¥æ”¶æ•¸æ“š"""
        if pipe_name in self.pipes:
            return self.pipes[pipe_name][1].recv()
        raise KeyError(f"Pipe {pipe_name} not found")
    
    def set_shared_data(self, key: str, value: Any):
        """è¨­ç½®å…±äº«æ•¸æ“š"""
        self.shared_data[key] = value
    
    def get_shared_data(self, key: str) -> Any:
        """ç²å–å…±äº«æ•¸æ“š"""
        return self.shared_data.get(key)
    
    def start_process(self, target: Callable, args: tuple = (), kwargs: dict = None):
        """å•Ÿå‹•é€²ç¨‹"""
        process = Process(target=target, args=args, kwargs=kwargs or {})
        process.daemon = True
        process.start()
        self.processes.append(process)
    
    def wait_for_all_processes(self):
        """ç­‰å¾…æ‰€æœ‰é€²ç¨‹å®Œæˆ"""
        for process in self.processes:
            process.join()
    
    def close(self):
        """é—œé–‰é€šä¿¡å™¨"""
        for queue in self.queues.values():
            queue.close()
        
        for pipe in self.pipes.values():
            pipe[0].close()
            pipe[1].close()
        
        self.wait_for_all_processes()

# ä½¿ç”¨ç¤ºä¾‹
def producer(comm: ProcessCommunicator):
    """ç”Ÿç”¢è€…é€²ç¨‹"""
    for i in range(5):
        # ç™¼é€æ¶ˆæ¯
        comm.send_message("message_queue", f"Message {i}")
        
        # é€šéç®¡é“ç™¼é€æ•¸æ“š
        comm.send_data("data_pipe", i * i)
        
        # è¨­ç½®å…±äº«æ•¸æ“š
        comm.set_shared_data(f"item_{i}", i)
        
        time.sleep(1)

def consumer(comm: ProcessCommunicator):
    """æ¶ˆè²»è€…é€²ç¨‹"""
    for _ in range(5):
        # æ¥æ”¶æ¶ˆæ¯
        message = comm.receive_message("message_queue")
        print(f"Received message: {message}")
        
        # é€šéç®¡é“æ¥æ”¶æ•¸æ“š
        data = comm.receive_data("data_pipe")
        print(f"Received data: {data}")
        
        # ç²å–å…±äº«æ•¸æ“š
        shared_value = comm.get_shared_data("item_0")
        print(f"Shared data: {shared_value}")
        
        time.sleep(1)

def main():
    # å‰µå»ºé€šä¿¡å™¨
    comm = ProcessCommunicator()
    
    try:
        # å‰µå»ºé€šä¿¡é€šé“
        comm.create_queue("message_queue")
        comm.create_pipe("data_pipe")
        
        # å•Ÿå‹•é€²ç¨‹
        comm.start_process(producer, args=(comm,))
        comm.start_process(consumer, args=(comm,))
        
        # ç­‰å¾…é€²ç¨‹å®Œæˆ
        comm.wait_for_all_processes()
    
    finally:
        # é—œé–‰é€šä¿¡å™¨
        comm.close()

if __name__ == '__main__':
    main()
```

## ç·´ç¿’é¡Œ

1. **é€²ç¨‹ç®¡ç†å™¨**
   é–‹ç™¼ä¸€å€‹é€²ç¨‹ç®¡ç†å™¨ï¼š
   - ç®¡ç†é€²ç¨‹ç”Ÿå‘½é€±æœŸ
   - è™•ç†é€²ç¨‹é€šä¿¡
   - å„ªåŒ–é€²ç¨‹èª¿åº¦
   - æä¾›éŒ¯èª¤è™•ç†

2. **é€²ç¨‹é€šä¿¡å™¨**
   å‰µå»ºä¸€å€‹é€²ç¨‹é€šä¿¡å™¨ï¼š
   - æ”¯æŒå¤šç¨®é€šä¿¡æ–¹å¼
   - è™•ç†é€²ç¨‹åŒæ­¥
   - å„ªåŒ–é€šä¿¡æ•ˆç‡
   - æä¾›èª¿è©¦åŠŸèƒ½

3. **é€²ç¨‹æ¡†æ¶**
   å¯¦ç¾ä¸€å€‹é€²ç¨‹æ¡†æ¶ï¼š
   - æ”¯æŒå¤šç¨®é€²ç¨‹æ¨¡å‹
   - æä¾›é«˜ç´šAPI
   - å„ªåŒ–æ€§èƒ½
   - è™•ç†è¤‡é›œå ´æ™¯

## å°æé†’ ğŸ’¡

1. é€²ç¨‹ç®¡ç†
   - æ§åˆ¶é€²ç¨‹æ•¸é‡
   - è™•ç†é€²ç¨‹é€šä¿¡
   - å„ªåŒ–é€²ç¨‹èª¿åº¦
   - ç›£æ§é€²ç¨‹ç‹€æ…‹

2. é€²ç¨‹é€šä¿¡
   - é¸æ“‡åˆé©æ–¹å¼
   - è™•ç†åŒæ­¥å•é¡Œ
   - å„ªåŒ–é€šä¿¡é–‹éŠ·
   - é¿å…æ­»é–

3. æ€§èƒ½å„ªåŒ–
   - æ¸›å°‘é€²ç¨‹é–‹éŠ·
   - å„ªåŒ–è³‡æºä½¿ç”¨
   - å¹³è¡¡è² è¼‰
   - æé«˜ååé‡

4. èª¿è©¦æŠ€å·§
   - ä½¿ç”¨èª¿è©¦å·¥å…·
   - åˆ†æé€²ç¨‹å•é¡Œ
   - å„ªåŒ–é€šä¿¡é‚è¼¯
   - ç›£æ§ç³»çµ±è³‡æº

[ä¸Šä¸€ç« ï¼šä¸¦ç™¼ç·¨ç¨‹é€²éš](083_ä¸¦ç™¼ç·¨ç¨‹é€²éš.md) | [ä¸‹ä¸€ç« ï¼šé€²ç¨‹ç·¨ç¨‹é€²éš](085_é€²ç¨‹ç·¨ç¨‹é€²éš.md) 