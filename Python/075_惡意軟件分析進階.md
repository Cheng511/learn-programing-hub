[ä¸Šä¸€ç« ï¼šæƒ¡æ„è»Ÿä»¶åˆ†æåŸºç¤](074_æƒ¡æ„è»Ÿä»¶åˆ†æåŸºç¤.md) | [ä¸‹ä¸€ç« ï¼šé€†å‘å·¥ç¨‹åŸºç¤](076_é€†å‘å·¥ç¨‹åŸºç¤.md)

# Python æƒ¡æ„è»Ÿä»¶åˆ†æé€²éš ğŸ”

## å‹•æ…‹åˆ†æ

### 1. è¡Œç‚ºåˆ†æå™¨

```python
import psutil
import os
import time
from typing import Dict, List, Optional
import threading
import logging
from datetime import datetime

class BehaviorAnalyzer:
    def __init__(self, process_name: str):
        """åˆå§‹åŒ–è¡Œç‚ºåˆ†æå™¨"""
        self.process_name = process_name
        self.process = None
        self.running = False
        self.behaviors: List[Dict] = []
        self.lock = threading.Lock()
        
        # é…ç½®æ—¥èªŒ
        logging.basicConfig(
            filename=f'behavior_{datetime.now().strftime("%Y%m%d_%H%M%S")}.log',
            level=logging.INFO,
            format='%(asctime)s - %(levelname)s - %(message)s'
        )
    
    def start_monitoring(self):
        """é–‹å§‹ç›£æ§"""
        self.running = True
        
        try:
            # æŸ¥æ‰¾ç›®æ¨™é€²ç¨‹
            for proc in psutil.process_iter(['pid', 'name', 'cmdline']):
                if self.process_name.lower() in proc.info['name'].lower():
                    self.process = proc
                    break
            
            if not self.process:
                raise ValueError(f"Process {self.process_name} not found")
            
            # å‰µå»ºç›£æ§ç·šç¨‹
            threads = [
                threading.Thread(target=self.monitor_file_operations),
                threading.Thread(target=self.monitor_network_connections),
                threading.Thread(target=self.monitor_registry_operations),
                threading.Thread(target=self.monitor_process_operations)
            ]
            
            # å•Ÿå‹•æ‰€æœ‰ç·šç¨‹
            for thread in threads:
                thread.start()
            
            # ç­‰å¾…æ‰€æœ‰ç·šç¨‹å®Œæˆ
            for thread in threads:
                thread.join()
        
        except Exception as e:
            logging.error(f"Error in monitoring: {e}")
        finally:
            self.running = False
    
    def monitor_file_operations(self):
        """ç›£æ§æ–‡ä»¶æ“ä½œ"""
        while self.running:
            try:
                # ç²å–é€²ç¨‹æ‰“é–‹çš„æ–‡ä»¶
                files = self.process.open_files()
                
                for file in files:
                    with self.lock:
                        self.behaviors.append({
                            'type': 'file_operation',
                            'timestamp': datetime.now().isoformat(),
                            'path': file.path,
                            'mode': file.mode
                        })
                        logging.info(f"File operation: {file.path} ({file.mode})")
                
                time.sleep(1)
            
            except Exception as e:
                logging.error(f"Error monitoring file operations: {e}")
                time.sleep(1)
    
    def monitor_network_connections(self):
        """ç›£æ§ç¶²çµ¡é€£æ¥"""
        while self.running:
            try:
                # ç²å–é€²ç¨‹çš„ç¶²çµ¡é€£æ¥
                connections = self.process.connections()
                
                for conn in connections:
                    with self.lock:
                        self.behaviors.append({
                            'type': 'network_connection',
                            'timestamp': datetime.now().isoformat(),
                            'local_addr': conn.laddr,
                            'remote_addr': conn.raddr,
                            'status': conn.status
                        })
                        logging.info(
                            f"Network connection: {conn.laddr} -> {conn.raddr} ({conn.status})"
                        )
                
                time.sleep(1)
            
            except Exception as e:
                logging.error(f"Error monitoring network connections: {e}")
                time.sleep(1)
    
    def monitor_registry_operations(self):
        """ç›£æ§è¨»å†Šè¡¨æ“ä½œ"""
        while self.running:
            try:
                # ç²å–é€²ç¨‹çš„è¨»å†Šè¡¨æ“ä½œ
                # æ³¨æ„ï¼šé€™éœ€è¦ç®¡ç†å“¡æ¬Šé™
                import win32api
                import win32security
                
                # ç²å–é€²ç¨‹çš„è¨ªå•ä»¤ç‰Œ
                token = win32security.OpenProcessToken(
                    self.process.pid,
                    win32security.TOKEN_QUERY
                )
                
                # ç²å–é€²ç¨‹çš„æ¬Šé™
                privileges = win32security.GetTokenInformation(
                    token,
                    win32security.TokenPrivileges
                )
                
                with self.lock:
                    self.behaviors.append({
                        'type': 'registry_operation',
                        'timestamp': datetime.now().isoformat(),
                        'privileges': privileges
                    })
                    logging.info(f"Registry privileges: {privileges}")
                
                time.sleep(1)
            
            except Exception as e:
                logging.error(f"Error monitoring registry operations: {e}")
                time.sleep(1)
    
    def monitor_process_operations(self):
        """ç›£æ§é€²ç¨‹æ“ä½œ"""
        while self.running:
            try:
                # ç²å–é€²ç¨‹çš„å­é€²ç¨‹
                children = self.process.children()
                
                for child in children:
                    with self.lock:
                        self.behaviors.append({
                            'type': 'process_operation',
                            'timestamp': datetime.now().isoformat(),
                            'child_pid': child.pid,
                            'child_name': child.name(),
                            'cmdline': child.cmdline()
                        })
                        logging.info(
                            f"Child process: {child.pid} ({child.name()})"
                        )
                
                time.sleep(1)
            
            except Exception as e:
                logging.error(f"Error monitoring process operations: {e}")
                time.sleep(1)
    
    def stop_monitoring(self):
        """åœæ­¢ç›£æ§"""
        self.running = False
    
    def get_behaviors(self) -> List[Dict]:
        """ç²å–è¡Œç‚ºè¨˜éŒ„"""
        return self.behaviors

# ä½¿ç”¨ç¤ºä¾‹
def main():
    # å‰µå»ºåˆ†æå™¨
    analyzer = BehaviorAnalyzer("test.exe")
    
    print("Starting behavior analysis...")
    print("Press Ctrl+C to stop")
    
    try:
        # é–‹å§‹ç›£æ§
        analyzer.start_monitoring()
    except KeyboardInterrupt:
        print("\nStopping analysis...")
        analyzer.stop_monitoring()
        
        # è¼¸å‡ºçµæœ
        behaviors = analyzer.get_behaviors()
        print(f"\nFound {len(behaviors)} behaviors:")
        
        for behavior in behaviors:
            print(f"\nType: {behavior['type']}")
            print(f"Time: {behavior['timestamp']}")
            for key, value in behavior.items():
                if key not in ['type', 'timestamp']:
                    print(f"{key}: {value}")

if __name__ == '__main__':
    main()
```

### 2. å…§å­˜åˆ†æå™¨

```python
import psutil
import os
import time
from typing import Dict, List, Optional
import threading
import logging
from datetime import datetime
import struct

class MemoryAnalyzer:
    def __init__(self, process_name: str):
        """åˆå§‹åŒ–å…§å­˜åˆ†æå™¨"""
        self.process_name = process_name
        self.process = None
        self.running = False
        self.memory_dumps: List[Dict] = []
        self.lock = threading.Lock()
        
        # é…ç½®æ—¥èªŒ
        logging.basicConfig(
            filename=f'memory_{datetime.now().strftime("%Y%m%d_%H%M%S")}.log',
            level=logging.INFO,
            format='%(asctime)s - %(levelname)s - %(message)s'
        )
    
    def start_analysis(self):
        """é–‹å§‹åˆ†æ"""
        self.running = True
        
        try:
            # æŸ¥æ‰¾ç›®æ¨™é€²ç¨‹
            for proc in psutil.process_iter(['pid', 'name', 'cmdline']):
                if self.process_name.lower() in proc.info['name'].lower():
                    self.process = proc
                    break
            
            if not self.process:
                raise ValueError(f"Process {self.process_name} not found")
            
            # å‰µå»ºåˆ†æç·šç¨‹
            threads = [
                threading.Thread(target=self.analyze_memory_regions),
                threading.Thread(target=self.analyze_heap),
                threading.Thread(target=self.analyze_stack),
                threading.Thread(target=self.analyze_strings)
            ]
            
            # å•Ÿå‹•æ‰€æœ‰ç·šç¨‹
            for thread in threads:
                thread.start()
            
            # ç­‰å¾…æ‰€æœ‰ç·šç¨‹å®Œæˆ
            for thread in threads:
                thread.join()
        
        except Exception as e:
            logging.error(f"Error in analysis: {e}")
        finally:
            self.running = False
    
    def analyze_memory_regions(self):
        """åˆ†æå…§å­˜å€åŸŸ"""
        while self.running:
            try:
                # ç²å–é€²ç¨‹çš„å…§å­˜æ˜ å°„
                memory_maps = self.process.memory_maps()
                
                for mmap in memory_maps:
                    with self.lock:
                        self.memory_dumps.append({
                            'type': 'memory_region',
                            'timestamp': datetime.now().isoformat(),
                            'path': mmap.path,
                            'addr': mmap.addr,
                            'size': mmap.size,
                            'perms': mmap.perms,
                            'rss': mmap.rss
                        })
                        logging.info(
                            f"Memory region: {mmap.path} ({mmap.addr})"
                        )
                
                time.sleep(1)
            
            except Exception as e:
                logging.error(f"Error analyzing memory regions: {e}")
                time.sleep(1)
    
    def analyze_heap(self):
        """åˆ†æå †å…§å­˜"""
        while self.running:
            try:
                # ç²å–é€²ç¨‹çš„å †ä¿¡æ¯
                # æ³¨æ„ï¼šé€™éœ€è¦ç®¡ç†å“¡æ¬Šé™
                import win32api
                import win32process
                
                # ç²å–é€²ç¨‹çš„å †å¥æŸ„
                heap_handle = win32process.GetProcessHeap(self.process.pid)
                
                # ç²å–å †ä¿¡æ¯
                heap_info = win32process.Heap32List(heap_handle)
                
                with self.lock:
                    self.memory_dumps.append({
                        'type': 'heap',
                        'timestamp': datetime.now().isoformat(),
                        'heap_info': heap_info
                    })
                    logging.info(f"Heap info: {heap_info}")
                
                time.sleep(1)
            
            except Exception as e:
                logging.error(f"Error analyzing heap: {e}")
                time.sleep(1)
    
    def analyze_stack(self):
        """åˆ†ææ£§å…§å­˜"""
        while self.running:
            try:
                # ç²å–é€²ç¨‹çš„ç·šç¨‹ä¿¡æ¯
                threads = self.process.threads()
                
                for thread in threads:
                    # ç²å–ç·šç¨‹çš„æ£§ä¿¡æ¯
                    stack_info = {
                        'thread_id': thread.id,
                        'user_time': thread.user_time,
                        'system_time': thread.system_time,
                        'stack_size': thread.stack_size
                    }
                    
                    with self.lock:
                        self.memory_dumps.append({
                            'type': 'stack',
                            'timestamp': datetime.now().isoformat(),
                            'thread_id': thread.id,
                            'stack_info': stack_info
                        })
                        logging.info(f"Stack info for thread {thread.id}")
                
                time.sleep(1)
            
            except Exception as e:
                logging.error(f"Error analyzing stack: {e}")
                time.sleep(1)
    
    def analyze_strings(self):
        """åˆ†æå…§å­˜ä¸­çš„å­—ç¬¦ä¸²"""
        while self.running:
            try:
                # ç²å–é€²ç¨‹çš„å…§å­˜ä¿¡æ¯
                memory_info = self.process.memory_info()
                
                # è®€å–é€²ç¨‹å…§å­˜
                with open(f"\\\\.\\PHYSICALDRIVE0", "rb") as f:
                    f.seek(memory_info.rss)
                    memory_data = f.read(memory_info.rss)
                
                # æå–å­—ç¬¦ä¸²
                strings = []
                current_string = ""
                
                for byte in memory_data:
                    if 32 <= byte <= 126:  # å¯æ‰“å°å­—ç¬¦
                        current_string += chr(byte)
                    elif current_string:
                        if len(current_string) >= 4:  # æœ€å°é•·åº¦
                            strings.append(current_string)
                        current_string = ""
                
                with self.lock:
                    self.memory_dumps.append({
                        'type': 'strings',
                        'timestamp': datetime.now().isoformat(),
                        'strings': strings
                    })
                    logging.info(f"Found {len(strings)} strings")
                
                time.sleep(1)
            
            except Exception as e:
                logging.error(f"Error analyzing strings: {e}")
                time.sleep(1)
    
    def stop_analysis(self):
        """åœæ­¢åˆ†æ"""
        self.running = False
    
    def get_memory_dumps(self) -> List[Dict]:
        """ç²å–å…§å­˜è½‰å„²"""
        return self.memory_dumps

# ä½¿ç”¨ç¤ºä¾‹
def main():
    # å‰µå»ºåˆ†æå™¨
    analyzer = MemoryAnalyzer("test.exe")
    
    print("Starting memory analysis...")
    print("Press Ctrl+C to stop")
    
    try:
        # é–‹å§‹åˆ†æ
        analyzer.start_analysis()
    except KeyboardInterrupt:
        print("\nStopping analysis...")
        analyzer.stop_analysis()
        
        # è¼¸å‡ºçµæœ
        dumps = analyzer.get_memory_dumps()
        print(f"\nFound {len(dumps)} memory dumps:")
        
        for dump in dumps:
            print(f"\nType: {dump['type']}")
            print(f"Time: {dump['timestamp']}")
            for key, value in dump.items():
                if key not in ['type', 'timestamp']:
                    print(f"{key}: {value}")

if __name__ == '__main__':
    main()
```

## ç·´ç¿’é¡Œ

1. **è¡Œç‚ºåˆ†æå·¥å…·**
   é–‹ç™¼ä¸€å€‹è¡Œç‚ºåˆ†æå·¥å…·ï¼š
   - ç›£æ§æ–‡ä»¶æ“ä½œ
   - è¿½è¹¤ç¶²çµ¡é€£æ¥
   - åˆ†æé€²ç¨‹è¡Œç‚º
   - ç”Ÿæˆè¡Œç‚ºå ±å‘Š

2. **å…§å­˜åˆ†æå·¥å…·**
   å‰µå»ºä¸€å€‹å…§å­˜åˆ†æå·¥å…·ï¼š
   - åˆ†æå…§å­˜å€åŸŸ
   - æå–å…§å­˜æ•¸æ“š
   - è­˜åˆ¥æƒ¡æ„ä»£ç¢¼
   - ç”Ÿæˆåˆ†æå ±å‘Š

3. **æƒ¡æ„è»Ÿä»¶åˆ†ææ¡†æ¶**
   å¯¦ç¾ä¸€å€‹æƒ¡æ„è»Ÿä»¶åˆ†ææ¡†æ¶ï¼š
   - æ”¯æŒå‹•æ…‹åˆ†æ
   - æä¾›åˆ†æAPI
   - ç”Ÿæˆåˆ†æå ±å‘Š
   - ç®¡ç†åˆ†æçµæœ

## å°æé†’ ğŸ’¡

1. å®‰å…¨è€ƒæ…®
   - ä½¿ç”¨éš”é›¢ç’°å¢ƒ
   - ä¿è­·åˆ†ææ•¸æ“š
   - é¿å…åŸ·è¡Œæƒ¡æ„ä»£ç¢¼
   - å®šæœŸæ›´æ–°å·¥å…·

2. æ€§èƒ½å„ªåŒ–
   - å„ªåŒ–å…§å­˜ä½¿ç”¨
   - ä½¿ç”¨ç·©å­˜æ©Ÿåˆ¶
   - æ§åˆ¶CPUä½¿ç”¨
   - ä¸¦è¡Œè™•ç†

3. å¯é æ€§
   - è™•ç†é€²ç¨‹éŒ¯èª¤
   - é©—è­‰å…§å­˜è¨ªå•
   - è¨˜éŒ„åˆ†ææ—¥èªŒ
   - å‚™ä»½é‡è¦æ•¸æ“š

4. èª¿è©¦æŠ€å·§
   - ä½¿ç”¨èª¿è©¦å·¥å…·
   - åˆ†æéŒ¯èª¤ä¿¡æ¯
   - æ¨¡æ“¬é‹è¡Œç’°å¢ƒ
   - å£“åŠ›æ¸¬è©¦

[ä¸Šä¸€ç« ï¼šæƒ¡æ„è»Ÿä»¶åˆ†æåŸºç¤](074_æƒ¡æ„è»Ÿä»¶åˆ†æåŸºç¤.md) | [ä¸‹ä¸€ç« ï¼šé€†å‘å·¥ç¨‹åŸºç¤](076_é€†å‘å·¥ç¨‹åŸºç¤.md) 