[ä¸Šä¸€ç« ï¼šå¾®æœå‹™æ¶æ§‹è¨­è¨ˆ](126_å¾®æœå‹™æ¶æ§‹è¨­è¨ˆ.md) | [ä¸‹ä¸€ç« ï¼šäº‹ä»¶é©…å‹•æ¶æ§‹](128_äº‹ä»¶é©…å‹•æ¶æ§‹.md)

# Python æœå‹™ç¶²æ ¼æ‡‰ç”¨ ğŸŒ

## 1. æœå‹™ç¶²æ ¼åŸºç¤æ¶æ§‹

### 1.1 Sidecarä»£ç†

```python
from typing import Dict, List, Optional
import aiohttp
import asyncio
from dataclasses import dataclass
import yaml
import logging

@dataclass
class ProxyConfig:
    """ä»£ç†é…ç½®"""
    service_name: str
    listen_port: int
    target_host: str
    target_port: int
    circuit_breaker: bool = True
    retry_count: int = 3
    timeout: float = 5.0

class SidecarProxy:
    def __init__(self, config: ProxyConfig):
        self.config = config
        self.session = aiohttp.ClientSession()
        self.metrics = ProxyMetrics(config.service_name)
        self.circuit_breaker = CircuitBreaker()
        self.logger = logging.getLogger(f"sidecar.{config.service_name}")
    
    async def handle_request(self, request: Dict) -> Dict:
        """è™•ç†è«‹æ±‚"""
        target_url = f"http://{self.config.target_host}:{self.config.target_port}"
        
        for attempt in range(self.config.retry_count):
            try:
                if self.config.circuit_breaker and not self.circuit_breaker.allow_request():
                    raise Exception("Circuit breaker is open")
                
                async with self.session.request(
                    method=request['method'],
                    url=f"{target_url}{request['path']}",
                    headers=request['headers'],
                    json=request.get('body'),
                    timeout=self.config.timeout
                ) as response:
                    self.metrics.record_request(response.status)
                    return {
                        'status': response.status,
                        'headers': dict(response.headers),
                        'body': await response.json()
                    }
            except Exception as e:
                self.logger.error(f"Request failed: {str(e)}")
                self.circuit_breaker.record_failure()
                if attempt == self.config.retry_count - 1:
                    raise
                await asyncio.sleep(1 * (attempt + 1))
```

### 1.2 æœå‹™ç¶²æ ¼æ§åˆ¶å¹³é¢

```python
class ControlPlane:
    def __init__(self):
        self.services: Dict[str, List[ProxyConfig]] = {}
        self.config_version = 0
        self.watchers: List[asyncio.Queue] = []
    
    def register_service(self, config: ProxyConfig):
        """è¨»å†Šæœå‹™"""
        if config.service_name not in self.services:
            self.services[config.service_name] = []
        self.services[config.service_name].append(config)
        self.config_version += 1
        self._notify_watchers()
    
    def get_service_config(self, service_name: str) -> List[ProxyConfig]:
        """ç²å–æœå‹™é…ç½®"""
        return self.services.get(service_name, [])
    
    async def watch_config_changes(self) -> asyncio.Queue:
        """ç›£è½é…ç½®è®Šæ›´"""
        queue = asyncio.Queue()
        self.watchers.append(queue)
        return queue
    
    def _notify_watchers(self):
        """é€šçŸ¥é…ç½®è®Šæ›´"""
        for queue in self.watchers:
            queue.put_nowait({
                'version': self.config_version,
                'services': self.services
            })
```

## 2. æµé‡ç®¡ç†

### 2.1 è² è¼‰å‡è¡¡

```python
from abc import ABC, abstractmethod
import random

class LoadBalancer(ABC):
    @abstractmethod
    def select_target(self, targets: List[str]) -> str:
        """é¸æ“‡ç›®æ¨™æœå‹™å¯¦ä¾‹"""
        pass

class RoundRobinBalancer(LoadBalancer):
    def __init__(self):
        self.current = 0
    
    def select_target(self, targets: List[str]) -> str:
        if not targets:
            raise ValueError("No targets available")
        
        selected = targets[self.current]
        self.current = (self.current + 1) % len(targets)
        return selected

class WeightedRandomBalancer(LoadBalancer):
    def __init__(self, weights: Dict[str, float]):
        self.weights = weights
    
    def select_target(self, targets: List[str]) -> str:
        available_targets = [t for t in targets if t in self.weights]
        if not available_targets:
            raise ValueError("No targets available")
        
        total_weight = sum(self.weights[t] for t in available_targets)
        r = random.uniform(0, total_weight)
        
        cumulative_weight = 0
        for target in available_targets:
            cumulative_weight += self.weights[target]
            if r <= cumulative_weight:
                return target
```

### 2.2 æµé‡è·¯ç”±

```python
from dataclasses import dataclass
from typing import List, Dict, Optional
import re

@dataclass
class RouteRule:
    """è·¯ç”±è¦å‰‡"""
    path_pattern: str
    service: str
    weight: float = 1.0
    headers: Dict[str, str] = None

class TrafficRouter:
    def __init__(self):
        self.rules: List[RouteRule] = []
    
    def add_rule(self, rule: RouteRule):
        """æ·»åŠ è·¯ç”±è¦å‰‡"""
        self.rules.append(rule)
    
    def find_route(self, path: str,
                   headers: Dict[str, str]) -> Optional[str]:
        """æŸ¥æ‰¾åŒ¹é…çš„è·¯ç”±"""
        matching_rules = []
        
        for rule in self.rules:
            if re.match(rule.path_pattern, path):
                # æª¢æŸ¥è«‹æ±‚é ­åŒ¹é…
                if rule.headers:
                    headers_match = all(
                        headers.get(k) == v
                        for k, v in rule.headers.items()
                    )
                    if not headers_match:
                        continue
                matching_rules.append(rule)
        
        if not matching_rules:
            return None
        
        # æ ¹æ“šæ¬Šé‡é¸æ“‡è·¯ç”±
        total_weight = sum(r.weight for r in matching_rules)
        r = random.uniform(0, total_weight)
        
        cumulative_weight = 0
        for rule in matching_rules:
            cumulative_weight += rule.weight
            if r <= cumulative_weight:
                return rule.service
```

## 3. å¯è§€æ¸¬æ€§

### 3.1 æŒ‡æ¨™æ”¶é›†

```python
from prometheus_client import Counter, Histogram, Gauge
import time

class ProxyMetrics:
    def __init__(self, service_name: str):
        # è«‹æ±‚è¨ˆæ•¸å™¨
        self.request_counter = Counter(
            'proxy_requests_total',
            'Total proxy requests',
            ['service', 'status']
        )
        
        # å»¶é²ç›´æ–¹åœ–
        self.latency_histogram = Histogram(
            'proxy_request_duration_seconds',
            'Request duration in seconds',
            ['service']
        )
        
        # ä¸¦ç™¼è«‹æ±‚é‡
        self.concurrent_requests = Gauge(
            'proxy_concurrent_requests',
            'Number of concurrent requests',
            ['service']
        )
        
        self.service_name = service_name
    
    def record_request(self, status: int):
        """è¨˜éŒ„è«‹æ±‚"""
        self.request_counter.labels(
            service=self.service_name,
            status=status
        ).inc()
    
    @contextmanager
    def measure_latency(self):
        """æ¸¬é‡è«‹æ±‚å»¶é²"""
        start_time = time.time()
        self.concurrent_requests.labels(self.service_name).inc()
        try:
            yield
        finally:
            duration = time.time() - start_time
            self.latency_histogram.labels(self.service_name).observe(duration)
            self.concurrent_requests.labels(self.service_name).dec()
```

### 3.2 åˆ†å¸ƒå¼è¿½è¸ª

```python
from opentelemetry import trace
from opentelemetry.trace import SpanKind
from opentelemetry.trace.status import Status, StatusCode

class TracingMiddleware:
    def __init__(self, service_name: str):
        self.tracer = trace.get_tracer(service_name)
    
    async def trace_request(self, request: Dict) -> Dict:
        """è¿½è¸ªè«‹æ±‚"""
        with self.tracer.start_as_current_span(
            name=f"{request['method']} {request['path']}",
            kind=SpanKind.CLIENT
        ) as span:
            # è¨­ç½®spanå±¬æ€§
            span.set_attribute("http.method", request['method'])
            span.set_attribute("http.url", request['path'])
            
            try:
                response = await self._make_request(request)
                span.set_attribute("http.status_code", response['status'])
                span.set_status(Status(StatusCode.OK))
                return response
            except Exception as e:
                span.set_status(Status(StatusCode.ERROR, str(e)))
                span.record_exception(e)
                raise
```

## ç·´ç¿’é¡Œ ğŸƒ

1. å¯¦ç¾ä¸€å€‹å®Œæ•´çš„Sidecarä»£ç†ã€‚
2. é–‹ç™¼ä¸€å€‹æœå‹™ç¶²æ ¼æ§åˆ¶å¹³é¢ã€‚
3. è¨­è¨ˆä¸€å€‹é«˜ç´šæµé‡è·¯ç”±ç³»çµ±ã€‚
4. å¯¦ç¾åˆ†å¸ƒå¼è¿½è¸ªé›†æˆã€‚
5. å‰µå»ºä¸€å€‹æœå‹™ç¶²æ ¼ç›£æ§å„€è¡¨æ¿ã€‚

## å°çµ ğŸ“

- å­¸ç¿’äº†æœå‹™ç¶²æ ¼çš„åŸºæœ¬æ¶æ§‹
- æŒæ¡äº†Sidecarä»£ç†çš„å¯¦ç¾
- ç†è§£äº†æµé‡ç®¡ç†æ©Ÿåˆ¶
- å­¸æœƒäº†å¯è§€æ¸¬æ€§é›†æˆ
- äº†è§£äº†æœå‹™ç¶²æ ¼é‹ç¶­æ–¹æ³•

## å»¶ä¼¸é–±è®€ ğŸ“š

1. Service Mesh Architecture
2. Istio in Action
3. Envoy Proxy Documentation
4. Distributed Tracing Systems
5. Cloud Native Observability

[ä¸Šä¸€ç« ï¼šå¾®æœå‹™æ¶æ§‹è¨­è¨ˆ](126_å¾®æœå‹™æ¶æ§‹è¨­è¨ˆ.md) | [ä¸‹ä¸€ç« ï¼šäº‹ä»¶é©…å‹•æ¶æ§‹](128_äº‹ä»¶é©…å‹•æ¶æ§‹.md) 