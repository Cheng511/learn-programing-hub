[ä¸Šä¸€ç« ï¼šæ€§èƒ½å„ªåŒ–å¯¦è¸](145_æ€§èƒ½å„ªåŒ–å¯¦è¸.md) | [ä¸‹ä¸€ç« ï¼šå®¹å™¨åŒ–éƒ¨ç½²](147_å®¹å™¨åŒ–éƒ¨ç½².md)

# Python ç³»çµ±å®‰å…¨åŠ å›º ğŸ”’

## 1. èº«ä»½èªè­‰

### 1.1 èªè­‰ç³»çµ±

```python
from typing import Dict, List, Optional
import hashlib
import secrets
import time
import jwt
from datetime import datetime, timedelta

class PasswordHasher:
    """å¯†ç¢¼å“ˆå¸Œå™¨"""
    def __init__(self,
                 salt_length: int = 16,
                 iterations: int = 100000):
        self.salt_length = salt_length
        self.iterations = iterations
    
    def hash_password(self,
                     password: str) -> Dict[str, str]:
        """å“ˆå¸Œå¯†ç¢¼"""
        salt = secrets.token_hex(self.salt_length)
        hash_value = hashlib.pbkdf2_hmac(
            'sha256',
            password.encode(),
            salt.encode(),
            self.iterations
        ).hex()
        
        return {
            'hash': hash_value,
            'salt': salt,
            'iterations': self.iterations
        }
    
    def verify_password(self,
                       password: str,
                       hash_dict: Dict[str, str]) -> bool:
        """é©—è­‰å¯†ç¢¼"""
        hash_value = hashlib.pbkdf2_hmac(
            'sha256',
            password.encode(),
            hash_dict['salt'].encode(),
            int(hash_dict['iterations'])
        ).hex()
        
        return secrets.compare_digest(
            hash_value,
            hash_dict['hash']
        )

class TokenManager:
    """ä»¤ç‰Œç®¡ç†å™¨"""
    def __init__(self,
                 secret_key: str,
                 token_expiry: timedelta = timedelta(hours=1)):
        self.secret_key = secret_key
        self.token_expiry = token_expiry
        self.blacklist: List[str] = []
    
    def generate_token(self,
                      user_id: str,
                      claims: Dict = None) -> str:
        """ç”Ÿæˆä»¤ç‰Œ"""
        now = datetime.utcnow()
        payload = {
            'user_id': user_id,
            'iat': now,
            'exp': now + self.token_expiry
        }
        
        if claims:
            payload.update(claims)
        
        return jwt.encode(
            payload,
            self.secret_key,
            algorithm='HS256'
        )
    
    def verify_token(self,
                    token: str) -> Optional[Dict]:
        """é©—è­‰ä»¤ç‰Œ"""
        if token in self.blacklist:
            return None
        
        try:
            payload = jwt.decode(
                token,
                self.secret_key,
                algorithms=['HS256']
            )
            return payload
        except jwt.ExpiredSignatureError:
            return None
        except jwt.InvalidTokenError:
            return None
    
    def revoke_token(self,
                    token: str):
        """æ’¤éŠ·ä»¤ç‰Œ"""
        self.blacklist.append(token)

class TwoFactorAuth:
    """é›™å› ç´ èªè­‰"""
    def __init__(self,
                 code_length: int = 6,
                 code_expiry: int = 300):
        self.code_length = code_length
        self.code_expiry = code_expiry
        self.codes: Dict[str, Dict] = {}
    
    def generate_code(self,
                     user_id: str) -> str:
        """ç”Ÿæˆé©—è­‰ç¢¼"""
        code = ''.join(
            str(secrets.randbelow(10))
            for _ in range(self.code_length)
        )
        
        self.codes[user_id] = {
            'code': code,
            'expires': time.time() + self.code_expiry
        }
        
        return code
    
    def verify_code(self,
                   user_id: str,
                   code: str) -> bool:
        """é©—è­‰ç¢¼é©—è­‰"""
        if user_id not in self.codes:
            return False
        
        stored = self.codes[user_id]
        if time.time() > stored['expires']:
            del self.codes[user_id]
            return False
        
        if not secrets.compare_digest(
            stored['code'],
            code
        ):
            return False
        
        del self.codes[user_id]
        return True
```

### 1.2 è¨ªå•æ§åˆ¶

```python
from typing import Dict, List, Optional, Set
from enum import Enum
from dataclasses import dataclass

class Permission(Enum):
    """æ¬Šé™æšèˆ‰"""
    READ = 'read'
    WRITE = 'write'
    DELETE = 'delete'
    ADMIN = 'admin'

@dataclass
class Role:
    """è§’è‰²å®šç¾©"""
    name: str
    permissions: Set[Permission]

class RBAC:
    """åŸºæ–¼è§’è‰²çš„è¨ªå•æ§åˆ¶"""
    def __init__(self):
        self.roles: Dict[str, Role] = {}
        self.user_roles: Dict[str, Set[str]] = {}
    
    def add_role(self,
                role: Role):
        """æ·»åŠ è§’è‰²"""
        self.roles[role.name] = role
    
    def assign_role(self,
                   user_id: str,
                   role_name: str):
        """åˆ†é…è§’è‰²"""
        if role_name not in self.roles:
            raise ValueError(f"Role {role_name} does not exist")
        
        if user_id not in self.user_roles:
            self.user_roles[user_id] = set()
        
        self.user_roles[user_id].add(role_name)
    
    def has_permission(self,
                      user_id: str,
                      permission: Permission) -> bool:
        """æª¢æŸ¥æ¬Šé™"""
        if user_id not in self.user_roles:
            return False
        
        user_permissions = set()
        for role_name in self.user_roles[user_id]:
            role = self.roles[role_name]
            user_permissions.update(role.permissions)
        
        return permission in user_permissions

class ACL:
    """è¨ªå•æ§åˆ¶åˆ—è¡¨"""
    def __init__(self):
        self.acl: Dict[str, Dict[str, Set[Permission]]] = {}
    
    def grant_permission(self,
                       resource_id: str,
                       user_id: str,
                       permission: Permission):
        """æˆäºˆæ¬Šé™"""
        if resource_id not in self.acl:
            self.acl[resource_id] = {}
        
        if user_id not in self.acl[resource_id]:
            self.acl[resource_id][user_id] = set()
        
        self.acl[resource_id][user_id].add(permission)
    
    def revoke_permission(self,
                        resource_id: str,
                        user_id: str,
                        permission: Permission):
        """æ’¤éŠ·æ¬Šé™"""
        if (resource_id in self.acl and
            user_id in self.acl[resource_id]):
            self.acl[resource_id][user_id].discard(permission)
    
    def check_permission(self,
                       resource_id: str,
                       user_id: str,
                       permission: Permission) -> bool:
        """æª¢æŸ¥æ¬Šé™"""
        return (
            resource_id in self.acl and
            user_id in self.acl[resource_id] and
            permission in self.acl[resource_id][user_id]
        )
```

## 2. æ•¸æ“šåŠ å¯†

### 2.1 åŠ å¯†ç³»çµ±

```python
from typing import Dict, Optional, Tuple
from cryptography.fernet import Fernet
from cryptography.hazmat.primitives import hashes
from cryptography.hazmat.primitives.kdf.pbkdf2 import PBKDF2HMAC
from cryptography.hazmat.primitives.asymmetric import rsa, padding
import base64

class SymmetricEncryption:
    """å°ç¨±åŠ å¯†"""
    def __init__(self,
                 key: Optional[bytes] = None):
        self.key = key or Fernet.generate_key()
        self.cipher = Fernet(self.key)
    
    def encrypt(self,
               data: str) -> str:
        """åŠ å¯†æ•¸æ“š"""
        return self.cipher.encrypt(
            data.encode()
        ).decode()
    
    def decrypt(self,
               encrypted_data: str) -> str:
        """è§£å¯†æ•¸æ“š"""
        return self.cipher.decrypt(
            encrypted_data.encode()
        ).decode()
    
    @staticmethod
    def generate_key_from_password(
        password: str,
        salt: bytes = None
    ) -> Tuple[bytes, bytes]:
        """å¾å¯†ç¢¼ç”Ÿæˆå¯†é‘°"""
        if salt is None:
            salt = secrets.token_bytes(16)
        
        kdf = PBKDF2HMAC(
            algorithm=hashes.SHA256(),
            length=32,
            salt=salt,
            iterations=100000
        )
        
        key = base64.urlsafe_b64encode(
            kdf.derive(password.encode())
        )
        return key, salt

class AsymmetricEncryption:
    """éå°ç¨±åŠ å¯†"""
    def __init__(self,
                 key_size: int = 2048):
        self.private_key = rsa.generate_private_key(
            public_exponent=65537,
            key_size=key_size
        )
        self.public_key = self.private_key.public_key()
    
    def encrypt(self,
               data: str) -> bytes:
        """åŠ å¯†æ•¸æ“š"""
        return self.public_key.encrypt(
            data.encode(),
            padding.OAEP(
                mgf=padding.MGF1(algorithm=hashes.SHA256()),
                algorithm=hashes.SHA256(),
                label=None
            )
        )
    
    def decrypt(self,
               encrypted_data: bytes) -> str:
        """è§£å¯†æ•¸æ“š"""
        return self.private_key.decrypt(
            encrypted_data,
            padding.OAEP(
                mgf=padding.MGF1(algorithm=hashes.SHA256()),
                algorithm=hashes.SHA256(),
                label=None
            )
        ).decode()
    
    def sign(self,
            data: str) -> bytes:
        """ç°½åæ•¸æ“š"""
        return self.private_key.sign(
            data.encode(),
            padding.PSS(
                mgf=padding.MGF1(hashes.SHA256()),
                salt_length=padding.PSS.MAX_LENGTH
            ),
            hashes.SHA256()
        )
    
    def verify(self,
              data: str,
              signature: bytes) -> bool:
        """é©—è­‰ç°½å"""
        try:
            self.public_key.verify(
                signature,
                data.encode(),
                padding.PSS(
                    mgf=padding.MGF1(hashes.SHA256()),
                    salt_length=padding.PSS.MAX_LENGTH
                ),
                hashes.SHA256()
            )
            return True
        except:
            return False
```

## 3. å®‰å…¨ç›£æ§

### 3.1 å®‰å…¨å¯©è¨ˆ

```python
from typing import Dict, List, Optional
import logging
import json
from datetime import datetime

class SecurityAuditLogger:
    """å®‰å…¨å¯©è¨ˆæ—¥èªŒ"""
    def __init__(self,
                 log_file: str = 'security_audit.log'):
        self.logger = logging.getLogger('security_audit')
        self.logger.setLevel(logging.INFO)
        
        handler = logging.FileHandler(log_file)
        handler.setFormatter(
            logging.Formatter(
                '%(asctime)s - %(levelname)s - %(message)s'
            )
        )
        self.logger.addHandler(handler)
    
    def log_auth_attempt(self,
                       user_id: str,
                       success: bool,
                       ip_address: str):
        """è¨˜éŒ„èªè­‰å˜—è©¦"""
        self.logger.info(
            json.dumps({
                'event_type': 'auth_attempt',
                'user_id': user_id,
                'success': success,
                'ip_address': ip_address,
                'timestamp': datetime.utcnow().isoformat()
            })
        )
    
    def log_permission_check(self,
                          user_id: str,
                          resource_id: str,
                          permission: str,
                          granted: bool):
        """è¨˜éŒ„æ¬Šé™æª¢æŸ¥"""
        self.logger.info(
            json.dumps({
                'event_type': 'permission_check',
                'user_id': user_id,
                'resource_id': resource_id,
                'permission': permission,
                'granted': granted,
                'timestamp': datetime.utcnow().isoformat()
            })
        )
    
    def log_data_access(self,
                      user_id: str,
                      resource_id: str,
                      operation: str):
        """è¨˜éŒ„æ•¸æ“šè¨ªå•"""
        self.logger.info(
            json.dumps({
                'event_type': 'data_access',
                'user_id': user_id,
                'resource_id': resource_id,
                'operation': operation,
                'timestamp': datetime.utcnow().isoformat()
            })
        )

class SecurityMonitor:
    """å®‰å…¨ç›£æ§å™¨"""
    def __init__(self,
                 threshold: int = 5,
                 window: int = 300):
        self.threshold = threshold
        self.window = window
        self.failed_attempts: Dict[str, List[float]] = {}
    
    def record_failed_attempt(self,
                           user_id: str):
        """è¨˜éŒ„å¤±æ•—å˜—è©¦"""
        current_time = time.time()
        
        if user_id not in self.failed_attempts:
            self.failed_attempts[user_id] = []
        
        self.failed_attempts[user_id].append(current_time)
        self._cleanup_old_attempts(user_id)
    
    def is_blocked(self,
                  user_id: str) -> bool:
        """æª¢æŸ¥æ˜¯å¦è¢«é˜»æ­¢"""
        if user_id not in self.failed_attempts:
            return False
        
        self._cleanup_old_attempts(user_id)
        return len(self.failed_attempts[user_id]) >= self.threshold
    
    def _cleanup_old_attempts(self,
                           user_id: str):
        """æ¸…ç†éæœŸå˜—è©¦"""
        if user_id not in self.failed_attempts:
            return
        
        current_time = time.time()
        self.failed_attempts[user_id] = [
            t for t in self.failed_attempts[user_id]
            if current_time - t <= self.window
        ]

class SecurityAnalyzer:
    """å®‰å…¨åˆ†æå™¨"""
    def __init__(self,
                 audit_log: str = 'security_audit.log'):
        self.audit_log = audit_log
    
    def analyze_auth_attempts(self,
                           time_range: Tuple[datetime, datetime]) -> Dict:
        """åˆ†æèªè­‰å˜—è©¦"""
        attempts = {
            'total': 0,
            'success': 0,
            'failure': 0,
            'by_ip': {}
        }
        
        with open(self.audit_log, 'r') as f:
            for line in f:
                event = json.loads(line.split(' - ')[-1])
                if event['event_type'] != 'auth_attempt':
                    continue
                
                timestamp = datetime.fromisoformat(
                    event['timestamp']
                )
                if not (time_range[0] <= timestamp <= time_range[1]):
                    continue
                
                attempts['total'] += 1
                if event['success']:
                    attempts['success'] += 1
                else:
                    attempts['failure'] += 1
                
                ip = event['ip_address']
                if ip not in attempts['by_ip']:
                    attempts['by_ip'][ip] = {
                        'total': 0,
                        'success': 0,
                        'failure': 0
                    }
                
                attempts['by_ip'][ip]['total'] += 1
                if event['success']:
                    attempts['by_ip'][ip]['success'] += 1
                else:
                    attempts['by_ip'][ip]['failure'] += 1
        
        return attempts
    
    def analyze_data_access(self,
                          time_range: Tuple[datetime, datetime]) -> Dict:
        """åˆ†ææ•¸æ“šè¨ªå•"""
        access = {
            'total': 0,
            'by_user': {},
            'by_resource': {},
            'by_operation': {}
        }
        
        with open(self.audit_log, 'r') as f:
            for line in f:
                event = json.loads(line.split(' - ')[-1])
                if event['event_type'] != 'data_access':
                    continue
                
                timestamp = datetime.fromisoformat(
                    event['timestamp']
                )
                if not (time_range[0] <= timestamp <= time_range[1]):
                    continue
                
                access['total'] += 1
                
                user_id = event['user_id']
                if user_id not in access['by_user']:
                    access['by_user'][user_id] = 0
                access['by_user'][user_id] += 1
                
                resource_id = event['resource_id']
                if resource_id not in access['by_resource']:
                    access['by_resource'][resource_id] = 0
                access['by_resource'][resource_id] += 1
                
                operation = event['operation']
                if operation not in access['by_operation']:
                    access['by_operation'][operation] = 0
                access['by_operation'][operation] += 1
        
        return access
```

## ç·´ç¿’é¡Œ ğŸƒâ€â™‚ï¸

1. å¯¦ç¾å®‰å…¨èªè­‰ï¼š
   - å¯†ç¢¼åŠ å¯†å­˜å„²
   - ä»¤ç‰Œç”Ÿæˆé©—è­‰
   - é›™å› ç´ èªè­‰
   - æœƒè©±ç®¡ç†
   - æ¬Šé™æ§åˆ¶

2. é–‹ç™¼åŠ å¯†ç³»çµ±ï¼š
   - å°ç¨±åŠ å¯†
   - éå°ç¨±åŠ å¯†
   - æ•¸å­—ç°½å
   - å¯†é‘°ç®¡ç†
   - å®‰å…¨å‚³è¼¸

3. å¯¦ç¾å®‰å…¨ç›£æ§ï¼š
   - å¯©è¨ˆæ—¥èªŒ
   - ç•°å¸¸æª¢æ¸¬
   - è¨ªå•æ§åˆ¶
   - é¢¨éšªè©•ä¼°
   - å®‰å…¨å ±å‘Š

4. å‰µå»ºé˜²è­·ç³»çµ±ï¼š
   - è¼¸å…¥é©—è­‰
   - SQLæ³¨å…¥é˜²è­·
   - XSSé˜²è­·
   - CSRFé˜²è­·
   - è«‹æ±‚é™æµ

5. é–‹ç™¼æ¸¬è©¦æ–¹æ¡ˆï¼š
   - æ»²é€æ¸¬è©¦
   - æ¼æ´æƒæ
   - å®‰å…¨è©•ä¼°
   - å£“åŠ›æ¸¬è©¦
   - æ‡‰æ€¥æ¼”ç·´

## å°çµ ğŸ“

- äº†è§£äº†ç³»çµ±å®‰å…¨çš„æ ¸å¿ƒæ¦‚å¿µ
- æŒæ¡äº†èº«ä»½èªè­‰çš„å¯¦ç¾æ–¹æ³•
- å­¸æœƒäº†æ•¸æ“šåŠ å¯†çš„å¤šç¨®ç­–ç•¥
- ç†è§£äº†å®‰å…¨ç›£æ§çš„é‡è¦æ€§
- æŒæ¡äº†å®‰å…¨é˜²è­·çš„æœ€ä½³å¯¦è¸

## å»¶ä¼¸é–±è®€ ğŸ“š

1. Web æ‡‰ç”¨å®‰å…¨æŒ‡å—
2. å¯†ç¢¼å­¸å¯¦è¸æŒ‡å—
3. ç³»çµ±å®‰å…¨æ¶æ§‹
4. å®‰å…¨å¯©è¨ˆå¯¦æˆ°
5. æ‡‰æ€¥éŸ¿æ‡‰æ‰‹å†Š

[ä¸Šä¸€ç« ï¼šæ€§èƒ½å„ªåŒ–å¯¦è¸](145_æ€§èƒ½å„ªåŒ–å¯¦è¸.md) | [ä¸‹ä¸€ç« ï¼šå®¹å™¨åŒ–éƒ¨ç½²](147_å®¹å™¨åŒ–éƒ¨ç½².md) 