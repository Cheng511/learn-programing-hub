[ä¸Šä¸€ç« ï¼šAIå®‰å…¨èˆ‡éš±ç§](125_AIå®‰å…¨èˆ‡éš±ç§.md) | [ä¸‹ä¸€ç« ï¼šæœå‹™ç¶²æ ¼æ‡‰ç”¨](127_æœå‹™ç¶²æ ¼æ‡‰ç”¨.md)

# Python å¾®æœå‹™æ¶æ§‹è¨­è¨ˆ ğŸ—ï¸

## 1. å¾®æœå‹™åŸºç¤æ¶æ§‹

### 1.1 æœå‹™å®šç¾©

```python
from fastapi import FastAPI, HTTPException
from pydantic import BaseModel
from typing import List, Dict, Optional
import uvicorn
import asyncio
import aiohttp

class ServiceRegistry:
    def __init__(self):
        self.services: Dict[str, Dict] = {}
    
    def register(self, service_name: str, host: str, port: int):
        """è¨»å†Šæœå‹™"""
        self.services[service_name] = {
            'host': host,
            'port': port,
            'url': f'http://{host}:{port}',
            'status': 'active'
        }
    
    def deregister(self, service_name: str):
        """è¨»éŠ·æœå‹™"""
        if service_name in self.services:
            del self.services[service_name]
    
    def get_service(self, service_name: str) -> Optional[Dict]:
        """ç²å–æœå‹™ä¿¡æ¯"""
        return self.services.get(service_name)

class MicroService:
    def __init__(self, name: str, host: str, port: int):
        self.name = name
        self.host = host
        self.port = port
        self.app = FastAPI(title=name)
        self.registry = ServiceRegistry()
        
        self.setup_routes()
    
    def setup_routes(self):
        """è¨­ç½®è·¯ç”±"""
        @self.app.get('/health')
        async def health_check():
            return {'status': 'healthy', 'service': self.name}
    
    def run(self):
        """é‹è¡Œæœå‹™"""
        uvicorn.run(self.app, host=self.host, port=self.port)
```

### 1.2 æœå‹™é€šä¿¡

```python
class ServiceClient:
    def __init__(self, registry: ServiceRegistry):
        self.registry = registry
        self.session = aiohttp.ClientSession()
    
    async def call_service(self, service_name: str,
                          endpoint: str, method: str = 'GET',
                          **kwargs) -> Dict:
        """èª¿ç”¨æœå‹™"""
        service = self.registry.get_service(service_name)
        if not service:
            raise ValueError(f"Service {service_name} not found")
        
        url = f"{service['url']}/{endpoint.lstrip('/')}"
        
        async with self.session.request(method, url, **kwargs) as response:
            if response.status >= 400:
                raise HTTPException(
                    status_code=response.status,
                    detail=await response.text()
                )
            return await response.json()
    
    async def close(self):
        """é—œé–‰å®¢æˆ¶ç«¯"""
        await self.session.close()

class ServiceCommunicator:
    def __init__(self, service: MicroService):
        self.service = service
        self.client = ServiceClient(service.registry)
    
    async def broadcast(self, message: Dict):
        """å»£æ’­æ¶ˆæ¯çµ¦æ‰€æœ‰æœå‹™"""
        tasks = []
        for service_name in self.service.registry.services:
            if service_name != self.service.name:
                tasks.append(
                    self.client.call_service(
                        service_name,
                        'broadcast',
                        method='POST',
                        json=message
                    )
                )
        return await asyncio.gather(*tasks, return_exceptions=True)
```

## 2. æœå‹™è¨­è¨ˆæ¨¡å¼

### 2.1 æ–·è·¯å™¨æ¨¡å¼

```python
import time
from functools import wraps

class CircuitBreaker:
    def __init__(self, failure_threshold: int = 5,
                 reset_timeout: int = 60):
        self.failure_threshold = failure_threshold
        self.reset_timeout = reset_timeout
        self.failures = 0
        self.last_failure_time = 0
        self.state = 'closed'
    
    def __call__(self, func):
        @wraps(func)
        async def wrapper(*args, **kwargs):
            if self.state == 'open':
                if time.time() - self.last_failure_time > self.reset_timeout:
                    self.state = 'half-open'
                else:
                    raise HTTPException(
                        status_code=503,
                        detail="Service temporarily unavailable"
                    )
            
            try:
                result = await func(*args, **kwargs)
                if self.state == 'half-open':
                    self.state = 'closed'
                    self.failures = 0
                return result
            except Exception as e:
                self.failures += 1
                self.last_failure_time = time.time()
                
                if self.failures >= self.failure_threshold:
                    self.state = 'open'
                
                raise e
        
        return wrapper
```

### 2.2 é™æµå™¨æ¨¡å¼

```python
import asyncio
from datetime import datetime, timedelta

class RateLimiter:
    def __init__(self, max_requests: int = 100,
                 time_window: int = 60):
        self.max_requests = max_requests
        self.time_window = time_window
        self.requests = []
    
    async def acquire(self):
        """ç²å–è«‹æ±‚è¨±å¯"""
        now = datetime.now()
        
        # æ¸…ç†éæœŸè«‹æ±‚
        self.requests = [
            req_time for req_time in self.requests
            if now - req_time < timedelta(seconds=self.time_window)
        ]
        
        if len(self.requests) >= self.max_requests:
            raise HTTPException(
                status_code=429,
                detail="Too many requests"
            )
        
        self.requests.append(now)
        return True

class TokenBucket:
    def __init__(self, capacity: int = 100,
                 refill_rate: float = 1.0):
        self.capacity = capacity
        self.refill_rate = refill_rate
        self.tokens = capacity
        self.last_refill = time.time()
    
    async def consume(self, tokens: int = 1):
        """æ¶ˆè€—ä»¤ç‰Œ"""
        await self._refill()
        
        if self.tokens >= tokens:
            self.tokens -= tokens
            return True
        return False
    
    async def _refill(self):
        """è£œå……ä»¤ç‰Œ"""
        now = time.time()
        delta = now - self.last_refill
        self.tokens = min(
            self.capacity,
            self.tokens + delta * self.refill_rate
        )
        self.last_refill = now
```

## 3. æœå‹™ç›£æ§èˆ‡è¿½è¸ª

### 3.1 åˆ†å¸ƒå¼è¿½è¸ª

```python
import uuid
from contextvars import ContextVar
from typing import Optional

class TraceContext:
    def __init__(self, trace_id: Optional[str] = None,
                 parent_span_id: Optional[str] = None):
        self.trace_id = trace_id or str(uuid.uuid4())
        self.parent_span_id = parent_span_id
        self.span_id = str(uuid.uuid4())

current_trace_context: ContextVar[TraceContext] = ContextVar('trace_context')

class Tracer:
    def __init__(self):
        self.spans = []
    
    async def start_span(self, name: str,
                        parent_context: Optional[TraceContext] = None):
        """é–‹å§‹ä¸€å€‹è¿½è¸ªç¯„åœ"""
        context = TraceContext(
            trace_id=parent_context.trace_id if parent_context else None,
            parent_span_id=parent_context.span_id if parent_context else None
        )
        current_trace_context.set(context)
        
        span = {
            'name': name,
            'trace_id': context.trace_id,
            'span_id': context.span_id,
            'parent_span_id': context.parent_span_id,
            'start_time': time.time()
        }
        self.spans.append(span)
        return context
    
    async def end_span(self, context: TraceContext):
        """çµæŸè¿½è¸ªç¯„åœ"""
        for span in self.spans:
            if span['span_id'] == context.span_id:
                span['end_time'] = time.time()
                span['duration'] = span['end_time'] - span['start_time']
                break
```

### 3.2 æŒ‡æ¨™æ”¶é›†

```python
from prometheus_client import Counter, Histogram, Gauge
import time

class MetricsCollector:
    def __init__(self):
        # è«‹æ±‚è¨ˆæ•¸å™¨
        self.request_count = Counter(
            'request_total',
            'Total request count',
            ['service', 'endpoint', 'method']
        )
        
        # éŸ¿æ‡‰æ™‚é–“ç›´æ–¹åœ–
        self.response_time = Histogram(
            'response_time_seconds',
            'Response time in seconds',
            ['service', 'endpoint']
        )
        
        # æ´»èºé€£æ¥æ•¸
        self.active_connections = Gauge(
            'active_connections',
            'Number of active connections'
        )
    
    def track_request(self, service: str, endpoint: str,
                     method: str):
        """è¿½è¸ªè«‹æ±‚"""
        self.request_count.labels(
            service=service,
            endpoint=endpoint,
            method=method
        ).inc()
    
    @contextmanager
    def track_response_time(self, service: str, endpoint: str):
        """è¿½è¸ªéŸ¿æ‡‰æ™‚é–“"""
        start_time = time.time()
        try:
            yield
        finally:
            duration = time.time() - start_time
            self.response_time.labels(
                service=service,
                endpoint=endpoint
            ).observe(duration)
```

## ç·´ç¿’é¡Œ ğŸƒ

1. å¯¦ç¾ä¸€å€‹å®Œæ•´çš„å¾®æœå‹™è¨»å†Šèˆ‡ç™¼ç¾ç³»çµ±ã€‚
2. é–‹ç™¼ä¸€å€‹å¸¶æœ‰æ–·è·¯å™¨å’Œé™æµå™¨çš„APIç¶²é—œã€‚
3. è¨­è¨ˆä¸€å€‹åˆ†å¸ƒå¼è¿½è¸ªç³»çµ±ã€‚
4. å¯¦ç¾ä¸€å€‹æœå‹™å¥åº·æª¢æŸ¥æ©Ÿåˆ¶ã€‚
5. å‰µå»ºä¸€å€‹å¾®æœå‹™ç›£æ§å„€è¡¨æ¿ã€‚

## å°çµ ğŸ“

- å­¸ç¿’äº†å¾®æœå‹™æ¶æ§‹çš„åŸºæœ¬æ¦‚å¿µ
- æŒæ¡äº†æœå‹™é€šä¿¡æ–¹å¼
- ç†è§£äº†å¸¸ç”¨è¨­è¨ˆæ¨¡å¼
- å­¸æœƒäº†åˆ†å¸ƒå¼è¿½è¸ª
- äº†è§£äº†æœå‹™ç›£æ§æ–¹æ³•

## å»¶ä¼¸é–±è®€ ğŸ“š

1. Microservices Patterns
2. Building Microservices
3. Distributed Systems Architecture
4. Service Mesh in Practice
5. Monitoring Distributed Systems

[ä¸Šä¸€ç« ï¼šAIå®‰å…¨èˆ‡éš±ç§](125_AIå®‰å…¨èˆ‡éš±ç§.md) | [ä¸‹ä¸€ç« ï¼šæœå‹™ç¶²æ ¼æ‡‰ç”¨](127_æœå‹™ç¶²æ ¼æ‡‰ç”¨.md) 