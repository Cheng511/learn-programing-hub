[ä¸Šä¸€ç« ï¼šè¨ˆç®—æ©Ÿè¦–è¦ºåŸºç¤](102_è¨ˆç®—æ©Ÿè¦–è¦ºåŸºç¤.md) | [ä¸‹ä¸€ç« ï¼šæ©Ÿå™¨äººåŸºç¤](104_æ©Ÿå™¨äººåŸºç¤.md)

# Python è¨ˆç®—æ©Ÿè¦–è¦ºé€²éš ğŸ‘ï¸

## é«˜ç´šåœ–åƒè™•ç†

### 1. åœ–åƒåˆ†å‰²

```python
import cv2
import numpy as np
from typing import Tuple, List, Optional, Dict
import time
import sys
import os

class ImageSegmenter:
    def __init__(self):
        """åˆå§‹åŒ–åœ–åƒåˆ†å‰²å™¨"""
        try:
            self.image = None
            self.segmented = None
            self.height = 0
            self.width = 0
            self.channels = 0
            
            print("Image segmenter initialized")
            
        except Exception as e:
            print(f"Error initializing image segmenter: {e}")
    
    def read_image(self, image_path: str) -> bool:
        """è®€å–åœ–åƒ"""
        try:
            # è®€å–åœ–åƒ
            self.image = cv2.imread(image_path)
            
            if self.image is None:
                raise ValueError(f"Failed to read image: {image_path}")
            
            # ç²å–åœ–åƒä¿¡æ¯
            self.height, self.width = self.image.shape[:2]
            self.channels = self.image.shape[2] if len(self.image.shape) > 2 else 1
            
            print(f"Image loaded: {self.width}x{self.height} with {self.channels} channels")
            return True
            
        except Exception as e:
            print(f"Error reading image: {e}")
            return False
    
    def threshold_segmentation(self, threshold: int = 127) -> np.ndarray:
        """é–¾å€¼åˆ†å‰²"""
        try:
            if self.image is None:
                raise ValueError("No image loaded")
            
            # è½‰æ›ç‚ºç°åº¦åœ–
            if len(self.image.shape) == 3:
                gray = cv2.cvtColor(self.image, cv2.COLOR_BGR2GRAY)
            else:
                gray = self.image
            
            # æ‡‰ç”¨é–¾å€¼åˆ†å‰²
            _, segmented = cv2.threshold(gray, threshold, 255, cv2.THRESH_BINARY)
            
            return segmented
            
        except Exception as e:
            print(f"Error in threshold segmentation: {e}")
            return np.array([])
    
    def kmeans_segmentation(self, k: int = 3) -> np.ndarray:
        """K-meansåˆ†å‰²"""
        try:
            if self.image is None:
                raise ValueError("No image loaded")
            
            # é‡å¡‘åœ–åƒ
            pixel_values = self.image.reshape((-1, 3))
            pixel_values = np.float32(pixel_values)
            
            # å®šç¾©åœæ­¢æ¢ä»¶
            criteria = (cv2.TERM_CRITERIA_EPS + cv2.TERM_CRITERIA_MAX_ITER, 100, 0.2)
            
            # æ‡‰ç”¨K-means
            _, labels, centers = cv2.kmeans(pixel_values, k, None, criteria, 10, cv2.KMEANS_RANDOM_CENTERS)
            
            # è½‰æ›å›uint8
            centers = np.uint8(centers)
            segmented_data = centers[labels.flatten()]
            
            # é‡å¡‘å›åŸå§‹åœ–åƒ
            segmented = segmented_data.reshape(self.image.shape)
            
            return segmented
            
        except Exception as e:
            print(f"Error in K-means segmentation: {e}")
            return np.array([])
    
    def watershed_segmentation(self) -> np.ndarray:
        """åˆ†æ°´å¶ºåˆ†å‰²"""
        try:
            if self.image is None:
                raise ValueError("No image loaded")
            
            # è½‰æ›ç‚ºç°åº¦åœ–
            if len(self.image.shape) == 3:
                gray = cv2.cvtColor(self.image, cv2.COLOR_BGR2GRAY)
            else:
                gray = self.image
            
            # é«˜æ–¯æ¨¡ç³Š
            blurred = cv2.GaussianBlur(gray, (5, 5), 0)
            
            # é–¾å€¼åˆ†å‰²
            _, thresh = cv2.threshold(blurred, 0, 255, cv2.THRESH_BINARY_INV + cv2.THRESH_OTSU)
            
            # å½¢æ…‹å­¸æ“ä½œ
            kernel = np.ones((3, 3), np.uint8)
            opening = cv2.morphologyEx(thresh, cv2.MORPH_OPEN, kernel, iterations=2)
            
            # ç¢ºå®šèƒŒæ™¯å€åŸŸ
            sure_bg = cv2.dilate(opening, kernel, iterations=3)
            
            # ç¢ºå®šå‰æ™¯å€åŸŸ
            dist_transform = cv2.distanceTransform(opening, cv2.DIST_L2, 5)
            _, sure_fg = cv2.threshold(dist_transform, 0.5 * dist_transform.max(), 255, 0)
            sure_fg = np.uint8(sure_fg)
            
            # æ‰¾åˆ°æœªçŸ¥å€åŸŸ
            unknown = cv2.subtract(sure_bg, sure_fg)
            
            # æ¨™è¨˜
            _, markers = cv2.connectedComponents(sure_fg)
            markers = markers + 1
            markers[unknown == 255] = 0
            
            # æ‡‰ç”¨åˆ†æ°´å¶ºç®—æ³•
            markers = cv2.watershed(self.image, markers)
            
            # ç¹ªè£½åˆ†å‰²çµæœ
            segmented = self.image.copy()
            segmented[markers == -1] = [0, 0, 255]
            
            return segmented
            
        except Exception as e:
            print(f"Error in watershed segmentation: {e}")
            return np.array([])
    
    def grabcut_segmentation(self, rect: Tuple[int, int, int, int]) -> np.ndarray:
        """GrabCutåˆ†å‰²"""
        try:
            if self.image is None:
                raise ValueError("No image loaded")
            
            # å‰µå»ºæ©ç¢¼
            mask = np.zeros(self.image.shape[:2], np.uint8)
            bgd_model = np.zeros((1, 65), np.float64)
            fgd_model = np.zeros((1, 65), np.float64)
            
            # æ‡‰ç”¨GrabCut
            cv2.grabCut(self.image, mask, rect, bgd_model, fgd_model, 5, cv2.GC_INIT_WITH_RECT)
            
            # å‰µå»ºæ©ç¢¼
            mask2 = np.where((mask == cv2.GC_FGD) | (mask == cv2.GC_PR_FGD), 255, 0).astype('uint8')
            
            # æ‡‰ç”¨æ©ç¢¼
            segmented = cv2.bitwise_and(self.image, self.image, mask=mask2)
            
            return segmented
            
        except Exception as e:
            print(f"Error in GrabCut segmentation: {e}")
            return np.array([])
    
    def save_image(self, image: np.ndarray, output_path: str) -> bool:
        """ä¿å­˜åœ–åƒ"""
        try:
            if image.size == 0:
                raise ValueError("Empty image")
            
            # ä¿å­˜åœ–åƒ
            success = cv2.imwrite(output_path, image)
            
            if success:
                print(f"Image saved to: {output_path}")
            else:
                print(f"Failed to save image: {output_path}")
            
            return success
            
        except Exception as e:
            print(f"Error saving image: {e}")
            return False

# ä½¿ç”¨ç¤ºä¾‹
def main():
    # å‰µå»ºåœ–åƒåˆ†å‰²å™¨
    segmenter = ImageSegmenter()
    
    try:
        # è®€å–åœ–åƒ
        image_path = "example.jpg"
        if segmenter.read_image(image_path):
            # é–¾å€¼åˆ†å‰²
            threshold_segmented = segmenter.threshold_segmentation()
            segmenter.save_image(threshold_segmented, "threshold_segmented.jpg")
            
            # K-meansåˆ†å‰²
            kmeans_segmented = segmenter.kmeans_segmentation()
            segmenter.save_image(kmeans_segmented, "kmeans_segmented.jpg")
            
            # åˆ†æ°´å¶ºåˆ†å‰²
            watershed_segmented = segmenter.watershed_segmentation()
            segmenter.save_image(watershed_segmented, "watershed_segmented.jpg")
            
            # GrabCutåˆ†å‰²
            rect = (100, 100, 400, 300)  # ç¤ºä¾‹çŸ©å½¢
            grabcut_segmented = segmenter.grabcut_segmentation(rect)
            segmenter.save_image(grabcut_segmented, "grabcut_segmented.jpg")
    
    except Exception as e:
        print(f"Error in main: {e}")

if __name__ == '__main__':
    main()
```

### 2. ç›®æ¨™æª¢æ¸¬

```python
import cv2
import numpy as np
from typing import Tuple, List, Optional, Dict
import time
import sys
import os

class ObjectDetector:
    def __init__(self):
        """åˆå§‹åŒ–ç›®æ¨™æª¢æ¸¬å™¨"""
        try:
            # åŠ è¼‰é è¨“ç·´æ¨¡å‹
            self.net = cv2.dnn.readNet("yolov3.weights", "yolov3.cfg")
            
            # åŠ è¼‰é¡åˆ¥åç¨±
            with open("coco.names", "r") as f:
                self.classes = [line.strip() for line in f.readlines()]
            
            # ç²å–è¼¸å‡ºå±¤
            self.layer_names = self.net.getLayerNames()
            self.output_layers = [self.layer_names[i - 1] for i in self.net.getUnconnectedOutLayers()]
            
            # è¨­ç½®éš¨æ©Ÿé¡è‰²
            self.colors = np.random.uniform(0, 255, size=(len(self.classes), 3))
            
            print("Object detector initialized")
            
        except Exception as e:
            print(f"Error initializing object detector: {e}")
    
    def detect_objects(self, image: np.ndarray) -> Tuple[List[Dict], np.ndarray]:
        """æª¢æ¸¬ç›®æ¨™"""
        try:
            # ç²å–åœ–åƒå°ºå¯¸
            height, width = image.shape[:2]
            
            # æº–å‚™åœ–åƒ
            blob = cv2.dnn.blobFromImage(image, 0.00392, (416, 416), (0, 0, 0), True, crop=False)
            
            # å‰å‘å‚³æ’­
            self.net.setInput(blob)
            outs = self.net.forward(self.output_layers)
            
            # åˆå§‹åŒ–æª¢æ¸¬çµæœ
            class_ids = []
            confidences = []
            boxes = []
            
            # è™•ç†æª¢æ¸¬çµæœ
            for out in outs:
                for detection in out:
                    scores = detection[5:]
                    class_id = np.argmax(scores)
                    confidence = scores[class_id]
                    
                    if confidence > 0.5:
                        # è¨ˆç®—é‚Šç•Œæ¡†
                        center_x = int(detection[0] * width)
                        center_y = int(detection[1] * height)
                        w = int(detection[2] * width)
                        h = int(detection[3] * height)
                        
                        # è¨ˆç®—é‚Šç•Œæ¡†åº§æ¨™
                        x = int(center_x - w / 2)
                        y = int(center_y - h / 2)
                        
                        boxes.append([x, y, w, h])
                        confidences.append(float(confidence))
                        class_ids.append(class_id)
            
            # æ‡‰ç”¨éæ¥µå¤§å€¼æŠ‘åˆ¶
            indexes = cv2.dnn.NMSBoxes(boxes, confidences, 0.5, 0.4)
            
            # æ•´ç†æª¢æ¸¬çµæœ
            results = []
            for i in range(len(boxes)):
                if i in indexes:
                    results.append({
                        'class': self.classes[class_ids[i]],
                        'confidence': confidences[i],
                        'box': boxes[i]
                    })
            
            # ç¹ªè£½æª¢æ¸¬çµæœ
            output = image.copy()
            for result in results:
                x, y, w, h = result['box']
                label = f"{result['class']} {result['confidence']:.2f}"
                color = self.colors[self.classes.index(result['class'])]
                
                cv2.rectangle(output, (x, y), (x + w, y + h), color, 2)
                cv2.putText(output, label, (x, y - 10), cv2.FONT_HERSHEY_SIMPLEX, 0.5, color, 2)
            
            return results, output
            
        except Exception as e:
            print(f"Error detecting objects: {e}")
            return [], np.array([])
    
    def detect_faces(self, image: np.ndarray) -> Tuple[List[Tuple[int, int, int, int]], np.ndarray]:
        """æª¢æ¸¬äººè‡‰"""
        try:
            # åŠ è¼‰äººè‡‰æª¢æ¸¬å™¨
            face_cascade = cv2.CascadeClassifier(cv2.data.haarcascades + 'haarcascade_frontalface_default.xml')
            
            # è½‰æ›ç‚ºç°åº¦åœ–
            if len(image.shape) == 3:
                gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)
            else:
                gray = image
            
            # æª¢æ¸¬äººè‡‰
            faces = face_cascade.detectMultiScale(gray, 1.3, 5)
            
            # ç¹ªè£½æª¢æ¸¬çµæœ
            output = image.copy()
            for (x, y, w, h) in faces:
                cv2.rectangle(output, (x, y), (x + w, y + h), (255, 0, 0), 2)
            
            return faces.tolist(), output
            
        except Exception as e:
            print(f"Error detecting faces: {e}")
            return [], np.array([])
    
    def detect_edges(self, image: np.ndarray) -> np.ndarray:
        """æª¢æ¸¬é‚Šç·£"""
        try:
            # è½‰æ›ç‚ºç°åº¦åœ–
            if len(image.shape) == 3:
                gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)
            else:
                gray = image
            
            # æ‡‰ç”¨Cannyé‚Šç·£æª¢æ¸¬
            edges = cv2.Canny(gray, 100, 200)
            
            return edges
            
        except Exception as e:
            print(f"Error detecting edges: {e}")
            return np.array([])
    
    def save_image(self, image: np.ndarray, output_path: str) -> bool:
        """ä¿å­˜åœ–åƒ"""
        try:
            if image.size == 0:
                raise ValueError("Empty image")
            
            # ä¿å­˜åœ–åƒ
            success = cv2.imwrite(output_path, image)
            
            if success:
                print(f"Image saved to: {output_path}")
            else:
                print(f"Failed to save image: {output_path}")
            
            return success
            
        except Exception as e:
            print(f"Error saving image: {e}")
            return False

# ä½¿ç”¨ç¤ºä¾‹
def main():
    # å‰µå»ºç›®æ¨™æª¢æ¸¬å™¨
    detector = ObjectDetector()
    
    try:
        # è®€å–åœ–åƒ
        image = cv2.imread("example.jpg")
        
        if image is not None:
            # æª¢æ¸¬ç›®æ¨™
            results, output = detector.detect_objects(image)
            print(f"Detected {len(results)} objects")
            detector.save_image(output, "object_detection.jpg")
            
            # æª¢æ¸¬äººè‡‰
            faces, face_output = detector.detect_faces(image)
            print(f"Detected {len(faces)} faces")
            detector.save_image(face_output, "face_detection.jpg")
            
            # æª¢æ¸¬é‚Šç·£
            edges = detector.detect_edges(image)
            detector.save_image(edges, "edge_detection.jpg")
    
    except Exception as e:
        print(f"Error in main: {e}")

if __name__ == '__main__':
    main()
```

## ç·´ç¿’é¡Œ

1. **åœ–åƒåˆ†å‰²**
   é–‹ç™¼åœ–åƒåˆ†å‰²ï¼š
   - é–¾å€¼åˆ†å‰²
   - K-meansåˆ†å‰²
   - åˆ†æ°´å¶ºåˆ†å‰²
   - å„ªåŒ–æ€§èƒ½

2. **ç›®æ¨™æª¢æ¸¬**
   å‰µå»ºç›®æ¨™æª¢æ¸¬ï¼š
   - YOLOæª¢æ¸¬
   - äººè‡‰æª¢æ¸¬
   - é‚Šç·£æª¢æ¸¬
   - å„ªåŒ–æ€§èƒ½

3. **è¨ˆç®—æ©Ÿè¦–è¦º**
   å¯¦ç¾è¨ˆç®—æ©Ÿè¦–è¦ºï¼š
   - è™•ç†åœ–åƒ
   - æª¢æ¸¬ç›®æ¨™
   - å„ªåŒ–æ€§èƒ½
   - è™•ç†ç•°å¸¸

## å°æé†’ ğŸ’¡

1. åœ–åƒåˆ†å‰²
   - é¸æ“‡åˆé©æ–¹æ³•
   - å„ªåŒ–åƒæ•¸
   - è™•ç†ç•°å¸¸
   - æä¾›ç›£æ§

2. ç›®æ¨™æª¢æ¸¬
   - é¸æ“‡åˆé©æ–¹æ³•
   - å„ªåŒ–æ€§èƒ½
   - è™•ç†ç•°å¸¸
   - æä¾›çµæœ

3. è¨ˆç®—æ©Ÿè¦–è¦º
   - é¸æ“‡åˆé©ç®—æ³•
   - å„ªåŒ–æ€§èƒ½
   - è™•ç†ç•°å¸¸
   - æä¾›ç›£æ§

4. èª¿è©¦æŠ€å·§
   - ä½¿ç”¨é–‹ç™¼å·¥å…·
   - åˆ†ææ€§èƒ½
   - å„ªåŒ–é—œéµè·¯å¾‘
   - ç›£æ§è™•ç†ç‹€æ…‹

[ä¸Šä¸€ç« ï¼šè¨ˆç®—æ©Ÿè¦–è¦ºåŸºç¤](102_è¨ˆç®—æ©Ÿè¦–è¦ºåŸºç¤.md) | [ä¸‹ä¸€ç« ï¼šæ©Ÿå™¨äººåŸºç¤](104_æ©Ÿå™¨äººåŸºç¤.md) 