[ä¸Šä¸€ç« ï¼šäº‹ä»¶é©…å‹•æ¶æ§‹](128_äº‹ä»¶é©…å‹•æ¶æ§‹.md) | [ä¸‹ä¸€ç« ï¼šç³»çµ±å¯è§€æ¸¬æ€§](130_ç³»çµ±å¯è§€æ¸¬æ€§.md)

# Python å¤§è¦æ¨¡æ•¸æ“šæµè™•ç† ğŸŒŠ

## 1. æµè™•ç†æ¡†æ¶

### 1.1 æµè™•ç†å¼•æ“

```python
from typing import Dict, List, Callable, Any, Generic, TypeVar
import asyncio
from dataclasses import dataclass
import time
import logging

T = TypeVar('T')
U = TypeVar('U')

@dataclass
class StreamRecord(Generic[T]):
    """æµè¨˜éŒ„"""
    data: T
    timestamp: float
    key: str = None

class StreamProcessor(Generic[T, U]):
    def __init__(self, name: str):
        self.name = name
        self.input_queue: asyncio.Queue[StreamRecord[T]] = asyncio.Queue()
        self.output_queue: asyncio.Queue[StreamRecord[U]] = asyncio.Queue()
        self.running = False
        self.logger = logging.getLogger(f"processor.{name}")
    
    async def process(self, transform: Callable[[T], U]):
        """è™•ç†æµæ•¸æ“š"""
        self.running = True
        
        while self.running:
            try:
                record = await self.input_queue.get()
                result = transform(record.data)
                
                await self.output_queue.put(StreamRecord(
                    data=result,
                    timestamp=time.time(),
                    key=record.key
                ))
            except Exception as e:
                self.logger.error(f"Error processing record: {str(e)}")
    
    def stop(self):
        """åœæ­¢è™•ç†"""
        self.running = False
```

### 1.2 çª—å£æ“ä½œ

```python
from collections import deque
from datetime import datetime, timedelta

class WindowedProcessor(Generic[T, U]):
    def __init__(self, window_size: int,
                 slide_size: int = None):
        self.window_size = window_size
        self.slide_size = slide_size or window_size
        self.buffer = deque(maxlen=window_size)
        self.last_emit = 0
    
    async def process_window(self,
                           window_function: Callable[[List[T]], U]):
        """è™•ç†çª—å£æ•¸æ“š"""
        current_time = time.time()
        
        # æª¢æŸ¥æ˜¯å¦éœ€è¦è§¸ç™¼çª—å£è¨ˆç®—
        if (current_time - self.last_emit) >= self.slide_size:
            window_data = list(self.buffer)
            if window_data:
                result = window_function(window_data)
                self.last_emit = current_time
                return result
        return None
    
    def add_record(self, record: StreamRecord[T]):
        """æ·»åŠ è¨˜éŒ„åˆ°çª—å£"""
        self.buffer.append(record)

class TimeWindowedProcessor(Generic[T, U]):
    def __init__(self, window_duration: timedelta,
                 slide_duration: timedelta = None):
        self.window_duration = window_duration
        self.slide_duration = slide_duration or window_duration
        self.buffer: Dict[datetime, List[StreamRecord[T]]] = {}
    
    def clean_old_windows(self):
        """æ¸…ç†éæœŸçª—å£"""
        current_time = datetime.now()
        cutoff_time = current_time - self.window_duration
        
        self.buffer = {
            ts: records
            for ts, records in self.buffer.items()
            if ts > cutoff_time
        }
    
    async def process_window(self,
                           window_function: Callable[[List[T]], U]):
        """è™•ç†æ™‚é–“çª—å£æ•¸æ“š"""
        self.clean_old_windows()
        current_time = datetime.now()
        window_start = current_time - self.window_duration
        
        # æ”¶é›†çª—å£å…§çš„æ‰€æœ‰æ•¸æ“š
        window_data = []
        for ts, records in self.buffer.items():
            if window_start <= ts <= current_time:
                window_data.extend(records)
        
        if window_data:
            return window_function([r.data for r in window_data])
        return None
```

## 2. æ•¸æ“šæµè½‰æ›

### 2.1 æµè½‰æ›æ“ä½œ

```python
from abc import ABC, abstractmethod

class StreamTransform(ABC, Generic[T, U]):
    @abstractmethod
    async def transform(self, record: StreamRecord[T]) -> StreamRecord[U]:
        """è½‰æ›æµè¨˜éŒ„"""
        pass

class MapTransform(StreamTransform[T, U]):
    def __init__(self, mapper: Callable[[T], U]):
        self.mapper = mapper
    
    async def transform(self, record: StreamRecord[T]) -> StreamRecord[U]:
        """æ˜ å°„è½‰æ›"""
        return StreamRecord(
            data=self.mapper(record.data),
            timestamp=record.timestamp,
            key=record.key
        )

class FilterTransform(StreamTransform[T, T]):
    def __init__(self, predicate: Callable[[T], bool]):
        self.predicate = predicate
    
    async def transform(self, record: StreamRecord[T]) -> StreamRecord[T]:
        """éæ¿¾è½‰æ›"""
        if self.predicate(record.data):
            return record
        return None

class AggregateTransform(StreamTransform[T, U]):
    def __init__(self, aggregator: Callable[[List[T]], U],
                 window_size: int):
        self.aggregator = aggregator
        self.window = WindowedProcessor[T, U](window_size)
    
    async def transform(self, record: StreamRecord[T]) -> StreamRecord[U]:
        """èšåˆè½‰æ›"""
        self.window.add_record(record)
        result = await self.window.process_window(self.aggregator)
        
        if result is not None:
            return StreamRecord(
                data=result,
                timestamp=time.time(),
                key=record.key
            )
        return None
```

### 2.2 æµå¼Join

```python
class StreamJoiner(Generic[T, U]):
    def __init__(self, window_duration: timedelta):
        self.window_duration = window_duration
        self.left_stream: Dict[str, List[StreamRecord[T]]] = {}
        self.right_stream: Dict[str, List[StreamRecord[U]]] = {}
    
    def add_left(self, record: StreamRecord[T]):
        """æ·»åŠ å·¦æµè¨˜éŒ„"""
        if record.key not in self.left_stream:
            self.left_stream[record.key] = []
        self.left_stream[record.key].append(record)
    
    def add_right(self, record: StreamRecord[U]):
        """æ·»åŠ å³æµè¨˜éŒ„"""
        if record.key not in self.right_stream:
            self.right_stream[record.key] = []
        self.right_stream[record.key].append(record)
    
    async def join(self) -> List[Tuple[T, U]]:
        """åŸ·è¡Œæµå¼Join"""
        current_time = time.time()
        results = []
        
        # éæ­·æ‰€æœ‰éµ
        for key in set(self.left_stream.keys()) | set(self.right_stream.keys()):
            left_records = self.left_stream.get(key, [])
            right_records = self.right_stream.get(key, [])
            
            # éæ¿¾æ™‚é–“çª—å£å…§çš„è¨˜éŒ„
            left_records = [
                r for r in left_records
                if current_time - r.timestamp <= self.window_duration.total_seconds()
            ]
            right_records = [
                r for r in right_records
                if current_time - r.timestamp <= self.window_duration.total_seconds()
            ]
            
            # åŸ·è¡ŒJoin
            for left in left_records:
                for right in right_records:
                    results.append((left.data, right.data))
            
            # æ›´æ–°æµå­˜å„²
            if left_records:
                self.left_stream[key] = left_records
            if right_records:
                self.right_stream[key] = right_records
        
        return results
```

## 3. å¯¦æ™‚åˆ†æ

### 3.1 å¯¦æ™‚çµ±è¨ˆ

```python
class StreamStats:
    def __init__(self, window_size: int):
        self.window = WindowedProcessor[float, Dict[str, float]](window_size)
        self.stats: Dict[str, float] = {
            'count': 0,
            'sum': 0,
            'mean': 0,
            'min': float('inf'),
            'max': float('-inf')
        }
    
    def update(self, value: float):
        """æ›´æ–°çµ±è¨ˆä¿¡æ¯"""
        self.stats['count'] += 1
        self.stats['sum'] += value
        self.stats['mean'] = self.stats['sum'] / self.stats['count']
        self.stats['min'] = min(self.stats['min'], value)
        self.stats['max'] = max(self.stats['max'], value)
    
    async def compute_stats(self, values: List[float]) -> Dict[str, float]:
        """è¨ˆç®—çµ±è¨ˆä¿¡æ¯"""
        for value in values:
            self.update(value)
        return self.stats

class StreamAnalytics:
    def __init__(self, window_duration: timedelta):
        self.processor = TimeWindowedProcessor[float, Dict[str, float]](
            window_duration
        )
        self.stats = StreamStats(1000)
    
    async def process_metric(self, metric: StreamRecord[float]):
        """è™•ç†æŒ‡æ¨™æ•¸æ“š"""
        self.processor.buffer[datetime.now()] = [metric]
        return await self.processor.process_window(self.stats.compute_stats)
```

### 3.2 ç•°å¸¸æª¢æ¸¬

```python
import numpy as np
from scipy import stats

class AnomalyDetector:
    def __init__(self, window_size: int,
                 threshold: float = 3.0):
        self.window = WindowedProcessor[float, bool](window_size)
        self.threshold = threshold
        self.values = []
    
    def is_anomaly(self, value: float) -> bool:
        """æª¢æ¸¬ç•°å¸¸å€¼"""
        if len(self.values) < 2:
            return False
        
        z_score = abs(stats.zscore(self.values + [value])[-1])
        return z_score > self.threshold
    
    async def detect(self, values: List[float]) -> List[bool]:
        """æª¢æ¸¬ä¸€çµ„å€¼ä¸­çš„ç•°å¸¸"""
        self.values.extend(values)
        if len(self.values) > self.window.window_size:
            self.values = self.values[-self.window.window_size:]
        
        return [self.is_anomaly(v) for v in values]
```

## ç·´ç¿’é¡Œ ğŸƒ

1. å¯¦ç¾ä¸€å€‹æµè™•ç†ç®¡é“ã€‚
2. é–‹ç™¼ä¸€å€‹å¯¦æ™‚æ•¸æ“šåˆ†æç³»çµ±ã€‚
3. è¨­è¨ˆä¸€å€‹æµå¼ç•°å¸¸æª¢æ¸¬å™¨ã€‚
4. å¯¦ç¾è¤‡é›œçš„çª—å£æ“ä½œã€‚
5. å‰µå»ºä¸€å€‹æµå¼æ•¸æ“šå¯è¦–åŒ–å·¥å…·ã€‚

## å°çµ ğŸ“

- å­¸ç¿’äº†æµè™•ç†çš„åŸºæœ¬æ¦‚å¿µ
- æŒæ¡äº†çª—å£æ“ä½œçš„å¯¦ç¾
- ç†è§£äº†æµè½‰æ›æ“ä½œ
- å­¸æœƒäº†å¯¦æ™‚åˆ†ææ–¹æ³•
- äº†è§£äº†ç•°å¸¸æª¢æ¸¬æŠ€è¡“

## å»¶ä¼¸é–±è®€ ğŸ“š

1. Stream Processing Architectures
2. Real-time Analytics
3. Apache Flink Documentation
4. Time Series Analysis
5. Streaming Systems Design

[ä¸Šä¸€ç« ï¼šäº‹ä»¶é©…å‹•æ¶æ§‹](128_äº‹ä»¶é©…å‹•æ¶æ§‹.md) | [ä¸‹ä¸€ç« ï¼šç³»çµ±å¯è§€æ¸¬æ€§](130_ç³»çµ±å¯è§€æ¸¬æ€§.md) 