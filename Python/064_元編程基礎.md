[ä¸Šä¸€ç« ï¼šå‡½æ•¸å¼ç·¨ç¨‹](063_å‡½æ•¸å¼ç·¨ç¨‹.md) | [ä¸‹ä¸€ç« ï¼šå…ƒç·¨ç¨‹é€²éš](065_å…ƒç·¨ç¨‹é€²éš.md)

# Python å…ƒç·¨ç¨‹åŸºç¤ ğŸ”„

## å…ƒç·¨ç¨‹æ¦‚è¿°

å…ƒç·¨ç¨‹æ˜¯ä¸€ç¨®ç·¨ç¨‹æŠ€è¡“ï¼Œå®ƒä½¿ç¨‹åºèƒ½å¤ å°‡å…¶ä»–ç¨‹åºä½œç‚ºæ•¸æ“šä¾†è™•ç†ã€‚æœ¬ç« å°‡ä»‹ç´¹Pythonä¸­çš„å…ƒç·¨ç¨‹åŸºç¤æ¦‚å¿µå’ŒæŠ€è¡“ã€‚

## é¡è£é£¾å™¨

### 1. åŸºæœ¬é¡è£é£¾å™¨

```python
from functools import wraps
from typing import Type, Callable, Any

def singleton(cls: Type) -> Type:
    """å°‡é¡è½‰æ›ç‚ºå–®ä¾‹æ¨¡å¼çš„è£é£¾å™¨"""
    instances = {}
    
    @wraps(cls)
    def get_instance(*args, **kwargs) -> Any:
        if cls not in instances:
            instances[cls] = cls(*args, **kwargs)
        return instances[cls]
    
    return get_instance

@singleton
class Configuration:
    def __init__(self):
        self.settings = {}
    
    def set(self, key: str, value: Any):
        self.settings[key] = value
    
    def get(self, key: str, default: Any = None) -> Any:
        return self.settings.get(key, default)

# æ¸¬è©¦
config1 = Configuration()
config2 = Configuration()
print(config1 is config2)  # True
```

### 2. åƒæ•¸åŒ–é¡è£é£¾å™¨

```python
from typing import Type, Callable, Dict, Any

def validate_attributes(**validators: Callable) -> Callable[[Type], Type]:
    """ç‚ºé¡çš„å±¬æ€§æ·»åŠ é©—è­‰çš„è£é£¾å™¨"""
    def decorator(cls: Type) -> Type:
        original_init = cls.__init__
        
        def new_init(self, *args, **kwargs):
            original_init(self, *args, **kwargs)
            for key, validator in validators.items():
                if hasattr(self, key):
                    value = getattr(self, key)
                    if not validator(value):
                        raise ValueError(
                            f"Invalid value for {key}: {value}"
                        )
        
        cls.__init__ = new_init
        return cls
    
    return decorator

# é©—è­‰å‡½æ•¸
def is_positive(x: float) -> bool:
    return x > 0

def is_valid_name(x: str) -> bool:
    return isinstance(x, str) and len(x) >= 2

@validate_attributes(age=is_positive, name=is_valid_name)
class Person:
    def __init__(self, name: str, age: int):
        self.name = name
        self.age = age

# æ¸¬è©¦
try:
    person = Person("John", 30)  # æ­£å¸¸
    print(f"Created person: {person.name}, {person.age}")
    
    invalid_person = Person("", -5)  # å°‡å¼•ç™¼ç•°å¸¸
except ValueError as e:
    print(f"Validation error: {e}")
```

## å…ƒé¡

### 1. åŸºæœ¬å…ƒé¡

```python
class MetaLogger(type):
    def __new__(mcs, name, bases, namespace):
        # åœ¨å‰µå»ºé¡ä¹‹å‰æ·»åŠ æ—¥èªŒåŠŸèƒ½
        print(f"Creating class: {name}")
        
        # ç‚ºæ‰€æœ‰æ–¹æ³•æ·»åŠ æ—¥èªŒ
        for key, value in namespace.items():
            if callable(value) and not key.startswith('__'):
                namespace[key] = mcs.log_call(value)
        
        return super().__new__(mcs, name, bases, namespace)
    
    @staticmethod
    def log_call(func):
        @wraps(func)
        def wrapper(*args, **kwargs):
            print(f"Calling: {func.__name__}")
            result = func(*args, **kwargs)
            print(f"Finished: {func.__name__}")
            return result
        return wrapper

class MyClass(metaclass=MetaLogger):
    def hello(self):
        print("Hello, World!")
    
    def calculate(self, x, y):
        return x + y

# æ¸¬è©¦
obj = MyClass()
obj.hello()
result = obj.calculate(3, 4)
print(f"Result: {result}")
```

### 2. å±¬æ€§æè¿°ç¬¦

```python
from typing import Any, Optional

class Validator:
    """å±¬æ€§é©—è­‰æè¿°ç¬¦åŸºé¡"""
    def __init__(self):
        self.name = None
    
    def __set_name__(self, owner, name):
        self.name = name
    
    def __get__(self, instance, owner):
        if instance is None:
            return self
        return instance.__dict__.get(self.name)
    
    def __set__(self, instance, value):
        self.validate(value)
        instance.__dict__[self.name] = value
    
    def validate(self, value):
        pass

class Integer(Validator):
    def __init__(self, min_value: Optional[int] = None,
                 max_value: Optional[int] = None):
        super().__init__()
        self.min_value = min_value
        self.max_value = max_value
    
    def validate(self, value):
        if not isinstance(value, int):
            raise TypeError(f"{self.name} must be an integer")
        if self.min_value is not None and value < self.min_value:
            raise ValueError(
                f"{self.name} must be >= {self.min_value}"
            )
        if self.max_value is not None and value > self.max_value:
            raise ValueError(
                f"{self.name} must be <= {self.max_value}"
            )

class String(Validator):
    def __init__(self, min_length: int = 0,
                 max_length: Optional[int] = None):
        super().__init__()
        self.min_length = min_length
        self.max_length = max_length
    
    def validate(self, value):
        if not isinstance(value, str):
            raise TypeError(f"{self.name} must be a string")
        if len(value) < self.min_length:
            raise ValueError(
                f"{self.name} must be at least {self.min_length} characters"
            )
        if self.max_length and len(value) > self.max_length:
            raise ValueError(
                f"{self.name} must be at most {self.max_length} characters"
            )

# ä½¿ç”¨æè¿°ç¬¦
class Person:
    name = String(min_length=2, max_length=50)
    age = Integer(min_value=0, max_value=150)
    
    def __init__(self, name: str, age: int):
        self.name = name
        self.age = age
    
    def __str__(self):
        return f"Person(name={self.name}, age={self.age})"

# æ¸¬è©¦
try:
    person = Person("John", 30)
    print(person)
    
    # é€™äº›å°‡å¼•ç™¼ç•°å¸¸
    person.age = -1  # ValueError
    person.name = ""  # ValueError
except (TypeError, ValueError) as e:
    print(f"Validation error: {e}")
```

## å‹•æ…‹ä»£ç¢¼ç”Ÿæˆ

### 1. exec å’Œ eval

```python
def create_dynamic_class(class_name: str,
                        attributes: Dict[str, Any]) -> Type:
    """å‹•æ…‹å‰µå»ºä¸€å€‹å…·æœ‰æŒ‡å®šå±¬æ€§çš„é¡"""
    # å‰µå»ºé¡å®šç¾©ä»£ç¢¼
    class_def = f"class {class_name}:\n"
    class_def += "    def __init__(self):\n"
    
    # æ·»åŠ å±¬æ€§
    for name, value in attributes.items():
        class_def += f"        self.{name} = {repr(value)}\n"
    
    # å‰µå»ºå‘½åç©ºé–“ä¸¦åŸ·è¡Œä»£ç¢¼
    namespace = {}
    exec(class_def, namespace)
    return namespace[class_name]

# æ¸¬è©¦
attributes = {
    'name': 'Dynamic',
    'value': 42,
    'items': [1, 2, 3]
}

DynamicClass = create_dynamic_class('DynamicClass', attributes)
instance = DynamicClass()
print(instance.name)
print(instance.value)
print(instance.items)
```

### 2. type å‹•æ…‹å‰µå»º

```python
def method_factory(name: str) -> Callable:
    """å‰µå»ºä¸€å€‹å‹•æ…‹æ–¹æ³•"""
    def method(self):
        return f"Hello from {name}"
    return method

def create_dynamic_type(name: str,
                       attributes: Dict[str, Any],
                       methods: Dict[str, Callable]) -> Type:
    """ä½¿ç”¨typeå‹•æ…‹å‰µå»ºé¡"""
    # åˆä½µå±¬æ€§å’Œæ–¹æ³•
    namespace = {}
    
    # æ·»åŠ __init__æ–¹æ³•
    def __init__(self):
        for key, value in attributes.items():
            setattr(self, key, value)
    namespace['__init__'] = __init__
    
    # æ·»åŠ å…¶ä»–æ–¹æ³•
    namespace.update(methods)
    
    # å‰µå»ºé¡
    return type(name, (), namespace)

# æ¸¬è©¦
attributes = {'x': 1, 'y': 2}
methods = {
    'greet': method_factory('DynamicType'),
    'get_sum': lambda self: self.x + self.y
}

DynamicType = create_dynamic_type('DynamicType', attributes, methods)
instance = DynamicType()
print(instance.greet())
print(instance.get_sum())
```

## å¯¦æˆ°ç¤ºä¾‹

### 1. ORMæ¡†æ¶åŸºç¤

```python
from typing import Dict, Type, Any
import sqlite3

class Field:
    def __init__(self, field_type: Type, required: bool = True):
        self.field_type = field_type
        self.required = required

class ModelMeta(type):
    def __new__(mcs, name, bases, namespace):
        if name == 'Model':
            return super().__new__(mcs, name, bases, namespace)
        
        # æ”¶é›†å­—æ®µä¿¡æ¯
        fields = {}
        for key, value in namespace.items():
            if isinstance(value, Field):
                fields[key] = value
        
        namespace['_fields'] = fields
        return super().__new__(mcs, name, bases, namespace)

class Model(metaclass=ModelMeta):
    def __init__(self, **kwargs):
        for name, field in self._fields.items():
            if name not in kwargs and field.required:
                raise ValueError(f"Field {name} is required")
            value = kwargs.get(name)
            if value is not None and not isinstance(value, field.field_type):
                raise TypeError(f"Field {name} must be of type {field.field_type}")
            setattr(self, name, value)
    
    @classmethod
    def create_table(cls, connection: sqlite3.Connection):
        fields = []
        for name, field in cls._fields.items():
            field_type = 'TEXT'
            if field.field_type == int:
                field_type = 'INTEGER'
            elif field.field_type == float:
                field_type = 'REAL'
            
            null_str = '' if field.required else 'NULL'
            fields.append(f"{name} {field_type} {null_str}")
        
        query = f"CREATE TABLE IF NOT EXISTS {cls.__name__} "
        query += f"({', '.join(fields)})"
        
        connection.execute(query)
        connection.commit()
    
    def save(self, connection: sqlite3.Connection):
        fields = []
        values = []
        
        for name, field in self._fields.items():
            value = getattr(self, name, None)
            if value is not None:
                fields.append(name)
                values.append(value)
        
        placeholders = ', '.join(['?' for _ in values])
        query = f"INSERT INTO {self.__class__.__name__} "
        query += f"({', '.join(fields)}) VALUES ({placeholders})"
        
        connection.execute(query, values)
        connection.commit()

# ä½¿ç”¨ç¤ºä¾‹
class User(Model):
    name = Field(str)
    age = Field(int)
    email = Field(str, required=False)

# æ¸¬è©¦
conn = sqlite3.connect(':memory:')
User.create_table(conn)

user = User(name="John", age=30, email="john@example.com")
user.save(conn)

# æŸ¥è©¢æ•¸æ“š
cursor = conn.execute("SELECT * FROM User")
print(cursor.fetchall())
```

### 2. é…ç½®ç®¡ç†å™¨

```python
from typing import Any, Dict
import json
from pathlib import Path

class ConfigMeta(type):
    _instances: Dict[str, Any] = {}
    
    def __call__(cls, config_path: str = None):
        if config_path is None:
            config_path = 'default'
        
        if config_path not in cls._instances:
            cls._instances[config_path] = super().__call__(config_path)
        return cls._instances[config_path]

class Config(metaclass=ConfigMeta):
    def __init__(self, config_path: str):
        self._config_path = Path(config_path)
        self._data = {}
        self.load()
    
    def load(self):
        """å¾æ–‡ä»¶åŠ è¼‰é…ç½®"""
        if self._config_path.exists():
            with open(self._config_path, 'r') as f:
                self._data = json.load(f)
    
    def save(self):
        """ä¿å­˜é…ç½®åˆ°æ–‡ä»¶"""
        with open(self._config_path, 'w') as f:
            json.dump(self._data, f, indent=2)
    
    def __getattr__(self, name: str) -> Any:
        """å…è¨±é€šéå±¬æ€§è¨ªå•é…ç½®é …"""
        if name not in self._data:
            raise AttributeError(f"No config item named {name}")
        return self._data[name]
    
    def __setattr__(self, name: str, value: Any):
        """å…è¨±é€šéå±¬æ€§è¨­ç½®é…ç½®é …"""
        if name.startswith('_'):
            super().__setattr__(name, value)
        else:
            self._data[name] = value
    
    def update(self, **kwargs):
        """æ‰¹é‡æ›´æ–°é…ç½®"""
        self._data.update(kwargs)
        self.save()

# ä½¿ç”¨ç¤ºä¾‹
def main():
    # å‰µå»ºé…ç½®æ–‡ä»¶
    config_data = {
        "database_url": "sqlite:///app.db",
        "debug": True,
        "api_key": "secret123"
    }
    
    with open('config.json', 'w') as f:
        json.dump(config_data, f)
    
    # ä½¿ç”¨é…ç½®
    config = Config('config.json')
    print(f"Debug mode: {config.debug}")
    print(f"Database URL: {config.database_url}")
    
    # æ›´æ–°é…ç½®
    config.update(debug=False, api_key="new_secret")
    
    # é©—è­‰å–®ä¾‹è¡Œç‚º
    config2 = Config('config.json')
    print(config is config2)  # True

if __name__ == '__main__':
    main()
```

## ç·´ç¿’é¡Œ

1. **è‡ªå®šç¾©ORM**
   å¯¦ç¾ä¸€å€‹ç°¡å–®çš„ORMç³»çµ±ï¼š
   - æ”¯æŒå¤šç¨®å­—æ®µé¡å‹
   - å¯¦ç¾åŸºæœ¬çš„CRUDæ“ä½œ
   - æ”¯æŒé—œä¿‚æ˜ å°„
   - å¯¦ç¾æŸ¥è©¢æ§‹å»ºå™¨

2. **APIè£é£¾å™¨æ¡†æ¶**
   é–‹ç™¼ä¸€å€‹APIè£é£¾å™¨æ¡†æ¶ï¼š
   - è·¯ç”±è¨»å†Š
   - åƒæ•¸é©—è­‰
   - éŸ¿æ‡‰æ ¼å¼åŒ–
   - éŒ¯èª¤è™•ç†

3. **é…ç½®ç®¡ç†ç³»çµ±**
   å‰µå»ºä¸€å€‹é«˜ç´šé…ç½®ç³»çµ±ï¼š
   - å¤šæ ¼å¼æ”¯æŒ
   - ç’°å¢ƒè®Šé‡é›†æˆ
   - é…ç½®ç¹¼æ‰¿
   - å‹•æ…‹é‡è¼‰

## å°æé†’ ğŸ’¡

1. å…ƒç·¨ç¨‹ä½¿ç”¨
   - è¬¹æ…ä½¿ç”¨å…ƒç·¨ç¨‹
   - ä¿æŒä»£ç¢¼å¯è®€æ€§
   - æä¾›å……åˆ†æ–‡æª”
   - è€ƒæ…®ç¶­è­·æˆæœ¬

2. æ€§èƒ½å½±éŸ¿
   - æ³¨æ„é‹è¡Œæ™‚é–‹éŠ·
   - åˆç†ä½¿ç”¨ç·©å­˜
   - é¿å…éåº¦å‹•æ…‹
   - æ¬Šè¡¡éˆæ´»æ€§

3. ä»£ç¢¼çµ„ç¹”
   - æ¨¡å¡ŠåŒ–è¨­è¨ˆ
   - æ¸…æ™°çš„æ¥å£
   - å®Œæ•´çš„æ¸¬è©¦
   - ç•°å¸¸è™•ç†

4. æœ€ä½³å¯¦è¸
   - éµå¾ªPythoné¢¨æ ¼
   - é©åº¦ä½¿ç”¨
   - æ³¨é‡å¯¦ç”¨æ€§
   - è€ƒæ…®æ›¿ä»£æ–¹æ¡ˆ

[ä¸Šä¸€ç« ï¼šå‡½æ•¸å¼ç·¨ç¨‹](063_å‡½æ•¸å¼ç·¨ç¨‹.md) | [ä¸‹ä¸€ç« ï¼šå…ƒç·¨ç¨‹é€²éš](065_å…ƒç·¨ç¨‹é€²éš.md) 