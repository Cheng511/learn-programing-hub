[ä¸Šä¸€ç« ï¼šè»Ÿä»¶æ¸¬è©¦åŸºç¤](078_è»Ÿä»¶æ¸¬è©¦åŸºç¤.md) | [ä¸‹ä¸€ç« ï¼šæ€§èƒ½å„ªåŒ–åŸºç¤](080_æ€§èƒ½å„ªåŒ–åŸºç¤.md)

# Python è»Ÿä»¶æ¸¬è©¦é€²éš ğŸ§ª

## æ¸¬è©¦è¦†è“‹ç‡

### 1. ä»£ç¢¼è¦†è“‹ç‡åˆ†æå™¨

```python
import ast
import sys
import os
from typing import Dict, List, Set, Tuple
import traceback

class CoverageAnalyzer:
    def __init__(self):
        """åˆå§‹åŒ–è¦†è“‹ç‡åˆ†æå™¨"""
        self.coverage_data: Dict[str, Dict[str, Set[int]]] = {}
        self.current_file: str = None
        self.current_line: int = 0
    
    def start_file(self, filename: str):
        """é–‹å§‹åˆ†ææ–‡ä»¶"""
        self.current_file = filename
        self.current_line = 0
        self.coverage_data[filename] = {
            'lines': set(),
            'branches': set(),
            'functions': set()
        }
    
    def analyze_file(self, filename: str) -> Dict[str, float]:
        """åˆ†ææ–‡ä»¶è¦†è“‹ç‡"""
        try:
            with open(filename, 'r', encoding='utf-8') as f:
                content = f.read()
            
            tree = ast.parse(content)
            self.start_file(filename)
            
            # åˆ†æä»£ç¢¼
            self._analyze_node(tree)
            
            # è¨ˆç®—è¦†è“‹ç‡
            return self._calculate_coverage(filename)
        
        except Exception as e:
            print(f"Error analyzing {filename}: {e}")
            return {}
    
    def _analyze_node(self, node: ast.AST):
        """åˆ†æASTç¯€é»"""
        if isinstance(node, ast.FunctionDef):
            self.coverage_data[self.current_file]['functions'].add(node.lineno)
        
        elif isinstance(node, ast.If):
            self.coverage_data[self.current_file]['branches'].add(node.lineno)
            for child in ast.walk(node):
                if isinstance(child, ast.If):
                    self.coverage_data[self.current_file]['branches'].add(child.lineno)
        
        elif isinstance(node, ast.While):
            self.coverage_data[self.current_file]['branches'].add(node.lineno)
        
        elif isinstance(node, ast.For):
            self.coverage_data[self.current_file]['branches'].add(node.lineno)
        
        elif isinstance(node, ast.Try):
            self.coverage_data[self.current_file]['branches'].add(node.lineno)
        
        # éæ­¸åˆ†æå­ç¯€é»
        for child in ast.iter_child_nodes(node):
            self._analyze_node(child)
    
    def _calculate_coverage(self, filename: str) -> Dict[str, float]:
        """è¨ˆç®—è¦†è“‹ç‡"""
        if filename not in self.coverage_data:
            return {}
        
        data = self.coverage_data[filename]
        total_lines = sum(1 for line in open(filename, 'r', encoding='utf-8'))
        
        return {
            'line_coverage': len(data['lines']) / total_lines if total_lines > 0 else 0,
            'branch_coverage': len(data['branches']) / total_lines if total_lines > 0 else 0,
            'function_coverage': len(data['functions']) / total_lines if total_lines > 0 else 0
        }
    
    def generate_report(self, output_file: str = None):
        """ç”Ÿæˆè¦†è“‹ç‡å ±å‘Š"""
        report = []
        report.append("Coverage Report")
        report.append("=" * 50)
        
        for filename, data in self.coverage_data.items():
            coverage = self._calculate_coverage(filename)
            report.append(f"\nFile: {filename}")
            report.append(f"Line Coverage: {coverage['line_coverage']:.2%}")
            report.append(f"Branch Coverage: {coverage['branch_coverage']:.2%}")
            report.append(f"Function Coverage: {coverage['function_coverage']:.2%}")
        
        report_text = "\n".join(report)
        
        if output_file:
            with open(output_file, 'w', encoding='utf-8') as f:
                f.write(report_text)
        else:
            print(report_text)

# ä½¿ç”¨ç¤ºä¾‹
def main():
    analyzer = CoverageAnalyzer()
    
    # åˆ†ææ–‡ä»¶
    coverage = analyzer.analyze_file("test_file.py")
    print(f"Coverage: {coverage}")
    
    # ç”Ÿæˆå ±å‘Š
    analyzer.generate_report("coverage_report.txt")

if __name__ == '__main__':
    main()
```

### 2. æ¸¬è©¦æ•¸æ“šç”Ÿæˆå™¨

```python
import random
import string
from typing import List, Dict, Any, Type, Union
import datetime
import uuid

class TestDataGenerator:
    def __init__(self):
        """åˆå§‹åŒ–æ¸¬è©¦æ•¸æ“šç”Ÿæˆå™¨"""
        self.generators = {
            str: self._generate_string,
            int: self._generate_integer,
            float: self._generate_float,
            bool: self._generate_boolean,
            list: self._generate_list,
            dict: self._generate_dict,
            datetime.datetime: self._generate_datetime,
            uuid.UUID: self._generate_uuid
        }
    
    def generate(self, type_: Type, **kwargs) -> Any:
        """ç”Ÿæˆæ¸¬è©¦æ•¸æ“š"""
        if type_ in self.generators:
            return self.generators[type_](**kwargs)
        else:
            raise ValueError(f"Unsupported type: {type_}")
    
    def _generate_string(self, min_length: int = 1, max_length: int = 10) -> str:
        """ç”Ÿæˆå­—ç¬¦ä¸²"""
        length = random.randint(min_length, max_length)
        return ''.join(random.choices(string.ascii_letters + string.digits, k=length))
    
    def _generate_integer(self, min_value: int = -100, max_value: int = 100) -> int:
        """ç”Ÿæˆæ•´æ•¸"""
        return random.randint(min_value, max_value)
    
    def _generate_float(self, min_value: float = -100.0, max_value: float = 100.0) -> float:
        """ç”Ÿæˆæµ®é»æ•¸"""
        return random.uniform(min_value, max_value)
    
    def _generate_boolean(self) -> bool:
        """ç”Ÿæˆå¸ƒçˆ¾å€¼"""
        return random.choice([True, False])
    
    def _generate_list(self, item_type: Type, min_length: int = 1, max_length: int = 5, **kwargs) -> List:
        """ç”Ÿæˆåˆ—è¡¨"""
        length = random.randint(min_length, max_length)
        return [self.generate(item_type, **kwargs) for _ in range(length)]
    
    def _generate_dict(self, key_type: Type, value_type: Type, min_items: int = 1, max_items: int = 5, **kwargs) -> Dict:
        """ç”Ÿæˆå­—å…¸"""
        items = random.randint(min_items, max_items)
        return {
            self.generate(key_type, **kwargs): self.generate(value_type, **kwargs)
            for _ in range(items)
        }
    
    def _generate_datetime(self, start_date: datetime.datetime = None, end_date: datetime.datetime = None) -> datetime.datetime:
        """ç”Ÿæˆæ—¥æœŸæ™‚é–“"""
        if start_date is None:
            start_date = datetime.datetime(2000, 1, 1)
        if end_date is None:
            end_date = datetime.datetime.now()
        
        delta = end_date - start_date
        random_days = random.randint(0, delta.days)
        random_seconds = random.randint(0, 86400)
        
        return start_date + datetime.timedelta(days=random_days, seconds=random_seconds)
    
    def _generate_uuid(self) -> uuid.UUID:
        """ç”ŸæˆUUID"""
        return uuid.uuid4()
    
    def generate_test_cases(self, func: callable, num_cases: int = 10) -> List[Dict[str, Any]]:
        """ç”Ÿæˆæ¸¬è©¦ç”¨ä¾‹"""
        import inspect
        import typing
        
        # ç²å–å‡½æ•¸åƒæ•¸ä¿¡æ¯
        sig = inspect.signature(func)
        test_cases = []
        
        for _ in range(num_cases):
            args = {}
            for param_name, param in sig.parameters.items():
                if param.annotation != inspect.Parameter.empty:
                    # ä½¿ç”¨é¡å‹è¨»è§£ç”Ÿæˆæ•¸æ“š
                    args[param_name] = self.generate(param.annotation)
                else:
                    # é»˜èªç”Ÿæˆå­—ç¬¦ä¸²
                    args[param_name] = self._generate_string()
            
            test_cases.append(args)
        
        return test_cases

# ä½¿ç”¨ç¤ºä¾‹
def example_function(name: str, age: int, scores: List[float]) -> Dict[str, Any]:
    """ç¤ºä¾‹å‡½æ•¸"""
    return {
        'name': name,
        'age': age,
        'scores': scores,
        'average': sum(scores) / len(scores) if scores else 0
    }

def main():
    generator = TestDataGenerator()
    
    # ç”ŸæˆåŸºæœ¬é¡å‹æ•¸æ“š
    print("Basic types:")
    print(f"String: {generator.generate(str)}")
    print(f"Integer: {generator.generate(int)}")
    print(f"Float: {generator.generate(float)}")
    print(f"Boolean: {generator.generate(bool)}")
    
    # ç”Ÿæˆè¤‡é›œé¡å‹æ•¸æ“š
    print("\nComplex types:")
    print(f"List: {generator.generate(list, item_type=int)}")
    print(f"Dict: {generator.generate(dict, key_type=str, value_type=int)}")
    print(f"Datetime: {generator.generate(datetime.datetime)}")
    print(f"UUID: {generator.generate(uuid.UUID)}")
    
    # ç”Ÿæˆæ¸¬è©¦ç”¨ä¾‹
    print("\nTest cases:")
    test_cases = generator.generate_test_cases(example_function, num_cases=3)
    for i, case in enumerate(test_cases, 1):
        print(f"Case {i}:")
        print(f"  Input: {case}")
        print(f"  Output: {example_function(**case)}")

if __name__ == '__main__':
    main()
```

## ç·´ç¿’é¡Œ

1. **è¦†è“‹ç‡åˆ†æå·¥å…·**
   é–‹ç™¼ä¸€å€‹è¦†è“‹ç‡åˆ†æå·¥å…·ï¼š
   - æ”¯æŒå¤šç¨®è¦†è“‹ç‡æŒ‡æ¨™
   - ç”ŸæˆHTMLå ±å‘Š
   - æ”¯æŒåˆ†æ”¯è¦†è“‹
   - æä¾›APIæ¥å£

2. **æ¸¬è©¦æ•¸æ“šç”Ÿæˆå™¨**
   å‰µå»ºä¸€å€‹æ¸¬è©¦æ•¸æ“šç”Ÿæˆå™¨ï¼š
   - æ”¯æŒè‡ªå®šç¾©é¡å‹
   - ç”Ÿæˆè¤‡é›œæ•¸æ“šçµæ§‹
   - æä¾›æ•¸æ“šé©—è­‰
   - æ”¯æŒæ•¸æ“šç´„æŸ

3. **æ¸¬è©¦æ¡†æ¶æ“´å±•**
   å¯¦ç¾ä¸€å€‹æ¸¬è©¦æ¡†æ¶æ“´å±•ï¼š
   - æ”¯æŒåƒæ•¸åŒ–æ¸¬è©¦
   - æä¾›æ¸¬è©¦è£é£¾å™¨
   - ç”Ÿæˆæ¸¬è©¦å ±å‘Š
   - ç®¡ç†æ¸¬è©¦æ•¸æ“š

## å°æé†’ ğŸ’¡

1. è¦†è“‹ç‡åˆ†æ
   - é¸æ“‡åˆé©æŒ‡æ¨™
   - åˆ†æä»£ç¢¼çµæ§‹
   - å„ªåŒ–æ¸¬è©¦ç”¨ä¾‹
   - å®šæœŸæ›´æ–°å ±å‘Š

2. æ•¸æ“šç”Ÿæˆ
   - è€ƒæ…®é‚Šç•Œæ¢ä»¶
   - ç”Ÿæˆå¤šæ¨£æ•¸æ“š
   - é©—è­‰æ•¸æ“šè³ªé‡
   - æ§åˆ¶æ•¸æ“šé‡

3. æ¸¬è©¦å„ªåŒ–
   - æé«˜åŸ·è¡Œæ•ˆç‡
   - æ¸›å°‘é‡è¤‡ä»£ç¢¼
   - ç¶­è­·æ¸¬è©¦æ•¸æ“š
   - è‡ªå‹•åŒ–æ¸¬è©¦

4. èª¿è©¦æŠ€å·§
   - åˆ†æå¤±æ•—åŸå› 
   - å„ªåŒ–æ¸¬è©¦ç”¨ä¾‹
   - æ”¹é€²æ¸¬è©¦æ•¸æ“š
   - å®Œå–„éŒ¯èª¤è™•ç†

[ä¸Šä¸€ç« ï¼šè»Ÿä»¶æ¸¬è©¦åŸºç¤](078_è»Ÿä»¶æ¸¬è©¦åŸºç¤.md) | [ä¸‹ä¸€ç« ï¼šæ€§èƒ½å„ªåŒ–åŸºç¤](080_æ€§èƒ½å„ªåŒ–åŸºç¤.md) 