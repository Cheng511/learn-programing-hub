[ä¸Šä¸€ç« ï¼šæƒ¡æ„è»Ÿä»¶åˆ†æé€²éš](075_æƒ¡æ„è»Ÿä»¶åˆ†æé€²éš.md) | [ä¸‹ä¸€ç« ï¼šé€†å‘å·¥ç¨‹é€²éš](077_é€†å‘å·¥ç¨‹é€²éš.md)

# Python é€†å‘å·¥ç¨‹åŸºç¤ ğŸ”

## åå½™ç·¨

### 1. åŸºæœ¬åå½™ç·¨å™¨

```python
import capstone
from typing import List, Dict, Optional
import struct

class BasicDisassembler:
    def __init__(self, arch: str = 'x86', mode: str = '32'):
        """åˆå§‹åŒ–åå½™ç·¨å™¨"""
        self.arch = arch
        self.mode = mode
        
        # å‰µå»ºCapstoneå¼•æ“
        if arch == 'x86':
            if mode == '32':
                self.cs = capstone.Cs(capstone.CS_ARCH_X86, capstone.CS_MODE_32)
            else:
                self.cs = capstone.Cs(capstone.CS_ARCH_X86, capstone.CS_MODE_64)
        elif arch == 'arm':
            if mode == '32':
                self.cs = capstone.Cs(capstone.CS_ARCH_ARM, capstone.CS_MODE_ARM)
            else:
                self.cs = capstone.Cs(capstone.CS_ARCH_ARM64, capstone.CS_MODE_ARM)
        else:
            raise ValueError(f"Unsupported architecture: {arch}")
        
        # é…ç½®åå½™ç·¨å™¨
        self.cs.detail = True
        self.cs.syntax = capstone.CS_OPT_SYNTAX_ATT
    
    def disassemble(self, code: bytes, address: int = 0x1000) -> List[Dict]:
        """åå½™ç·¨ä»£ç¢¼"""
        try:
            instructions = []
            for insn in self.cs.disasm(code, address):
                instructions.append({
                    'address': hex(insn.address),
                    'size': insn.size,
                    'mnemonic': insn.mnemonic,
                    'op_str': insn.op_str,
                    'groups': [group.name for group in insn.groups],
                    'regs_read': [reg.name for reg in insn.regs_read],
                    'regs_write': [reg.name for reg in insn.regs_write]
                })
            return instructions
        except Exception as e:
            print(f"Error disassembling code: {e}")
            return []
    
    def analyze_control_flow(self, instructions: List[Dict]) -> Dict:
        """åˆ†ææ§åˆ¶æµ"""
        try:
            control_flow = {
                'jumps': [],
                'calls': [],
                'returns': [],
                'conditional': []
            }
            
            for insn in instructions:
                if insn['mnemonic'].startswith('j'):
                    if insn['mnemonic'] == 'jmp':
                        control_flow['jumps'].append(insn)
                    else:
                        control_flow['conditional'].append(insn)
                elif insn['mnemonic'] == 'call':
                    control_flow['calls'].append(insn)
                elif insn['mnemonic'] == 'ret':
                    control_flow['returns'].append(insn)
            
            return control_flow
        except Exception as e:
            print(f"Error analyzing control flow: {e}")
            return {}
    
    def analyze_data_references(self, instructions: List[Dict]) -> Dict:
        """åˆ†ææ•¸æ“šå¼•ç”¨"""
        try:
            data_refs = {
                'memory_reads': [],
                'memory_writes': [],
                'immediate_values': []
            }
            
            for insn in instructions:
                # æª¢æŸ¥å…§å­˜è®€å–
                if any(group == 'CS_GRP_MEM' for group in insn['groups']):
                    if any(reg in insn['regs_read'] for reg in ['rax', 'rbx', 'rcx', 'rdx']):
                        data_refs['memory_reads'].append(insn)
                    else:
                        data_refs['memory_writes'].append(insn)
                
                # æª¢æŸ¥ç«‹å³æ•¸
                if 'immediate' in insn['op_str']:
                    data_refs['immediate_values'].append(insn)
            
            return data_refs
        except Exception as e:
            print(f"Error analyzing data references: {e}")
            return {}

# ä½¿ç”¨ç¤ºä¾‹
def main():
    # å‰µå»ºåå½™ç·¨å™¨
    disassembler = BasicDisassembler('x86', '64')
    
    # ç¤ºä¾‹ä»£ç¢¼
    code = bytes([
        0x55,                   # push rbp
        0x48, 0x89, 0xe5,       # mov rbp, rsp
        0x48, 0x83, 0xec, 0x20, # sub rsp, 0x20
        0x48, 0x8b, 0x05, 0x00, # mov rax, qword ptr [rip + 0x0]
        0x00, 0x00, 0x00,
        0x48, 0x89, 0x45, 0xf8, # mov qword ptr [rbp - 0x8], rax
        0x48, 0x8b, 0x45, 0xf8, # mov rax, qword ptr [rbp - 0x8]
        0x48, 0x83, 0xc4, 0x20, # add rsp, 0x20
        0x5d,                   # pop rbp
        0xc3                    # ret
    ])
    
    # åå½™ç·¨ä»£ç¢¼
    print("Disassembling code...")
    instructions = disassembler.disassemble(code)
    
    print("\nInstructions:")
    for insn in instructions:
        print(f"{insn['address']}: {insn['mnemonic']} {insn['op_str']}")
    
    # åˆ†ææ§åˆ¶æµ
    print("\nAnalyzing control flow...")
    control_flow = disassembler.analyze_control_flow(instructions)
    
    print("\nJumps:")
    for jump in control_flow['jumps']:
        print(f"{jump['address']}: {jump['mnemonic']} {jump['op_str']}")
    
    print("\nCalls:")
    for call in control_flow['calls']:
        print(f"{call['address']}: {call['mnemonic']} {call['op_str']}")
    
    print("\nReturns:")
    for ret in control_flow['returns']:
        print(f"{ret['address']}: {ret['mnemonic']} {ret['op_str']}")
    
    # åˆ†ææ•¸æ“šå¼•ç”¨
    print("\nAnalyzing data references...")
    data_refs = disassembler.analyze_data_references(instructions)
    
    print("\nMemory reads:")
    for read in data_refs['memory_reads']:
        print(f"{read['address']}: {read['mnemonic']} {read['op_str']}")
    
    print("\nMemory writes:")
    for write in data_refs['memory_writes']:
        print(f"{write['address']}: {write['mnemonic']} {write['op_str']}")

if __name__ == '__main__':
    main()
```

### 2. å‡½æ•¸åˆ†æå™¨

```python
import capstone
from typing import List, Dict, Optional
import struct

class FunctionAnalyzer:
    def __init__(self, arch: str = 'x86', mode: str = '32'):
        """åˆå§‹åŒ–å‡½æ•¸åˆ†æå™¨"""
        self.arch = arch
        self.mode = mode
        
        # å‰µå»ºCapstoneå¼•æ“
        if arch == 'x86':
            if mode == '32':
                self.cs = capstone.Cs(capstone.CS_ARCH_X86, capstone.CS_MODE_32)
            else:
                self.cs = capstone.Cs(capstone.CS_ARCH_X86, capstone.CS_MODE_64)
        elif arch == 'arm':
            if mode == '32':
                self.cs = capstone.Cs(capstone.CS_ARCH_ARM, capstone.CS_MODE_ARM)
            else:
                self.cs = capstone.Cs(capstone.CS_ARCH_ARM64, capstone.CS_MODE_ARM)
        else:
            raise ValueError(f"Unsupported architecture: {arch}")
        
        # é…ç½®åå½™ç·¨å™¨
        self.cs.detail = True
        self.cs.syntax = capstone.CS_OPT_SYNTAX_ATT
    
    def find_functions(self, code: bytes, address: int = 0x1000) -> List[Dict]:
        """æŸ¥æ‰¾å‡½æ•¸"""
        try:
            functions = []
            current_function = None
            
            for insn in self.cs.disasm(code, address):
                # æª¢æŸ¥å‡½æ•¸é–‹å§‹
                if insn.mnemonic in ['push', 'mov'] and insn.op_str.endswith('rbp'):
                    if current_function is None:
                        current_function = {
                            'start_address': hex(insn.address),
                            'instructions': [],
                            'size': 0
                        }
                
                # æª¢æŸ¥å‡½æ•¸çµæŸ
                elif insn.mnemonic == 'ret':
                    if current_function is not None:
                        current_function['instructions'].append({
                            'address': hex(insn.address),
                            'mnemonic': insn.mnemonic,
                            'op_str': insn.op_str
                        })
                        current_function['size'] = insn.address - int(current_function['start_address'], 16)
                        functions.append(current_function)
                        current_function = None
                
                # æ·»åŠ æŒ‡ä»¤
                elif current_function is not None:
                    current_function['instructions'].append({
                        'address': hex(insn.address),
                        'mnemonic': insn.mnemonic,
                        'op_str': insn.op_str
                    })
            
            return functions
        except Exception as e:
            print(f"Error finding functions: {e}")
            return []
    
    def analyze_function(self, function: Dict) -> Dict:
        """åˆ†æå‡½æ•¸"""
        try:
            analysis = {
                'stack_frame': {
                    'size': 0,
                    'variables': []
                },
                'calls': [],
                'jumps': [],
                'data_refs': [],
                'registers': {
                    'read': set(),
                    'written': set()
                }
            }
            
            # åˆ†ææŒ‡ä»¤
            for insn in function['instructions']:
                # åˆ†ææ£§å¹€
                if insn['mnemonic'] == 'sub' and 'rsp' in insn['op_str']:
                    try:
                        analysis['stack_frame']['size'] = int(insn['op_str'].split(',')[1], 16)
                    except:
                        pass
                
                # åˆ†æèª¿ç”¨
                elif insn['mnemonic'] == 'call':
                    analysis['calls'].append(insn)
                
                # åˆ†æè·³è½‰
                elif insn['mnemonic'].startswith('j'):
                    analysis['jumps'].append(insn)
                
                # åˆ†ææ•¸æ“šå¼•ç”¨
                elif any(reg in insn['op_str'] for reg in ['[', ']']):
                    analysis['data_refs'].append(insn)
                
                # åˆ†æå¯„å­˜å™¨ä½¿ç”¨
                for reg in ['rax', 'rbx', 'rcx', 'rdx', 'rsi', 'rdi', 'r8', 'r9']:
                    if reg in insn['op_str']:
                        if insn['mnemonic'] in ['mov', 'add', 'sub', 'mul', 'div']:
                            analysis['registers']['written'].add(reg)
                        else:
                            analysis['registers']['read'].add(reg)
            
            return analysis
        except Exception as e:
            print(f"Error analyzing function: {e}")
            return {}
    
    def decompile_function(self, function: Dict, analysis: Dict) -> str:
        """åç·¨è­¯å‡½æ•¸"""
        try:
            decompiled = []
            
            # å‡½æ•¸é ­
            decompiled.append("def function():")
            
            # æ£§å¹€è¨­ç½®
            if analysis['stack_frame']['size'] > 0:
                decompiled.append(f"    # Allocate stack frame: {analysis['stack_frame']['size']} bytes")
            
            # æŒ‡ä»¤è½‰æ›
            for insn in function['instructions']:
                if insn['mnemonic'] == 'mov':
                    # ç°¡å–®çš„movæŒ‡ä»¤è½‰æ›
                    dest, src = insn['op_str'].split(',')
                    decompiled.append(f"    {dest.strip()} = {src.strip()}")
                elif insn['mnemonic'] == 'add':
                    dest, src = insn['op_str'].split(',')
                    decompiled.append(f"    {dest.strip()} += {src.strip()}")
                elif insn['mnemonic'] == 'sub':
                    dest, src = insn['op_str'].split(',')
                    decompiled.append(f"    {dest.strip()} -= {src.strip()}")
                elif insn['mnemonic'] == 'call':
                    decompiled.append(f"    # Call {insn['op_str']}")
                elif insn['mnemonic'] == 'ret':
                    decompiled.append("    return")
            
            return '\n'.join(decompiled)
        except Exception as e:
            print(f"Error decompiling function: {e}")
            return ""

# ä½¿ç”¨ç¤ºä¾‹
def main():
    # å‰µå»ºåˆ†æå™¨
    analyzer = FunctionAnalyzer('x86', '64')
    
    # ç¤ºä¾‹ä»£ç¢¼
    code = bytes([
        0x55,                   # push rbp
        0x48, 0x89, 0xe5,       # mov rbp, rsp
        0x48, 0x83, 0xec, 0x20, # sub rsp, 0x20
        0x48, 0x8b, 0x05, 0x00, # mov rax, qword ptr [rip + 0x0]
        0x00, 0x00, 0x00,
        0x48, 0x89, 0x45, 0xf8, # mov qword ptr [rbp - 0x8], rax
        0x48, 0x8b, 0x45, 0xf8, # mov rax, qword ptr [rbp - 0x8]
        0x48, 0x83, 0xc4, 0x20, # add rsp, 0x20
        0x5d,                   # pop rbp
        0xc3                    # ret
    ])
    
    # æŸ¥æ‰¾å‡½æ•¸
    print("Finding functions...")
    functions = analyzer.find_functions(code)
    
    print(f"\nFound {len(functions)} functions:")
    
    # åˆ†ææ¯å€‹å‡½æ•¸
    for i, function in enumerate(functions):
        print(f"\nFunction {i + 1}:")
        print(f"Start address: {function['start_address']}")
        print(f"Size: {function['size']} bytes")
        
        # åˆ†æå‡½æ•¸
        analysis = analyzer.analyze_function(function)
        
        print("\nStack frame:")
        print(f"Size: {analysis['stack_frame']['size']} bytes")
        
        print("\nCalls:")
        for call in analysis['calls']:
            print(f"  {call['address']}: {call['mnemonic']} {call['op_str']}")
        
        print("\nJumps:")
        for jump in analysis['jumps']:
            print(f"  {jump['address']}: {jump['mnemonic']} {jump['op_str']}")
        
        print("\nRegisters:")
        print("Read:", ', '.join(analysis['registers']['read']))
        print("Written:", ', '.join(analysis['registers']['written']))
        
        # åç·¨è­¯å‡½æ•¸
        print("\nDecompiled:")
        print(analyzer.decompile_function(function, analysis))

if __name__ == '__main__':
    main()
```

## ç·´ç¿’é¡Œ

1. **åå½™ç·¨å·¥å…·**
   é–‹ç™¼ä¸€å€‹åå½™ç·¨å·¥å…·ï¼š
   - æ”¯æŒå¤šç¨®æ¶æ§‹
   - åˆ†ææ§åˆ¶æµ
   - è­˜åˆ¥å‡½æ•¸
   - ç”Ÿæˆå ±å‘Š

2. **å‡½æ•¸åˆ†æå·¥å…·**
   å‰µå»ºä¸€å€‹å‡½æ•¸åˆ†æå·¥å…·ï¼š
   - åˆ†ææ£§å¹€
   - è¿½è¹¤æ•¸æ“šæµ
   - è­˜åˆ¥æ¨¡å¼
   - ç”Ÿæˆæ–‡æª”

3. **é€†å‘å·¥ç¨‹æ¡†æ¶**
   å¯¦ç¾ä¸€å€‹é€†å‘å·¥ç¨‹æ¡†æ¶ï¼š
   - æ”¯æŒå¤šç¨®æ ¼å¼
   - æä¾›åˆ†æAPI
   - ç”Ÿæˆåˆ†æå ±å‘Š
   - ç®¡ç†åˆ†æçµæœ

## å°æé†’ ğŸ’¡

1. å®‰å…¨è€ƒæ…®
   - ä½¿ç”¨éš”é›¢ç’°å¢ƒ
   - ä¿è­·åˆ†ææ•¸æ“š
   - é¿å…åŸ·è¡Œä»£ç¢¼
   - å®šæœŸæ›´æ–°å·¥å…·

2. æ€§èƒ½å„ªåŒ–
   - å„ªåŒ–å…§å­˜ä½¿ç”¨
   - ä½¿ç”¨ç·©å­˜æ©Ÿåˆ¶
   - æ§åˆ¶CPUä½¿ç”¨
   - ä¸¦è¡Œè™•ç†

3. å¯é æ€§
   - è™•ç†æ–‡ä»¶éŒ¯èª¤
   - é©—è­‰æ–‡ä»¶æ ¼å¼
   - è¨˜éŒ„åˆ†ææ—¥èªŒ
   - å‚™ä»½é‡è¦æ•¸æ“š

4. èª¿è©¦æŠ€å·§
   - ä½¿ç”¨èª¿è©¦å·¥å…·
   - åˆ†æéŒ¯èª¤ä¿¡æ¯
   - æ¨¡æ“¬é‹è¡Œç’°å¢ƒ
   - å£“åŠ›æ¸¬è©¦

[ä¸Šä¸€ç« ï¼šæƒ¡æ„è»Ÿä»¶åˆ†æé€²éš](075_æƒ¡æ„è»Ÿä»¶åˆ†æé€²éš.md) | [ä¸‹ä¸€ç« ï¼šé€†å‘å·¥ç¨‹é€²éš](077_é€†å‘å·¥ç¨‹é€²éš.md) 