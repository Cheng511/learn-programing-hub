[ä¸Šä¸€ç« ï¼šæ€§èƒ½å„ªåŒ–åŸºç¤](080_æ€§èƒ½å„ªåŒ–åŸºç¤.md) | [ä¸‹ä¸€ç« ï¼šä¸¦ç™¼ç·¨ç¨‹åŸºç¤](082_ä¸¦ç™¼ç·¨ç¨‹åŸºç¤.md)

# Python æ€§èƒ½å„ªåŒ–é€²éš ğŸš€

## ä¸¦ç™¼å„ªåŒ–

### 1. ç·šç¨‹æ± å„ªåŒ–å™¨

```python
import concurrent.futures
import threading
import queue
import time
from typing import List, Dict, Any, Callable, Optional
import sys
import os

class ThreadPoolOptimizer:
    def __init__(self, max_workers: int = None):
        """åˆå§‹åŒ–ç·šç¨‹æ± å„ªåŒ–å™¨"""
        self.max_workers = max_workers or (os.cpu_count() or 1) * 2
        self.executor = concurrent.futures.ThreadPoolExecutor(max_workers=self.max_workers)
        self.task_queue = queue.Queue()
        self.result_queue = queue.Queue()
        self.workers: List[threading.Thread] = []
        self.is_running = False
        self.results: Dict[str, Any] = {}
    
    def start(self):
        """å•Ÿå‹•ç·šç¨‹æ± """
        self.is_running = True
        for _ in range(self.max_workers):
            worker = threading.Thread(target=self._worker_loop)
            worker.daemon = True
            worker.start()
            self.workers.append(worker)
    
    def stop(self):
        """åœæ­¢ç·šç¨‹æ± """
        self.is_running = False
        for _ in range(self.max_workers):
            self.task_queue.put(None)
        
        for worker in self.workers:
            worker.join()
        
        self.executor.shutdown()
    
    def submit_task(self, task_id: str, func: Callable, *args, **kwargs):
        """æäº¤ä»»å‹™"""
        self.task_queue.put((task_id, func, args, kwargs))
    
    def _worker_loop(self):
        """å·¥ä½œç·šç¨‹å¾ªç’°"""
        while self.is_running:
            try:
                task = self.task_queue.get(timeout=1)
                if task is None:
                    break
                
                task_id, func, args, kwargs = task
                
                try:
                    # ä½¿ç”¨ç·šç¨‹æ± åŸ·è¡Œä»»å‹™
                    future = self.executor.submit(func, *args, **kwargs)
                    result = future.result()
                    
                    self.result_queue.put((task_id, result, None))
                
                except Exception as e:
                    self.result_queue.put((task_id, None, e))
                
                finally:
                    self.task_queue.task_done()
            
            except queue.Empty:
                continue
    
    def get_result(self, task_id: str, timeout: float = None) -> Any:
        """ç²å–ä»»å‹™çµæœ"""
        while True:
            try:
                result_task_id, result, error = self.result_queue.get(timeout=timeout)
                if result_task_id == task_id:
                    if error:
                        raise error
                    return result
                else:
                    self.result_queue.put((result_task_id, result, error))
            
            except queue.Empty:
                raise TimeoutError(f"Timeout waiting for task {task_id}")
    
    def map_tasks(self, func: Callable, items: List[Any], **kwargs) -> List[Any]:
        """ä¸¦è¡Œè™•ç†å¤šå€‹ä»»å‹™"""
        futures = []
        for item in items:
            future = self.executor.submit(func, item, **kwargs)
            futures.append(future)
        
        return [future.result() for future in concurrent.futures.as_completed(futures)]
    
    def batch_process(self, func: Callable, items: List[Any], batch_size: int = 10, **kwargs) -> List[Any]:
        """æ‰¹é‡è™•ç†ä»»å‹™"""
        results = []
        for i in range(0, len(items), batch_size):
            batch = items[i:i + batch_size]
            batch_results = self.map_tasks(func, batch, **kwargs)
            results.extend(batch_results)
        return results

# ä½¿ç”¨ç¤ºä¾‹
def process_item(item: int) -> int:
    """è™•ç†å–®å€‹é …ç›®"""
    time.sleep(0.1)  # æ¨¡æ“¬è™•ç†æ™‚é–“
    return item * item

def main():
    # å‰µå»ºå„ªåŒ–å™¨
    optimizer = ThreadPoolOptimizer(max_workers=4)
    
    try:
        # å•Ÿå‹•ç·šç¨‹æ± 
        optimizer.start()
        
        # æäº¤å–®å€‹ä»»å‹™
        print("Submitting single task:")
        optimizer.submit_task("task1", process_item, 5)
        result = optimizer.get_result("task1")
        print(f"Result: {result}")
        
        # ä¸¦è¡Œè™•ç†å¤šå€‹ä»»å‹™
        print("\nProcessing multiple tasks:")
        items = list(range(10))
        results = optimizer.map_tasks(process_item, items)
        print(f"Results: {results}")
        
        # æ‰¹é‡è™•ç†ä»»å‹™
        print("\nBatch processing tasks:")
        items = list(range(20))
        results = optimizer.batch_process(process_item, items, batch_size=5)
        print(f"Results: {results}")
    
    finally:
        # åœæ­¢ç·šç¨‹æ± 
        optimizer.stop()

if __name__ == '__main__':
    main()
```

### 2. é€²ç¨‹æ± å„ªåŒ–å™¨

```python
import multiprocessing
from multiprocessing import Pool, Process, Queue
import time
from typing import List, Dict, Any, Callable, Optional
import sys
import os

class ProcessPoolOptimizer:
    def __init__(self, num_processes: int = None):
        """åˆå§‹åŒ–é€²ç¨‹æ± å„ªåŒ–å™¨"""
        self.num_processes = num_processes or os.cpu_count() or 1
        self.pool = Pool(processes=self.num_processes)
        self.processes: List[Process] = []
        self.task_queue = Queue()
        self.result_queue = Queue()
        self.is_running = False
        self.results: Dict[str, Any] = {}
    
    def start(self):
        """å•Ÿå‹•é€²ç¨‹æ± """
        self.is_running = True
        for _ in range(self.num_processes):
            process = Process(target=self._worker_loop)
            process.daemon = True
            process.start()
            self.processes.append(process)
    
    def stop(self):
        """åœæ­¢é€²ç¨‹æ± """
        self.is_running = False
        for _ in range(self.num_processes):
            self.task_queue.put(None)
        
        for process in self.processes:
            process.join()
        
        self.pool.close()
        self.pool.join()
    
    def submit_task(self, task_id: str, func: Callable, *args, **kwargs):
        """æäº¤ä»»å‹™"""
        self.task_queue.put((task_id, func, args, kwargs))
    
    def _worker_loop(self):
        """å·¥ä½œé€²ç¨‹å¾ªç’°"""
        while self.is_running:
            try:
                task = self.task_queue.get(timeout=1)
                if task is None:
                    break
                
                task_id, func, args, kwargs = task
                
                try:
                    # ä½¿ç”¨é€²ç¨‹æ± åŸ·è¡Œä»»å‹™
                    result = self.pool.apply(func, args=args, kwds=kwargs)
                    self.result_queue.put((task_id, result, None))
                
                except Exception as e:
                    self.result_queue.put((task_id, None, e))
                
                finally:
                    self.task_queue.task_done()
            
            except queue.Empty:
                continue
    
    def get_result(self, task_id: str, timeout: float = None) -> Any:
        """ç²å–ä»»å‹™çµæœ"""
        while True:
            try:
                result_task_id, result, error = self.result_queue.get(timeout=timeout)
                if result_task_id == task_id:
                    if error:
                        raise error
                    return result
                else:
                    self.result_queue.put((result_task_id, result, error))
            
            except queue.Empty:
                raise TimeoutError(f"Timeout waiting for task {task_id}")
    
    def map_tasks(self, func: Callable, items: List[Any], **kwargs) -> List[Any]:
        """ä¸¦è¡Œè™•ç†å¤šå€‹ä»»å‹™"""
        return self.pool.map(func, items)
    
    def batch_process(self, func: Callable, items: List[Any], batch_size: int = 10, **kwargs) -> List[Any]:
        """æ‰¹é‡è™•ç†ä»»å‹™"""
        results = []
        for i in range(0, len(items), batch_size):
            batch = items[i:i + batch_size]
            batch_results = self.map_tasks(func, batch, **kwargs)
            results.extend(batch_results)
        return results
    
    def starmap_tasks(self, func: Callable, items: List[tuple], **kwargs) -> List[Any]:
        """ä¸¦è¡Œè™•ç†å¤šåƒæ•¸ä»»å‹™"""
        return self.pool.starmap(func, items)

# ä½¿ç”¨ç¤ºä¾‹
def process_item(item: int) -> int:
    """è™•ç†å–®å€‹é …ç›®"""
    time.sleep(0.1)  # æ¨¡æ“¬è™•ç†æ™‚é–“
    return item * item

def process_items(item1: int, item2: int) -> int:
    """è™•ç†å…©å€‹é …ç›®"""
    time.sleep(0.1)  # æ¨¡æ“¬è™•ç†æ™‚é–“
    return item1 + item2

def main():
    # å‰µå»ºå„ªåŒ–å™¨
    optimizer = ProcessPoolOptimizer(num_processes=4)
    
    try:
        # å•Ÿå‹•é€²ç¨‹æ± 
        optimizer.start()
        
        # æäº¤å–®å€‹ä»»å‹™
        print("Submitting single task:")
        optimizer.submit_task("task1", process_item, 5)
        result = optimizer.get_result("task1")
        print(f"Result: {result}")
        
        # ä¸¦è¡Œè™•ç†å¤šå€‹ä»»å‹™
        print("\nProcessing multiple tasks:")
        items = list(range(10))
        results = optimizer.map_tasks(process_item, items)
        print(f"Results: {results}")
        
        # æ‰¹é‡è™•ç†ä»»å‹™
        print("\nBatch processing tasks:")
        items = list(range(20))
        results = optimizer.batch_process(process_item, items, batch_size=5)
        print(f"Results: {results}")
        
        # è™•ç†å¤šåƒæ•¸ä»»å‹™
        print("\nProcessing multi-parameter tasks:")
        items = [(i, i+1) for i in range(5)]
        results = optimizer.starmap_tasks(process_items, items)
        print(f"Results: {results}")
    
    finally:
        # åœæ­¢é€²ç¨‹æ± 
        optimizer.stop()

if __name__ == '__main__':
    main()
```

## ç·´ç¿’é¡Œ

1. **ä¸¦ç™¼å„ªåŒ–å·¥å…·**
   é–‹ç™¼ä¸€å€‹ä¸¦ç™¼å„ªåŒ–å·¥å…·ï¼š
   - æ”¯æŒå¤šç¨®ä¸¦ç™¼æ¨¡å¼
   - æä¾›ä»»å‹™èª¿åº¦
   - å„ªåŒ–è³‡æºä½¿ç”¨
   - ç›£æ§æ€§èƒ½æŒ‡æ¨™

2. **é€²ç¨‹æ± ç®¡ç†å™¨**
   å‰µå»ºä¸€å€‹é€²ç¨‹æ± ç®¡ç†å™¨ï¼š
   - ç®¡ç†é€²ç¨‹ç”Ÿå‘½é€±æœŸ
   - è™•ç†é€²ç¨‹é€šä¿¡
   - å„ªåŒ–é€²ç¨‹åˆ†é…
   - æä¾›éŒ¯èª¤è™•ç†

3. **ä¸¦ç™¼æ¡†æ¶**
   å¯¦ç¾ä¸€å€‹ä¸¦ç™¼æ¡†æ¶ï¼š
   - æ”¯æŒå¤šç¨®ä¸¦ç™¼æ¨¡å‹
   - æä¾›é«˜ç´šAPI
   - å„ªåŒ–æ€§èƒ½
   - è™•ç†è¤‡é›œå ´æ™¯

## å°æé†’ ğŸ’¡

1. ä¸¦ç™¼å„ªåŒ–
   - é¸æ“‡åˆé©æ¨¡å‹
   - æ§åˆ¶ä¸¦ç™¼åº¦
   - é¿å…æ­»é–
   - å„ªåŒ–è³‡æºä½¿ç”¨

2. é€²ç¨‹ç®¡ç†
   - æ§åˆ¶é€²ç¨‹æ•¸é‡
   - è™•ç†é€²ç¨‹é€šä¿¡
   - å„ªåŒ–é€²ç¨‹åˆ†é…
   - ç›£æ§é€²ç¨‹ç‹€æ…‹

3. æ€§èƒ½å„ªåŒ–
   - æ¸›å°‘é–‹éŠ·
   - å„ªåŒ–èª¿åº¦
   - å¹³è¡¡è² è¼‰
   - æé«˜ååé‡

4. èª¿è©¦æŠ€å·§
   - ä½¿ç”¨èª¿è©¦å·¥å…·
   - åˆ†ææ€§èƒ½ç“¶é ¸
   - å„ªåŒ–é—œéµè·¯å¾‘
   - ç›£æ§ç³»çµ±è³‡æº

[ä¸Šä¸€ç« ï¼šæ€§èƒ½å„ªåŒ–åŸºç¤](080_æ€§èƒ½å„ªåŒ–åŸºç¤.md) | [ä¸‹ä¸€ç« ï¼šä¸¦ç™¼ç·¨ç¨‹åŸºç¤](082_ä¸¦ç™¼ç·¨ç¨‹åŸºç¤.md) 