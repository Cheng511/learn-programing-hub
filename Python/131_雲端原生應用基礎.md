[ä¸Šä¸€ç« ï¼šç³»çµ±å¯è§€æ¸¬æ€§](130_ç³»çµ±å¯è§€æ¸¬æ€§.md) | [ä¸‹ä¸€ç« ï¼šå®¹å™¨åŒ–æ‡‰ç”¨é–‹ç™¼](132_å®¹å™¨åŒ–æ‡‰ç”¨é–‹ç™¼.md)

# Python é›²ç«¯åŸç”Ÿæ‡‰ç”¨åŸºç¤ â˜ï¸

## 1. é›²ç«¯åŸç”Ÿæ¦‚å¿µ

### 1.1 ä»€éº¼æ˜¯é›²ç«¯åŸç”Ÿï¼Ÿ

é›²ç«¯åŸç”Ÿï¼ˆCloud Nativeï¼‰æ˜¯ä¸€ç¨®æ§‹å»ºå’Œé‹è¡Œæ‡‰ç”¨ç¨‹åºçš„æ–¹æ³•ï¼Œå……åˆ†åˆ©ç”¨é›²ç«¯è¨ˆç®—å„ªå‹¢ï¼š
- å¯æ“´å±•æ€§ï¼ˆScalabilityï¼‰
- å½ˆæ€§ï¼ˆElasticityï¼‰
- è‡ªå‹•åŒ–ï¼ˆAutomationï¼‰
- å¯è§€æ¸¬æ€§ï¼ˆObservabilityï¼‰

### 1.2 é›²ç«¯åŸç”Ÿæ‡‰ç”¨ç‰¹é»

```python
from dataclasses import dataclass
from typing import List, Dict

@dataclass
class CloudNativeApp:
    """é›²ç«¯åŸç”Ÿæ‡‰ç”¨çš„åŸºæœ¬ç‰¹å¾µ"""
    name: str
    version: str
    components: List[str]
    config: Dict[str, str]
    
    def is_cloud_native_compliant(self) -> bool:
        """æª¢æŸ¥æ‡‰ç”¨æ˜¯å¦ç¬¦åˆé›²ç«¯åŸç”Ÿç‰¹å¾µ"""
        requirements = [
            "containerized",      # å®¹å™¨åŒ–
            "microservices",      # å¾®æœå‹™æ¶æ§‹
            "api-driven",         # APIé©…å‹•
            "stateless",          # ç„¡ç‹€æ…‹
            "scalable"           # å¯æ“´å±•
        ]
        return all(req in self.components for req in requirements)
```

## 2. é›²ç«¯åŸç”Ÿé–‹ç™¼å·¥å…·

### 2.1 ç’°å¢ƒé…ç½®ç®¡ç†

```python
import os
from pathlib import Path
import yaml

class CloudConfig:
    """é›²ç«¯ç’°å¢ƒé…ç½®ç®¡ç†"""
    def __init__(self, config_path: str):
        self.config_path = Path(config_path)
        self.config = self._load_config()
        
    def _load_config(self) -> dict:
        """åŠ è¼‰é…ç½®æ–‡ä»¶"""
        if not self.config_path.exists():
            return {}
        
        with open(self.config_path) as f:
            return yaml.safe_load(f)
    
    def get_service_config(self, service_name: str) -> dict:
        """ç²å–æœå‹™é…ç½®"""
        return self.config.get('services', {}).get(service_name, {})
    
    def update_config(self, service_name: str, config: dict):
        """æ›´æ–°æœå‹™é…ç½®"""
        if 'services' not in self.config:
            self.config['services'] = {}
        self.config['services'][service_name] = config
        
        with open(self.config_path, 'w') as f:
            yaml.dump(self.config, f)
```

## 3. æœå‹™ç™¼ç¾èˆ‡è¨»å†Š

### 3.1 æœå‹™è¨»å†Š

```python
import requests
from typing import Optional

class ServiceRegistry:
    """æœå‹™è¨»å†Šèˆ‡ç™¼ç¾"""
    def __init__(self, registry_url: str):
        self.registry_url = registry_url
        
    async def register_service(self, 
                             service_name: str,
                             service_url: str,
                             metadata: Optional[dict] = None):
        """è¨»å†Šæœå‹™"""
        payload = {
            "name": service_name,
            "url": service_url,
            "metadata": metadata or {}
        }
        
        try:
            response = requests.post(
                f"{self.registry_url}/register",
                json=payload
            )
            return response.status_code == 200
        except Exception as e:
            print(f"Service registration failed: {e}")
            return False
    
    async def discover_service(self, service_name: str) -> Optional[str]:
        """ç™¼ç¾æœå‹™"""
        try:
            response = requests.get(
                f"{self.registry_url}/discover/{service_name}"
            )
            if response.status_code == 200:
                return response.json().get("url")
        except Exception as e:
            print(f"Service discovery failed: {e}")
        return None
```

## 4. å¥åº·æª¢æŸ¥èˆ‡ç›£æ§

### 4.1 å¥åº·æª¢æŸ¥å¯¦ç¾

```python
from datetime import datetime
import asyncio
from typing import Dict, List

class HealthCheck:
    """æœå‹™å¥åº·æª¢æŸ¥"""
    def __init__(self):
        self.checks: Dict[str, callable] = {}
        self.status: Dict[str, bool] = {}
        
    def add_check(self, name: str, check_func: callable):
        """æ·»åŠ å¥åº·æª¢æŸ¥é …"""
        self.checks[name] = check_func
        
    async def run_checks(self) -> Dict[str, dict]:
        """åŸ·è¡Œæ‰€æœ‰å¥åº·æª¢æŸ¥"""
        results = {}
        for name, check in self.checks.items():
            try:
                start_time = datetime.now()
                status = await check()
                duration = (datetime.now() - start_time).total_seconds()
                
                results[name] = {
                    "status": "healthy" if status else "unhealthy",
                    "timestamp": datetime.now().isoformat(),
                    "duration": duration
                }
            except Exception as e:
                results[name] = {
                    "status": "unhealthy",
                    "error": str(e),
                    "timestamp": datetime.now().isoformat()
                }
        return results
```

## 5. é›²ç«¯åŸç”Ÿå„²å­˜

### 5.1 å°è±¡å„²å­˜æ¥å£

```python
from abc import ABC, abstractmethod
import boto3
from google.cloud import storage
from azure.storage.blob import BlobServiceClient

class CloudStorage(ABC):
    """é›²ç«¯å„²å­˜æŠ½è±¡æ¥å£"""
    @abstractmethod
    async def upload_file(self, local_path: str, remote_path: str):
        pass
    
    @abstractmethod
    async def download_file(self, remote_path: str, local_path: str):
        pass

class S3Storage(CloudStorage):
    """AWS S3å„²å­˜å¯¦ç¾"""
    def __init__(self, bucket_name: str):
        self.s3 = boto3.client('s3')
        self.bucket = bucket_name
    
    async def upload_file(self, local_path: str, remote_path: str):
        """ä¸Šå‚³æ–‡ä»¶åˆ°S3"""
        try:
            self.s3.upload_file(local_path, self.bucket, remote_path)
            return True
        except Exception as e:
            print(f"Upload failed: {e}")
            return False
```

## ç·´ç¿’é¡Œ ğŸƒâ€â™‚ï¸

1. å¯¦ç¾ä¸€å€‹å®Œæ•´çš„é›²ç«¯åŸç”Ÿæ‡‰ç”¨ï¼ŒåŒ…å«ä»¥ä¸‹åŠŸèƒ½ï¼š
   - æœå‹™è¨»å†Šèˆ‡ç™¼ç¾
   - å¥åº·æª¢æŸ¥
   - é…ç½®ç®¡ç†
   - é›²ç«¯å„²å­˜é›†æˆ

2. å‰µå»ºä¸€å€‹ç°¡å–®çš„å¾®æœå‹™ï¼Œä¸¦å°‡å…¶éƒ¨ç½²åˆ°é›²ç«¯å¹³å°ï¼š
   - å¯¦ç¾ RESTful API
   - æ·»åŠ å¥åº·æª¢æŸ¥ç«¯é»
   - é›†æˆæœå‹™ç™¼ç¾
   - å¯¦ç¾å„ªé›…é—œé–‰

3. è¨­è¨ˆä¸€å€‹é›²ç«¯åŸç”Ÿæ‡‰ç”¨çš„ç›£æ§ç³»çµ±ï¼š
   - æ”¶é›†æ€§èƒ½æŒ‡æ¨™
   - å¯¦ç¾å‘Šè­¦æ©Ÿåˆ¶
   - ç”Ÿæˆç›£æ§å ±å‘Š

4. å¯¦ç¾ä¸€å€‹æ”¯æ´å¤šé›²ç«¯å¹³å°çš„å„²å­˜ç³»çµ±ï¼š
   - æ”¯æ´ AWS S3
   - æ”¯æ´ Google Cloud Storage
   - æ”¯æ´ Azure Blob Storage
   - å¯¦ç¾çµ±ä¸€çš„å„²å­˜æ¥å£

5. é–‹ç™¼ä¸€å€‹é…ç½®ç®¡ç†å·¥å…·ï¼š
   - æ”¯æ´å¤šç’°å¢ƒé…ç½®
   - å¯¦ç¾é…ç½®ç†±æ›´æ–°
   - æ·»åŠ é…ç½®ç‰ˆæœ¬æ§åˆ¶

## å°çµ ğŸ“

- äº†è§£äº†é›²ç«¯åŸç”Ÿæ‡‰ç”¨çš„åŸºæœ¬æ¦‚å¿µ
- æŒæ¡äº†æœå‹™è¨»å†Šèˆ‡ç™¼ç¾çš„å¯¦ç¾æ–¹æ³•
- å­¸æœƒäº†å¥åº·æª¢æŸ¥çš„å¯¦ç¾
- ç†è§£äº†é›²ç«¯åŸç”Ÿå„²å­˜ä½¿ç”¨
- æŒæ¡äº†é…ç½®ç®¡ç†çš„æ–¹æ³•

## å»¶ä¼¸é–±è®€ ğŸ“š

1. Cloud Native Computing Foundation (CNCF) å®˜æ–¹æ–‡æª”
2. Kubernetes å®˜æ–¹æ–‡æª”
3. åäºŒè¦ç´ æ‡‰ç”¨å®£è¨€
4. å¾®æœå‹™è¨­è¨ˆæ¨¡å¼
5. é›²ç«¯åŸç”Ÿæ¶æ§‹å¯¦è¸æŒ‡å—

[ä¸Šä¸€ç« ï¼šç³»çµ±å¯è§€æ¸¬æ€§](130_ç³»çµ±å¯è§€æ¸¬æ€§.md) | [ä¸‹ä¸€ç« ï¼šå®¹å™¨åŒ–æ‡‰ç”¨é–‹ç™¼](132_å®¹å™¨åŒ–æ‡‰ç”¨é–‹ç™¼.md) 