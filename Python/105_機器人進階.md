[ä¸Šä¸€ç« ï¼šæ©Ÿå™¨äººåŸºç¤](104_æ©Ÿå™¨äººåŸºç¤.md) | [ä¸‹ä¸€ç« ï¼šéŠæˆ²é–‹ç™¼åŸºç¤](106_éŠæˆ²é–‹ç™¼åŸºç¤.md)

# Python æ©Ÿå™¨äººé€²éš ğŸ¤–

## æ©Ÿå™¨äººæ§åˆ¶é€²éš

### 1. è·¯å¾‘è¦åŠƒ

```python
import numpy as np
from typing import Tuple, List, Optional, Dict
import time
import sys
import os
from queue import PriorityQueue

class PathPlanner:
    def __init__(self):
        """åˆå§‹åŒ–è·¯å¾‘è¦åŠƒå™¨"""
        try:
            # åˆå§‹åŒ–è¦åŠƒåƒæ•¸
            self.grid_size = 0.1  # ç¶²æ ¼å¤§å°
            self.max_iterations = 1000  # æœ€å¤§è¿­ä»£æ¬¡æ•¸
            self.goal_threshold = 0.1  # ç›®æ¨™é–¾å€¼
            
            print("Path planner initialized")
            
        except Exception as e:
            print(f"Error initializing path planner: {e}")
    
    def create_grid(self, width: float, height: float) -> np.ndarray:
        """å‰µå»ºç¶²æ ¼åœ°åœ–"""
        try:
            rows = int(height / self.grid_size)
            cols = int(width / self.grid_size)
            grid = np.zeros((rows, cols), dtype=int)
            return grid
            
        except Exception as e:
            print(f"Error creating grid: {e}")
            return np.array([])
    
    def add_obstacles(self, grid: np.ndarray, obstacles: List[Tuple[float, float, float, float]]) -> np.ndarray:
        """æ·»åŠ éšœç¤™ç‰©"""
        try:
            for obs in obstacles:
                x, y, w, h = obs
                start_row = int(y / self.grid_size)
                start_col = int(x / self.grid_size)
                end_row = int((y + h) / self.grid_size)
                end_col = int((x + w) / self.grid_size)
                
                grid[start_row:end_row, start_col:end_col] = 1
            
            return grid
            
        except Exception as e:
            print(f"Error adding obstacles: {e}")
            return grid
    
    def a_star(self, grid: np.ndarray, start: Tuple[float, float], goal: Tuple[float, float]) -> List[Tuple[float, float]]:
        """A*ç®—æ³•è·¯å¾‘è¦åŠƒ"""
        try:
            # è½‰æ›ç‚ºç¶²æ ¼åæ¨™
            start_grid = (int(start[1] / self.grid_size), int(start[0] / self.grid_size))
            goal_grid = (int(goal[1] / self.grid_size), int(goal[0] / self.grid_size))
            
            # åˆå§‹åŒ–å„ªå…ˆéšŠåˆ—
            pq = PriorityQueue()
            pq.put((0, start_grid))
            
            # åˆå§‹åŒ–è¨ªå•å’Œçˆ¶ç¯€é»å­—å…¸
            visited = {start_grid}
            parent = {start_grid: None}
            g_score = {start_grid: 0}
            f_score = {start_grid: self._heuristic(start_grid, goal_grid)}
            
            while not pq.empty():
                current = pq.get()[1]
                
                # æª¢æŸ¥æ˜¯å¦åˆ°é”ç›®æ¨™
                if self._distance(current, goal_grid) < self.goal_threshold:
                    return self._reconstruct_path(parent, current)
                
                # éæ­·é„°å±…ç¯€é»
                for neighbor in self._get_neighbors(grid, current):
                    if neighbor in visited:
                        continue
                    
                    tentative_g = g_score[current] + self._distance(current, neighbor)
                    
                    if neighbor not in g_score or tentative_g < g_score[neighbor]:
                        parent[neighbor] = current
                        g_score[neighbor] = tentative_g
                        f_score[neighbor] = g_score[neighbor] + self._heuristic(neighbor, goal_grid)
                        pq.put((f_score[neighbor], neighbor))
                        visited.add(neighbor)
            
            return []
            
        except Exception as e:
            print(f"Error in A* planning: {e}")
            return []
    
    def rrt(self, grid: np.ndarray, start: Tuple[float, float], goal: Tuple[float, float]) -> List[Tuple[float, float]]:
        """RRTç®—æ³•è·¯å¾‘è¦åŠƒ"""
        try:
            # è½‰æ›ç‚ºç¶²æ ¼åæ¨™
            start_grid = (int(start[1] / self.grid_size), int(start[0] / self.grid_size))
            goal_grid = (int(goal[1] / self.grid_size), int(goal[0] / self.grid_size))
            
            # åˆå§‹åŒ–ç¯€é»åˆ—è¡¨
            nodes = [start_grid]
            parent = {start_grid: None}
            
            for _ in range(self.max_iterations):
                # éš¨æ©Ÿæ¡æ¨£
                if np.random.random() < 0.1:
                    sample = goal_grid
                else:
                    sample = self._random_sample(grid)
                
                # æ‰¾åˆ°æœ€è¿‘ç¯€é»
                nearest = self._find_nearest(nodes, sample)
                
                # å‘æ¡æ¨£é»å»¶ä¼¸
                new_node = self._extend(nearest, sample)
                
                # æª¢æŸ¥æ˜¯å¦æœ‰æ•ˆ
                if self._is_valid(grid, new_node):
                    nodes.append(new_node)
                    parent[new_node] = nearest
                    
                    # æª¢æŸ¥æ˜¯å¦åˆ°é”ç›®æ¨™
                    if self._distance(new_node, goal_grid) < self.goal_threshold:
                        return self._reconstruct_path(parent, new_node)
            
            return []
            
        except Exception as e:
            print(f"Error in RRT planning: {e}")
            return []
    
    def _heuristic(self, a: Tuple[int, int], b: Tuple[int, int]) -> float:
        """è¨ˆç®—å•Ÿç™¼å¼å€¼"""
        return np.sqrt((a[0] - b[0])**2 + (a[1] - b[1])**2)
    
    def _distance(self, a: Tuple[int, int], b: Tuple[int, int]) -> float:
        """è¨ˆç®—è·é›¢"""
        return np.sqrt((a[0] - b[0])**2 + (a[1] - b[1])**2)
    
    def _get_neighbors(self, grid: np.ndarray, node: Tuple[int, int]) -> List[Tuple[int, int]]:
        """ç²å–é„°å±…ç¯€é»"""
        neighbors = []
        for dx in [-1, 0, 1]:
            for dy in [-1, 0, 1]:
                if dx == 0 and dy == 0:
                    continue
                new_x = node[0] + dx
                new_y = node[1] + dy
                if (0 <= new_x < grid.shape[0] and 
                    0 <= new_y < grid.shape[1] and 
                    grid[new_x, new_y] == 0):
                    neighbors.append((new_x, new_y))
        return neighbors
    
    def _random_sample(self, grid: np.ndarray) -> Tuple[int, int]:
        """éš¨æ©Ÿæ¡æ¨£"""
        while True:
            x = np.random.randint(0, grid.shape[0])
            y = np.random.randint(0, grid.shape[1])
            if grid[x, y] == 0:
                return (x, y)
    
    def _find_nearest(self, nodes: List[Tuple[int, int]], sample: Tuple[int, int]) -> Tuple[int, int]:
        """æ‰¾åˆ°æœ€è¿‘ç¯€é»"""
        min_dist = float('inf')
        nearest = nodes[0]
        for node in nodes:
            dist = self._distance(node, sample)
            if dist < min_dist:
                min_dist = dist
                nearest = node
        return nearest
    
    def _extend(self, from_node: Tuple[int, int], to_node: Tuple[int, int]) -> Tuple[int, int]:
        """å‘ç›®æ¨™é»å»¶ä¼¸"""
        dist = self._distance(from_node, to_node)
        if dist <= self.grid_size:
            return to_node
        else:
            theta = np.arctan2(to_node[0] - from_node[0], to_node[1] - from_node[1])
            return (int(from_node[0] + self.grid_size * np.sin(theta)),
                   int(from_node[1] + self.grid_size * np.cos(theta)))
    
    def _is_valid(self, grid: np.ndarray, node: Tuple[int, int]) -> bool:
        """æª¢æŸ¥ç¯€é»æ˜¯å¦æœ‰æ•ˆ"""
        return (0 <= node[0] < grid.shape[0] and 
                0 <= node[1] < grid.shape[1] and 
                grid[node[0], node[1]] == 0)
    
    def _reconstruct_path(self, parent: Dict, current: Tuple[int, int]) -> List[Tuple[float, float]]:
        """é‡å»ºè·¯å¾‘"""
        path = []
        while current is not None:
            path.append((current[1] * self.grid_size, current[0] * self.grid_size))
            current = parent[current]
        return path[::-1]

# ä½¿ç”¨ç¤ºä¾‹
def main():
    # å‰µå»ºè·¯å¾‘è¦åŠƒå™¨
    planner = PathPlanner()
    
    try:
        # å‰µå»ºç¶²æ ¼åœ°åœ–
        grid = planner.create_grid(10.0, 10.0)
        
        # æ·»åŠ éšœç¤™ç‰©
        obstacles = [
            (2.0, 2.0, 1.0, 1.0),
            (4.0, 4.0, 1.0, 1.0),
            (6.0, 6.0, 1.0, 1.0)
        ]
        grid = planner.add_obstacles(grid, obstacles)
        
        # è¨­ç½®èµ·é»å’Œçµ‚é»
        start = (0.0, 0.0)
        goal = (9.0, 9.0)
        
        # ä½¿ç”¨A*ç®—æ³•è¦åŠƒè·¯å¾‘
        path_astar = planner.a_star(grid, start, goal)
        print(f"A* path: {path_astar}")
        
        # ä½¿ç”¨RRTç®—æ³•è¦åŠƒè·¯å¾‘
        path_rrt = planner.rrt(grid, start, goal)
        print(f"RRT path: {path_rrt}")
    
    except Exception as e:
        print(f"Error in main: {e}")

if __name__ == '__main__':
    main()
```

### 2. é‹å‹•è¦åŠƒ

```python
import numpy as np
from typing import Tuple, List, Optional, Dict
import time
import sys
import os

class MotionPlanner:
    def __init__(self):
        """åˆå§‹åŒ–é‹å‹•è¦åŠƒå™¨"""
        try:
            # åˆå§‹åŒ–è¦åŠƒåƒæ•¸
            self.max_velocity = np.array([1.0, 1.0, np.pi/2])  # æœ€å¤§é€Ÿåº¦
            self.max_acceleration = np.array([0.5, 0.5, np.pi/4])  # æœ€å¤§åŠ é€Ÿåº¦
            self.dt = 0.1  # æ™‚é–“æ­¥é•·
            
            print("Motion planner initialized")
            
        except Exception as e:
            print(f"Error initializing motion planner: {e}")
    
    def plan_trajectory(self, path: List[Tuple[float, float]], 
                       initial_velocity: np.ndarray = None) -> List[Dict]:
        """è¦åŠƒè»Œè·¡"""
        try:
            if initial_velocity is None:
                initial_velocity = np.zeros(3)
            
            trajectory = []
            current_velocity = initial_velocity.copy()
            current_position = np.array([path[0][0], path[0][1], 0.0])
            
            for i in range(len(path) - 1):
                # è¨ˆç®—ç›®æ¨™ä½ç½®å’Œæ–¹å‘
                target_position = np.array([path[i+1][0], path[i+1][1], 0.0])
                direction = target_position - current_position
                target_angle = np.arctan2(direction[1], direction[0])
                
                # è¨ˆç®—æ‰€éœ€é€Ÿåº¦
                distance = np.linalg.norm(direction[:2])
                required_velocity = direction / self.dt
                
                # é™åˆ¶é€Ÿåº¦å’ŒåŠ é€Ÿåº¦
                velocity_change = required_velocity - current_velocity
                max_velocity_change = self.max_acceleration * self.dt
                velocity_change = np.clip(velocity_change,
                                        -max_velocity_change,
                                        max_velocity_change)
                
                new_velocity = current_velocity + velocity_change
                new_velocity = np.clip(new_velocity,
                                     -self.max_velocity,
                                     self.max_velocity)
                
                # æ›´æ–°ä½ç½®å’Œé€Ÿåº¦
                current_position += new_velocity * self.dt
                current_velocity = new_velocity
                
                # è¨˜éŒ„ç‹€æ…‹
                state = {
                    'position': current_position.copy(),
                    'velocity': current_velocity.copy(),
                    'time': i * self.dt
                }
                trajectory.append(state)
            
            return trajectory
            
        except Exception as e:
            print(f"Error planning trajectory: {e}")
            return []
    
    def optimize_trajectory(self, trajectory: List[Dict]) -> List[Dict]:
        """å„ªåŒ–è»Œè·¡"""
        try:
            optimized = []
            for i in range(len(trajectory)):
                if i == 0 or i == len(trajectory) - 1:
                    optimized.append(trajectory[i])
                    continue
                
                # è¨ˆç®—å¹³æ»‘å¾Œçš„ç‹€æ…‹
                prev_state = trajectory[i-1]
                curr_state = trajectory[i]
                next_state = trajectory[i+1]
                
                # å¹³æ»‘ä½ç½®
                smooth_position = (prev_state['position'] + 
                                 2 * curr_state['position'] + 
                                 next_state['position']) / 4
                
                # å¹³æ»‘é€Ÿåº¦
                smooth_velocity = (prev_state['velocity'] + 
                                 2 * curr_state['velocity'] + 
                                 next_state['velocity']) / 4
                
                # é™åˆ¶é€Ÿåº¦å’ŒåŠ é€Ÿåº¦
                smooth_velocity = np.clip(smooth_velocity,
                                        -self.max_velocity,
                                        self.max_velocity)
                
                # è¨˜éŒ„å„ªåŒ–å¾Œçš„ç‹€æ…‹
                state = {
                    'position': smooth_position,
                    'velocity': smooth_velocity,
                    'time': curr_state['time']
                }
                optimized.append(state)
            
            return optimized
            
        except Exception as e:
            print(f"Error optimizing trajectory: {e}")
            return trajectory
    
    def check_collision(self, trajectory: List[Dict], obstacles: List[Tuple[float, float, float, float]]) -> bool:
        """æª¢æŸ¥ç¢°æ’"""
        try:
            for state in trajectory:
                position = state['position']
                for obs in obstacles:
                    x, y, w, h = obs
                    if (x <= position[0] <= x + w and 
                        y <= position[1] <= y + h):
                        return True
            return False
            
        except Exception as e:
            print(f"Error checking collision: {e}")
            return True
    
    def generate_trajectory(self, path: List[Tuple[float, float]], 
                          obstacles: List[Tuple[float, float, float, float]]) -> List[Dict]:
        """ç”Ÿæˆç„¡ç¢°æ’è»Œè·¡"""
        try:
            # åˆå§‹è»Œè·¡è¦åŠƒ
            trajectory = self.plan_trajectory(path)
            
            # å„ªåŒ–è»Œè·¡
            trajectory = self.optimize_trajectory(trajectory)
            
            # æª¢æŸ¥ç¢°æ’
            if self.check_collision(trajectory, obstacles):
                print("Warning: Trajectory has collisions")
            
            return trajectory
            
        except Exception as e:
            print(f"Error generating trajectory: {e}")
            return []

# ä½¿ç”¨ç¤ºä¾‹
def main():
    # å‰µå»ºé‹å‹•è¦åŠƒå™¨
    planner = MotionPlanner()
    
    try:
        # å‰µå»ºè·¯å¾‘
        path = [
            (0.0, 0.0),
            (1.0, 1.0),
            (2.0, 0.0),
            (3.0, 1.0)
        ]
        
        # å‰µå»ºéšœç¤™ç‰©
        obstacles = [
            (1.5, 0.5, 0.5, 0.5),
            (2.5, 0.5, 0.5, 0.5)
        ]
        
        # ç”Ÿæˆè»Œè·¡
        trajectory = planner.generate_trajectory(path, obstacles)
        
        # æ‰“å°è»Œè·¡
        for state in trajectory:
            print(f"Time: {state['time']:.2f}")
            print(f"Position: {state['position']}")
            print(f"Velocity: {state['velocity']}")
            print()
    
    except Exception as e:
        print(f"Error in main: {e}")

if __name__ == '__main__':
    main()
```

## ç·´ç¿’é¡Œ

1. **è·¯å¾‘è¦åŠƒ**
   é–‹ç™¼è·¯å¾‘è¦åŠƒï¼š
   - A*ç®—æ³•
   - RRTç®—æ³•
   - è·¯å¾‘å„ªåŒ–
   - å„ªåŒ–æ€§èƒ½

2. **é‹å‹•è¦åŠƒ**
   å‰µå»ºé‹å‹•è¦åŠƒï¼š
   - è»Œè·¡ç”Ÿæˆ
   - è»Œè·¡å„ªåŒ–
   - ç¢°æ’æª¢æ¸¬
   - å„ªåŒ–æ€§èƒ½

3. **æ©Ÿå™¨äººæ§åˆ¶**
   å¯¦ç¾æ©Ÿå™¨äººæ§åˆ¶ï¼š
   - è·¯å¾‘è·Ÿéš¨
   - é‹å‹•æ§åˆ¶
   - å„ªåŒ–æ€§èƒ½
   - è™•ç†ç•°å¸¸

## å°æé†’ ğŸ’¡

1. è·¯å¾‘è¦åŠƒ
   - é¸æ“‡åˆé©ç®—æ³•
   - å„ªåŒ–åƒæ•¸
   - è™•ç†ç•°å¸¸
   - æä¾›ç›£æ§

2. é‹å‹•è¦åŠƒ
   - é¸æ“‡åˆé©æ–¹æ³•
   - å„ªåŒ–æ€§èƒ½
   - è™•ç†ç•°å¸¸
   - æä¾›çµæœ

3. æ©Ÿå™¨äººæ§åˆ¶
   - é¸æ“‡åˆé©ç®—æ³•
   - å„ªåŒ–æ€§èƒ½
   - è™•ç†ç•°å¸¸
   - æä¾›ç›£æ§

4. èª¿è©¦æŠ€å·§
   - ä½¿ç”¨é–‹ç™¼å·¥å…·
   - åˆ†ææ€§èƒ½
   - å„ªåŒ–é—œéµè·¯å¾‘
   - ç›£æ§è™•ç†ç‹€æ…‹

[ä¸Šä¸€ç« ï¼šæ©Ÿå™¨äººåŸºç¤](104_æ©Ÿå™¨äººåŸºç¤.md) | [ä¸‹ä¸€ç« ï¼šéŠæˆ²é–‹ç™¼åŸºç¤](106_éŠæˆ²é–‹ç™¼åŸºç¤.md) 