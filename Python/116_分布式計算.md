[ä¸Šä¸€ç« ï¼šå¤§æ•¸æ“šè™•ç†åŸºç¤](115_å¤§æ•¸æ“šè™•ç†åŸºç¤.md) | [ä¸‹ä¸€ç« ï¼šé›²ç«¯æ•¸æ“šåº«æ•´åˆ](117_é›²ç«¯æ•¸æ“šåº«æ•´åˆ.md)

# Python åˆ†å¸ƒå¼è¨ˆç®— ğŸŒ

## 1. åˆ†å¸ƒå¼è¨ˆç®—åŸºç¤

### 1.1 åˆ†å¸ƒå¼ç³»çµ±æ¶æ§‹

```python
from typing import List, Dict, Any
import socket
import json
import threading

class DistributedNode:
    def __init__(self, host: str, port: int):
        self.host = host
        self.port = port
        self.peers: List[Dict] = []
        self.is_running = False
        
    def start(self):
        """å•Ÿå‹•ç¯€é»æœå‹™"""
        self.server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        self.server_socket.bind((self.host, self.port))
        self.server_socket.listen(5)
        
        self.is_running = True
        self.listener_thread = threading.Thread(target=self._listen_for_connections)
        self.listener_thread.start()
    
    def _listen_for_connections(self):
        """ç›£è½é€£æ¥è«‹æ±‚"""
        while self.is_running:
            try:
                client_socket, address = self.server_socket.accept()
                handler = threading.Thread(
                    target=self._handle_connection,
                    args=(client_socket, address)
                )
                handler.start()
            except Exception as e:
                print(f"Connection error: {e}")
```

### 1.2 ä»»å‹™åˆ†ç™¼

```python
from dataclasses import dataclass
from typing import Callable, Optional
import pickle

@dataclass
class Task:
    id: str
    function: Callable
    args: tuple
    kwargs: dict
    result: Optional[Any] = None

class TaskDistributor:
    def __init__(self):
        self.tasks: Dict[str, Task] = {}
        self.workers: List[str] = []
    
    def add_task(self, task: Task):
        """æ·»åŠ ä»»å‹™"""
        self.tasks[task.id] = task
    
    def distribute_tasks(self):
        """åˆ†ç™¼ä»»å‹™åˆ°å·¥ä½œç¯€é»"""
        for task_id, task in self.tasks.items():
            if not task.result:
                worker = self._get_available_worker()
                if worker:
                    self._send_task_to_worker(worker, task)
    
    def _send_task_to_worker(self, worker: str, task: Task):
        """ç™¼é€ä»»å‹™åˆ°å·¥ä½œç¯€é»"""
        serialized_task = pickle.dumps(task)
        # å¯¦ç¾å…·é«”çš„ä»»å‹™ç™¼é€é‚è¼¯
```

## 2. åˆ†å¸ƒå¼è¨ˆç®—æ¡†æ¶

### 2.1 Celery æ‡‰ç”¨

```python
from celery import Celery
from typing import List, Dict
import time

class CeleryManager:
    def __init__(self, app_name: str, broker_url: str):
        self.app = Celery(app_name, broker=broker_url)
        self.configure()
    
    def configure(self):
        """é…ç½®Celery"""
        self.app.conf.update(
            task_serializer='json',
            accept_content=['json'],
            result_serializer='json',
            timezone='Asia/Shanghai',
            enable_utc=True
        )
    
    @self.app.task
    def process_data(self, data: Dict) -> Dict:
        """è™•ç†æ•¸æ“šçš„ä»»å‹™"""
        # å¯¦ç¾æ•¸æ“šè™•ç†é‚è¼¯
        time.sleep(1)  # æ¨¡æ“¬è™•ç†æ™‚é–“
        return {'processed': data}
    
    def process_batch(self, items: List[Dict]):
        """æ‰¹é‡è™•ç†æ•¸æ“š"""
        tasks = []
        for item in items:
            task = self.process_data.delay(item)
            tasks.append(task)
        return [task.get() for task in tasks]
```

### 2.2 Ray æ¡†æ¶æ‡‰ç”¨

```python
import ray
from typing import List

@ray.remote
class RayWorker:
    def __init__(self):
        self.data = []
    
    def process(self, item: Any) -> Any:
        """è™•ç†å–®å€‹æ•¸æ“šé …"""
        # å¯¦ç¾è™•ç†é‚è¼¯
        return processed_item
    
    def batch_process(self, items: List[Any]) -> List[Any]:
        """æ‰¹é‡è™•ç†æ•¸æ“š"""
        return [self.process(item) for item in items]

class RayManager:
    def __init__(self, num_workers: int = 4):
        ray.init()
        self.workers = [RayWorker.remote() for _ in range(num_workers)]
    
    def distribute_work(self, data: List[Any]) -> List[Any]:
        """åˆ†ç™¼å·¥ä½œåˆ°Rayå·¥ä½œè€…"""
        chunk_size = len(data) // len(self.workers)
        chunks = [data[i:i + chunk_size] for i in range(0, len(data), chunk_size)]
        
        # ä¸¦è¡Œè™•ç†
        futures = [worker.batch_process.remote(chunk) for worker, chunk in zip(self.workers, chunks)]
        return ray.get(futures)
```

## 3. åˆ†å¸ƒå¼å­˜å„²

### 3.1 åˆ†å¸ƒå¼æ–‡ä»¶ç³»çµ±

```python
import os
from typing import BinaryIO
import hashlib

class DistributedFileSystem:
    def __init__(self, base_path: str, replicas: int = 3):
        self.base_path = base_path
        self.replicas = replicas
        os.makedirs(base_path, exist_ok=True)
    
    def save_file(self, file_path: str, content: BinaryIO):
        """ä¿å­˜æ–‡ä»¶åˆ°åˆ†å¸ƒå¼ç³»çµ±"""
        file_hash = self._calculate_hash(content)
        locations = self._get_storage_locations(file_hash)
        
        for location in locations:
            full_path = os.path.join(self.base_path, location)
            os.makedirs(os.path.dirname(full_path), exist_ok=True)
            with open(full_path, 'wb') as f:
                f.write(content.read())
                content.seek(0)
    
    def _calculate_hash(self, content: BinaryIO) -> str:
        """è¨ˆç®—æ–‡ä»¶å“ˆå¸Œå€¼"""
        sha256 = hashlib.sha256()
        for chunk in iter(lambda: content.read(4096), b''):
            sha256.update(chunk)
        content.seek(0)
        return sha256.hexdigest()
```

### 3.2 åˆ†å¸ƒå¼ç·©å­˜

```python
from typing import Any, Optional
import time
import threading

class DistributedCache:
    def __init__(self, capacity: int = 1000):
        self.capacity = capacity
        self.cache: Dict[str, Any] = {}
        self.locks: Dict[str, threading.Lock] = {}
        self.last_used: Dict[str, float] = {}
    
    def get(self, key: str) -> Optional[Any]:
        """ç²å–ç·©å­˜å€¼"""
        if key in self.cache:
            self.last_used[key] = time.time()
            return self.cache[key]
        return None
    
    def set(self, key: str, value: Any):
        """è¨­ç½®ç·©å­˜å€¼"""
        with self._get_lock(key):
            if len(self.cache) >= self.capacity:
                self._evict_least_used()
            self.cache[key] = value
            self.last_used[key] = time.time()
    
    def _get_lock(self, key: str) -> threading.Lock:
        """ç²å–éµçš„é–"""
        if key not in self.locks:
            self.locks[key] = threading.Lock()
        return self.locks[key]
```

## 4. åˆ†å¸ƒå¼å”èª¿

### 4.1 ZooKeeper æ•´åˆ

```python
from kazoo.client import KazooClient
from kazoo.recipe.lock import Lock
from typing import Callable

class ZooKeeperManager:
    def __init__(self, hosts: str):
        self.zk = KazooClient(hosts=hosts)
        self.zk.start()
    
    def create_node(self, path: str, value: bytes = b""):
        """å‰µå»ºç¯€é»"""
        self.zk.ensure_path(path)
        self.zk.create(path, value, makepath=True)
    
    def get_node_data(self, path: str) -> bytes:
        """ç²å–ç¯€é»æ•¸æ“š"""
        data, _ = self.zk.get(path)
        return data
    
    def watch_node(self, path: str, callback: Callable):
        """ç›£è¦–ç¯€é»è®ŠåŒ–"""
        @self.zk.DataWatch(path)
        def watch_callback(data, stat):
            callback(data, stat)
```

### 4.2 åˆ†å¸ƒå¼é–

```python
import time
from typing import Optional
import uuid

class DistributedLock:
    def __init__(self, zk_manager: ZooKeeperManager):
        self.zk = zk_manager
        self.locks: Dict[str, Lock] = {}
    
    def acquire_lock(self, resource: str, timeout: Optional[float] = None) -> bool:
        """ç²å–åˆ†å¸ƒå¼é–"""
        lock = self._get_lock(resource)
        return lock.acquire(timeout=timeout)
    
    def release_lock(self, resource: str):
        """é‡‹æ”¾åˆ†å¸ƒå¼é–"""
        lock = self._get_lock(resource)
        lock.release()
    
    def _get_lock(self, resource: str) -> Lock:
        """ç²å–è³‡æºçš„é–å°è±¡"""
        if resource not in self.locks:
            lock_path = f"/locks/{resource}"
            self.locks[resource] = self.zk.zk.Lock(lock_path)
        return self.locks[resource]
```

## ç·´ç¿’é¡Œ ğŸƒ

1. å¯¦ç¾ä¸€å€‹ç°¡å–®çš„åˆ†å¸ƒå¼è¨ˆç®—æ¡†æ¶ã€‚
2. ä½¿ç”¨Celeryé–‹ç™¼ä¸€å€‹åˆ†å¸ƒå¼ä»»å‹™è™•ç†ç³»çµ±ã€‚
3. å¯¦ç¾ä¸€å€‹åŸºæ–¼Rayçš„ä¸¦è¡Œæ•¸æ“šè™•ç†æ‡‰ç”¨ã€‚
4. è¨­è¨ˆä¸€å€‹åˆ†å¸ƒå¼æ–‡ä»¶å­˜å„²ç³»çµ±ã€‚
5. é–‹ç™¼ä¸€å€‹ä½¿ç”¨ZooKeeperçš„åˆ†å¸ƒå¼é…ç½®ç®¡ç†ç³»çµ±ã€‚

## å°çµ ğŸ“

- å­¸ç¿’äº†åˆ†å¸ƒå¼ç³»çµ±çš„åŸºæœ¬æ¦‚å¿µ
- æŒæ¡äº†ä»»å‹™åˆ†ç™¼å’Œè™•ç†æ–¹æ³•
- ç†è§£äº†åˆ†å¸ƒå¼å­˜å„²çš„å¯¦ç¾
- å­¸æœƒäº†ä½¿ç”¨åˆ†å¸ƒå¼è¨ˆç®—æ¡†æ¶
- äº†è§£äº†åˆ†å¸ƒå¼å”èª¿çš„é‡è¦æ€§

## å»¶ä¼¸é–±è®€ ğŸ“š

1. Distributed Systems with Python
2. Celery Best Practices
3. Ray: Distributed Computing Framework
4. ZooKeeper: Distributed Process Coordination
5. Distributed System Design Patterns

[ä¸Šä¸€ç« ï¼šå¤§æ•¸æ“šè™•ç†åŸºç¤](115_å¤§æ•¸æ“šè™•ç†åŸºç¤.md) | [ä¸‹ä¸€ç« ï¼šé›²ç«¯æ•¸æ“šåº«æ•´åˆ](117_é›²ç«¯æ•¸æ“šåº«æ•´åˆ.md) 