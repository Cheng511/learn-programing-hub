[ä¸Šä¸€ç« ï¼šç³»çµ±å¯è§€æ¸¬æ€§](142_ç³»çµ±å¯è§€æ¸¬æ€§.md) | [ä¸‹ä¸€ç« ï¼šé«˜å¯ç”¨æ¶æ§‹è¨­è¨ˆ](144_é«˜å¯ç”¨æ¶æ§‹è¨­è¨ˆ.md)

# Python åˆ†å¸ƒå¼ç³»çµ±è¨­è¨ˆ ğŸŒ

## 1. åˆ†å¸ƒå¼å”èª¿

### 1.1 ZooKeeper é›†æˆ

```python
from kazoo.client import KazooClient
from kazoo.exceptions import NodeExistsError, NoNodeError
from typing import Dict, List, Optional
import json

class ZKCoordinator:
    """ZooKeeper å”èª¿å™¨"""
    def __init__(self,
                 hosts: str,
                 namespace: str):
        self.client = KazooClient(hosts=hosts)
        self.namespace = namespace
        self.client.start()
    
    def ensure_path(self, path: str):
        """ç¢ºä¿è·¯å¾‘å­˜åœ¨"""
        full_path = f"/{self.namespace}/{path}"
        self.client.ensure_path(full_path)
    
    async def register_service(self,
                             service_name: str,
                             service_info: Dict) -> bool:
        """è¨»å†Šæœå‹™"""
        try:
            path = f"/{self.namespace}/services/{service_name}"
            self.ensure_path(f"/{self.namespace}/services")
            
            self.client.create(
                path,
                json.dumps(service_info).encode(),
                ephemeral=True
            )
            return True
        except NodeExistsError:
            return False
    
    async def get_services(self,
                          service_name: str) -> List[Dict]:
        """ç²å–æœå‹™åˆ—è¡¨"""
        try:
            path = f"/{self.namespace}/services/{service_name}"
            if not self.client.exists(path):
                return []
            
            data, _ = self.client.get(path)
            return [json.loads(data.decode())]
        except NoNodeError:
            return []
    
    def watch_services(self,
                      service_name: str,
                      callback: Callable):
        """ç›£è½æœå‹™è®ŠåŒ–"""
        path = f"/{self.namespace}/services/{service_name}"
        
        @self.client.DataWatch(path)
        def watch_handler(data, stat):
            if data:
                service_info = json.loads(data.decode())
                callback(service_info)
```

### 1.2 åˆ†å¸ƒå¼é–

```python
import asyncio
from typing import Optional
import time

class DistributedLock:
    """åˆ†å¸ƒå¼é–"""
    def __init__(self,
                 zk: ZKCoordinator,
                 lock_name: str):
        self.zk = zk
        self.lock_path = f"locks/{lock_name}"
        self.lock_id = None
    
    async def acquire(self,
                     timeout: Optional[float] = None,
                     retry_delay: float = 0.1) -> bool:
        """ç²å–é–"""
        start_time = time.time()
        
        while True:
            try:
                # å‰µå»ºè‡¨æ™‚ç¯€é»
                path = f"/{self.zk.namespace}/{self.lock_path}"
                self.lock_id = await self.zk.client.create(
                    path,
                    ephemeral=True
                )
                return True
            except NodeExistsError:
                # æª¢æŸ¥è¶…æ™‚
                if timeout and time.time() - start_time > timeout:
                    return False
                
                # ç­‰å¾…é‡è©¦
                await asyncio.sleep(retry_delay)
    
    async def release(self):
        """é‡‹æ”¾é–"""
        if self.lock_id:
            try:
                await self.zk.client.delete(self.lock_id)
                self.lock_id = None
                return True
            except NoNodeError:
                return False
        return False

class DistributedReadWriteLock:
    """åˆ†å¸ƒå¼è®€å¯«é–"""
    def __init__(self,
                 zk: ZKCoordinator,
                 lock_name: str):
        self.zk = zk
        self.lock_path = f"rwlocks/{lock_name}"
        self.read_lock_path = f"{self.lock_path}/read"
        self.write_lock_path = f"{self.lock_path}/write"
    
    async def acquire_read(self,
                          timeout: Optional[float] = None) -> bool:
        """ç²å–è®€é–"""
        try:
            # ç¢ºä¿è·¯å¾‘å­˜åœ¨
            self.zk.ensure_path(self.read_lock_path)
            
            # æª¢æŸ¥æ˜¯å¦æœ‰å¯«é–
            if await self._has_write_lock():
                return False
            
            # å‰µå»ºè®€é–
            path = f"/{self.zk.namespace}/{self.read_lock_path}"
            await self.zk.client.create(
                path,
                ephemeral=True,
                sequence=True
            )
            return True
        except Exception:
            return False
    
    async def acquire_write(self,
                           timeout: Optional[float] = None) -> bool:
        """ç²å–å¯«é–"""
        try:
            # ç¢ºä¿è·¯å¾‘å­˜åœ¨
            self.zk.ensure_path(self.write_lock_path)
            
            # æª¢æŸ¥æ˜¯å¦æœ‰å…¶ä»–é–
            if await self._has_write_lock() or await self._has_read_locks():
                return False
            
            # å‰µå»ºå¯«é–
            path = f"/{self.zk.namespace}/{self.write_lock_path}"
            await self.zk.client.create(
                path,
                ephemeral=True
            )
            return True
        except Exception:
            return False
    
    async def _has_write_lock(self) -> bool:
        """æª¢æŸ¥æ˜¯å¦æœ‰å¯«é–"""
        path = f"/{self.zk.namespace}/{self.write_lock_path}"
        return bool(await self.zk.client.exists(path))
    
    async def _has_read_locks(self) -> bool:
        """æª¢æŸ¥æ˜¯å¦æœ‰è®€é–"""
        path = f"/{self.zk.namespace}/{self.read_lock_path}"
        children = await self.zk.client.get_children(path)
        return len(children) > 0
```

## 2. ä¸€è‡´æ€§ç®—æ³•

### 2.1 Raft å¯¦ç¾

```python
from enum import Enum
from typing import Dict, List, Optional
import random
import time

class NodeState(Enum):
    """ç¯€é»ç‹€æ…‹"""
    FOLLOWER = 1
    CANDIDATE = 2
    LEADER = 3

class RaftNode:
    """Raft ç¯€é»"""
    def __init__(self,
                 node_id: str,
                 nodes: List[str]):
        self.node_id = node_id
        self.nodes = nodes
        self.state = NodeState.FOLLOWER
        
        # æŒä¹…åŒ–ç‹€æ…‹
        self.current_term = 0
        self.voted_for = None
        self.log = []
        
        # æ˜“å¤±æ€§ç‹€æ…‹
        self.commit_index = 0
        self.last_applied = 0
        
        # é ˜å°äººç‹€æ…‹
        self.next_index = {node: 0 for node in nodes}
        self.match_index = {node: 0 for node in nodes}
        
        # é¸èˆ‰è¶…æ™‚
        self.election_timeout = random.randint(150, 300)
        self.last_heartbeat = time.time()
    
    async def start(self):
        """å•Ÿå‹•ç¯€é»"""
        while True:
            if self.state == NodeState.FOLLOWER:
                await self._run_follower()
            elif self.state == NodeState.CANDIDATE:
                await self._run_candidate()
            elif self.state == NodeState.LEADER:
                await self._run_leader()
    
    async def _run_follower(self):
        """é‹è¡Œè·Ÿéš¨è€…é‚è¼¯"""
        while self.state == NodeState.FOLLOWER:
            # æª¢æŸ¥æ˜¯å¦è¶…æ™‚
            if time.time() - self.last_heartbeat > self.election_timeout:
                self.state = NodeState.CANDIDATE
                break
            
            await asyncio.sleep(0.1)
    
    async def _run_candidate(self):
        """é‹è¡Œå€™é¸äººé‚è¼¯"""
        # å¢åŠ ä»»æœŸ
        self.current_term += 1
        self.voted_for = self.node_id
        votes = 1
        
        # ç™¼é€è«‹æ±‚æŠ•ç¥¨ RPC
        for node in self.nodes:
            if node != self.node_id:
                vote_granted = await self._request_vote(node)
                if vote_granted:
                    votes += 1
        
        # æª¢æŸ¥æ˜¯å¦ç²å¾—å¤šæ•¸ç¥¨
        if votes > len(self.nodes) // 2:
            self.state = NodeState.LEADER
        else:
            self.state = NodeState.FOLLOWER
    
    async def _run_leader(self):
        """é‹è¡Œé ˜å°è€…é‚è¼¯"""
        while self.state == NodeState.LEADER:
            # ç™¼é€å¿ƒè·³
            for node in self.nodes:
                if node != self.node_id:
                    await self._append_entries(node)
            
            await asyncio.sleep(0.05)
    
    async def _request_vote(self,
                          node: str) -> bool:
        """è«‹æ±‚æŠ•ç¥¨"""
        # å¯¦ç¾è«‹æ±‚æŠ•ç¥¨ RPC
        pass
    
    async def _append_entries(self,
                            node: str) -> bool:
        """è¿½åŠ æ—¥èªŒ"""
        # å¯¦ç¾è¿½åŠ æ—¥èªŒ RPC
        pass
```

### 2.2 å…±è­˜å”è­°

```python
from typing import Dict, List, Optional, Set
import asyncio

class ConsensusProtocol:
    """å…±è­˜å”è­°"""
    def __init__(self,
                 node_id: str,
                 nodes: List[str]):
        self.node_id = node_id
        self.nodes = nodes
        self.values: Dict[str, Set[str]] = {}
        self.decided: Dict[str, str] = {}
    
    async def propose(self,
                     key: str,
                     value: str) -> bool:
        """æè­°å€¼"""
        # åˆå§‹åŒ–æè­°
        if key not in self.values:
            self.values[key] = set()
        
        # æ·»åŠ æè­°å€¼
        self.values[key].add(value)
        
        # å»£æ’­æè­°
        tasks = [
            self._send_proposal(node, key, value)
            for node in self.nodes
            if node != self.node_id
        ]
        
        # ç­‰å¾…å›æ‡‰
        responses = await asyncio.gather(*tasks)
        
        # æª¢æŸ¥æ˜¯å¦é”æˆå…±è­˜
        accept_count = sum(1 for r in responses if r)
        return accept_count > len(self.nodes) // 2
    
    async def _send_proposal(self,
                           node: str,
                           key: str,
                           value: str) -> bool:
        """ç™¼é€æè­°"""
        # å¯¦ç¾ç™¼é€æè­°é‚è¼¯
        pass
    
    async def receive_proposal(self,
                             node: str,
                             key: str,
                             value: str) -> bool:
        """æ¥æ”¶æè­°"""
        # æª¢æŸ¥æ˜¯å¦å·²ç¶“æ±ºå®š
        if key in self.decided:
            return False
        
        # æ·»åŠ æè­°å€¼
        if key not in self.values:
            self.values[key] = set()
        self.values[key].add(value)
        
        # æª¢æŸ¥æ˜¯å¦å¯ä»¥æ±ºå®š
        if len(self.values[key]) > len(self.nodes) // 2:
            self.decided[key] = value
            return True
        
        return False
```

## 3. å®¹éŒ¯è™•ç†

### 3.1 æ•…éšœæª¢æ¸¬

```python
from typing import Dict, List, Optional, Set
import time

class FailureDetector:
    """æ•…éšœæª¢æ¸¬å™¨"""
    def __init__(self,
                 node_id: str,
                 nodes: List[str],
                 timeout: float = 1.0):
        self.node_id = node_id
        self.nodes = nodes
        self.timeout = timeout
        self.heartbeats: Dict[str, float] = {}
        self.suspected: Set[str] = set()
    
    def heartbeat(self, node: str):
        """æ¥æ”¶å¿ƒè·³"""
        self.heartbeats[node] = time.time()
        if node in self.suspected:
            self.suspected.remove(node)
    
    def check_nodes(self) -> Set[str]:
        """æª¢æŸ¥ç¯€é»ç‹€æ…‹"""
        current_time = time.time()
        
        # æª¢æŸ¥æ¯å€‹ç¯€é»
        for node in self.nodes:
            if node == self.node_id:
                continue
            
            # æª¢æŸ¥æœ€å¾Œå¿ƒè·³æ™‚é–“
            last_heartbeat = self.heartbeats.get(node, 0)
            if current_time - last_heartbeat > self.timeout:
                self.suspected.add(node)
            elif node in self.suspected:
                self.suspected.remove(node)
        
        return self.suspected.copy()

class PhiAccrualDetector:
    """Phi ç´¯ç©æ•…éšœæª¢æ¸¬å™¨"""
    def __init__(self,
                 threshold: float = 8.0,
                 window_size: int = 1000):
        self.threshold = threshold
        self.window_size = window_size
        self.intervals: Dict[str, List[float]] = {}
        self.last_heartbeat: Dict[str, float] = {}
    
    def heartbeat(self, node: str):
        """æ¥æ”¶å¿ƒè·³"""
        current_time = time.time()
        
        if node in self.last_heartbeat:
            # è¨ˆç®—æ™‚é–“é–“éš”
            interval = current_time - self.last_heartbeat[node]
            
            # æ›´æ–°é–“éš”çª—å£
            if node not in self.intervals:
                self.intervals[node] = []
            self.intervals[node].append(interval)
            
            # ä¿æŒçª—å£å¤§å°
            if len(self.intervals[node]) > self.window_size:
                self.intervals[node].pop(0)
        
        self.last_heartbeat[node] = current_time
    
    def phi(self, node: str) -> float:
        """è¨ˆç®— phi å€¼"""
        if node not in self.last_heartbeat:
            return float('inf')
        
        current_time = time.time()
        time_diff = current_time - self.last_heartbeat[node]
        
        if not self.intervals.get(node):
            return float('inf')
        
        # è¨ˆç®—å‡å€¼å’Œæ¨™æº–å·®
        mean = sum(self.intervals[node]) / len(self.intervals[node])
        variance = sum((x - mean) ** 2 for x in self.intervals[node]) / len(self.intervals[node])
        std_dev = variance ** 0.5
        
        # è¨ˆç®— phi å€¼
        if std_dev == 0:
            return 0.0 if time_diff <= mean else float('inf')
        
        return -math.log10(self._probability(time_diff, mean, std_dev))
    
    def _probability(self,
                    time_diff: float,
                    mean: float,
                    std_dev: float) -> float:
        """è¨ˆç®—æ¦‚ç‡"""
        y = (time_diff - mean) / std_dev
        return 1.0 / (1.0 + math.exp(-y))
```

### 3.2 è‡ªå‹•æ¢å¾©

```python
from typing import Callable, Dict, List, Optional
import asyncio

class RecoveryManager:
    """æ¢å¾©ç®¡ç†å™¨"""
    def __init__(self,
                 node_id: str,
                 nodes: List[str]):
        self.node_id = node_id
        self.nodes = nodes
        self.state: Dict = {}
        self.handlers: Dict[str, Callable] = {}
    
    def register_handler(self,
                        event_type: str,
                        handler: Callable):
        """è¨»å†Šè™•ç†å™¨"""
        self.handlers[event_type] = handler
    
    async def handle_failure(self,
                           failed_node: str,
                           event_type: str):
        """è™•ç†æ•…éšœ"""
        if event_type in self.handlers:
            await self.handlers[event_type](failed_node)
    
    async def recover_state(self) -> bool:
        """æ¢å¾©ç‹€æ…‹"""
        try:
            # å¾å…¶ä»–ç¯€é»ç²å–ç‹€æ…‹
            for node in self.nodes:
                if node != self.node_id:
                    state = await self._fetch_state(node)
                    if state:
                        self.state = state
                        return True
            return False
        except Exception:
            return False
    
    async def _fetch_state(self,
                          node: str) -> Optional[Dict]:
        """ç²å–ç‹€æ…‹"""
        # å¯¦ç¾ç‹€æ…‹ç²å–é‚è¼¯
        pass

class StateReplicator:
    """ç‹€æ…‹è¤‡è£½å™¨"""
    def __init__(self,
                 node_id: str,
                 nodes: List[str]):
        self.node_id = node_id
        self.nodes = nodes
        self.state: Dict = {}
        self.version = 0
    
    async def update_state(self,
                          key: str,
                          value: Any) -> bool:
        """æ›´æ–°ç‹€æ…‹"""
        # æ›´æ–°æœ¬åœ°ç‹€æ…‹
        self.state[key] = value
        self.version += 1
        
        # è¤‡è£½åˆ°å…¶ä»–ç¯€é»
        tasks = [
            self._replicate_state(node, key, value, self.version)
            for node in self.nodes
            if node != self.node_id
        ]
        
        # ç­‰å¾…ç¢ºèª
        results = await asyncio.gather(*tasks)
        return all(results)
    
    async def _replicate_state(self,
                             node: str,
                             key: str,
                             value: Any,
                             version: int) -> bool:
        """è¤‡è£½ç‹€æ…‹"""
        # å¯¦ç¾ç‹€æ…‹è¤‡è£½é‚è¼¯
        pass
```

## ç·´ç¿’é¡Œ ğŸƒâ€â™‚ï¸

1. å¯¦ç¾åˆ†å¸ƒå¼å”èª¿ç³»çµ±ï¼š
   - æœå‹™ç™¼ç¾
   - é…ç½®ç®¡ç†
   - é ˜å°è€…é¸èˆ‰
   - åˆ†å¸ƒå¼é–
   - äº‹ä»¶é€šçŸ¥

2. é–‹ç™¼ä¸€è‡´æ€§å”è­°ï¼š
   - å…±è­˜ç®—æ³•
   - æ—¥èªŒè¤‡è£½
   - ç‹€æ…‹æ©Ÿè¤‡è£½
   - æˆå“¡ç®¡ç†
   - æ•…éšœæ¢å¾©

3. å¯¦ç¾å®¹éŒ¯æ©Ÿåˆ¶ï¼š
   - æ•…éšœæª¢æ¸¬
   - è‡ªå‹•æ¢å¾©
   - æ•¸æ“šå‚™ä»½
   - è² è¼‰å‡è¡¡
   - ç†±å‚™åˆ‡æ›

4. å‰µå»ºç›£æ§ç³»çµ±ï¼š
   - ç¯€é»ç›£æ§
   - æ€§èƒ½ç›£æ§
   - æ•…éšœå‘Šè­¦
   - æ—¥èªŒåˆ†æ
   - æŒ‡æ¨™æ”¶é›†

5. é–‹ç™¼æ¸¬è©¦æ¡†æ¶ï¼š
   - ä¸€è‡´æ€§æ¸¬è©¦
   - å®¹éŒ¯æ¸¬è©¦
   - æ€§èƒ½æ¸¬è©¦
   - å£“åŠ›æ¸¬è©¦
   - æ•…éšœæ³¨å…¥

## å°çµ ğŸ“

- äº†è§£äº†åˆ†å¸ƒå¼ç³»çµ±çš„æ ¸å¿ƒæ¦‚å¿µ
- æŒæ¡äº†åˆ†å¸ƒå¼å”èª¿çš„å¯¦ç¾æ–¹æ³•
- å­¸æœƒäº†ä¸€è‡´æ€§ç®—æ³•çš„æ‡‰ç”¨
- ç†è§£äº†å®¹éŒ¯è™•ç†çš„é‡è¦æ€§
- æŒæ¡äº†åˆ†å¸ƒå¼ç³»çµ±çš„æœ€ä½³å¯¦è¸

## å»¶ä¼¸é–±è®€ ğŸ“š

1. åˆ†å¸ƒå¼ç³»çµ±åŸç†
2. ä¸€è‡´æ€§ç®—æ³•å¯¦ç¾
3. ZooKeeper æ¬Šå¨æŒ‡å—
4. åˆ†å¸ƒå¼å”è­°èˆ‡ç®—æ³•
5. å®¹éŒ¯ç³»çµ±è¨­è¨ˆ

[ä¸Šä¸€ç« ï¼šç³»çµ±å¯è§€æ¸¬æ€§](142_ç³»çµ±å¯è§€æ¸¬æ€§.md) | [ä¸‹ä¸€ç« ï¼šé«˜å¯ç”¨æ¶æ§‹è¨­è¨ˆ](144_é«˜å¯ç”¨æ¶æ§‹è¨­è¨ˆ.md) 