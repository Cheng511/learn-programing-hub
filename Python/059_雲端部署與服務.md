[ä¸Šä¸€ç« ï¼šè‡ªå‹•åŒ–é‹ç¶­](058_è‡ªå‹•åŒ–é‹ç¶­.md) | [ä¸‹ä¸€ç« ï¼šPythonæ€§èƒ½å„ªåŒ–](060_Pythonæ€§èƒ½å„ªåŒ–.md)

# Python é›²ç«¯éƒ¨ç½²èˆ‡æœå‹™ â˜ï¸

## Dockerå®¹å™¨åŒ–

### 1. åŸºç¤é…ç½®

```python
# requirements.txt
flask==2.0.1
gunicorn==20.1.0
redis==3.5.3
sqlalchemy==1.4.23
```

```dockerfile
# Dockerfile
FROM python:3.9-slim

WORKDIR /app

COPY requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt

COPY . .

EXPOSE 5000

CMD ["gunicorn", "--bind", "0.0.0.0:5000", "app:app"]
```

```yaml
# docker-compose.yml
version: '3'

services:
  web:
    build: .
    ports:
      - "5000:5000"
    environment:
      - FLASK_ENV=production
    depends_on:
      - redis
      - db
  
  redis:
    image: redis:alpine
    ports:
      - "6379:6379"
  
  db:
    image: postgres:13
    environment:
      - POSTGRES_USER=myapp
      - POSTGRES_PASSWORD=mypassword
      - POSTGRES_DB=myapp
    ports:
      - "5432:5432"
    volumes:
      - postgres_data:/var/lib/postgresql/data

volumes:
  postgres_data:
```

### 2. æ‡‰ç”¨ç¨‹åº

```python
from flask import Flask, jsonify
from redis import Redis
from sqlalchemy import create_engine
import os

app = Flask(__name__)
redis = Redis(host='redis', port=6379)
db_url = 'postgresql://myapp:mypassword@db:5432/myapp'
engine = create_engine(db_url)

@app.route('/')
def hello():
    redis.incr('hits')
    return jsonify({
        'message': 'Hello, Docker!',
        'visits': int(redis.get('hits'))
    })

@app.route('/health')
def health():
    try:
        # æª¢æŸ¥Redisé€£æ¥
        redis.ping()
        # æª¢æŸ¥æ•¸æ“šåº«é€£æ¥
        with engine.connect() as conn:
            conn.execute("SELECT 1")
        return jsonify({'status': 'healthy'})
    except Exception as e:
        return jsonify({'status': 'unhealthy', 'error': str(e)}), 500

if __name__ == '__main__':
    app.run(host='0.0.0.0')
```

## AWSéƒ¨ç½²

### 1. AWS SDKä½¿ç”¨

```python
import boto3
from typing import Dict, List
import json

class AWSManager:
    def __init__(self, region: str = 'us-west-2'):
        self.ec2 = boto3.client('ec2', region_name=region)
        self.s3 = boto3.client('s3')
        self.rds = boto3.client('rds', region_name=region)
    
    def create_ec2_instance(self, instance_type: str = 't2.micro') -> Dict:
        """å‰µå»ºEC2å¯¦ä¾‹"""
        try:
            response = self.ec2.run_instances(
                ImageId='ami-0c55b159cbfafe1f0',  # Amazon Linux 2 AMI ID
                InstanceType=instance_type,
                MinCount=1,
                MaxCount=1,
                SecurityGroups=['default'],
                UserData='''#!/bin/bash
                    yum update -y
                    yum install -y docker
                    service docker start
                    usermod -a -G docker ec2-user
                '''
            )
            return response['Instances'][0]
        except Exception as e:
            print(f'å‰µå»ºEC2å¯¦ä¾‹å¤±æ•—: {e}')
            return {}
    
    def create_s3_bucket(self, bucket_name: str) -> bool:
        """å‰µå»ºS3å­˜å„²æ¡¶"""
        try:
            self.s3.create_bucket(
                Bucket=bucket_name,
                CreateBucketConfiguration={
                    'LocationConstraint': 'us-west-2'
                }
            )
            return True
        except Exception as e:
            print(f'å‰µå»ºS3å­˜å„²æ¡¶å¤±æ•—: {e}')
            return False
    
    def upload_to_s3(self, file_path: str, bucket: str,
                     object_name: str = None) -> bool:
        """ä¸Šå‚³æ–‡ä»¶åˆ°S3"""
        if object_name is None:
            object_name = file_path
        
        try:
            self.s3.upload_file(file_path, bucket, object_name)
            return True
        except Exception as e:
            print(f'ä¸Šå‚³æ–‡ä»¶å¤±æ•—: {e}')
            return False
    
    def create_rds_instance(self, db_instance_id: str,
                          db_name: str) -> Dict:
        """å‰µå»ºRDSå¯¦ä¾‹"""
        try:
            response = self.rds.create_db_instance(
                DBInstanceIdentifier=db_instance_id,
                DBName=db_name,
                Engine='postgres',
                EngineVersion='13.4',
                DBInstanceClass='db.t3.micro',
                MasterUsername='myapp',
                MasterUserPassword='mypassword',
                AllocatedStorage=20
            )
            return response['DBInstance']
        except Exception as e:
            print(f'å‰µå»ºRDSå¯¦ä¾‹å¤±æ•—: {e}')
            return {}

# ä½¿ç”¨ç¤ºä¾‹
def deploy_to_aws():
    aws = AWSManager()
    
    # å‰µå»ºEC2å¯¦ä¾‹
    instance = aws.create_ec2_instance()
    print('EC2å¯¦ä¾‹å·²å‰µå»º:', instance.get('InstanceId'))
    
    # å‰µå»ºS3å­˜å„²æ¡¶
    bucket_name = 'myapp-artifacts'
    if aws.create_s3_bucket(bucket_name):
        print(f'S3å­˜å„²æ¡¶ {bucket_name} å·²å‰µå»º')
        
        # ä¸Šå‚³æ‡‰ç”¨æ–‡ä»¶
        aws.upload_to_s3('app.py', bucket_name)
        aws.upload_to_s3('requirements.txt', bucket_name)
        aws.upload_to_s3('Dockerfile', bucket_name)
    
    # å‰µå»ºRDSæ•¸æ“šåº«
    db = aws.create_rds_instance('myapp-db', 'myappdb')
    print('RDSå¯¦ä¾‹å·²å‰µå»º:', db.get('DBInstanceIdentifier'))

if __name__ == '__main__':
    deploy_to_aws()
```

### 2. è‡ªå‹•åŒ–éƒ¨ç½²

```python
import paramiko
import time
from typing import Dict, List
import os

class DeploymentManager:
    def __init__(self, host: str, username: str, key_path: str):
        self.host = host
        self.username = username
        self.key_path = key_path
        self.ssh = None
    
    def connect(self):
        """å»ºç«‹SSHé€£æ¥"""
        try:
            key = paramiko.RSAKey.from_private_key_file(self.key_path)
            self.ssh = paramiko.SSHClient()
            self.ssh.set_missing_host_key_policy(paramiko.AutoAddPolicy())
            self.ssh.connect(self.host, username=self.username, pkey=key)
            return True
        except Exception as e:
            print(f'SSHé€£æ¥å¤±æ•—: {e}')
            return False
    
    def execute_command(self, command: str) -> Dict:
        """åŸ·è¡Œé ç¨‹å‘½ä»¤"""
        if not self.ssh:
            return {'error': 'Not connected'}
        
        try:
            stdin, stdout, stderr = self.ssh.exec_command(command)
            return {
                'stdout': stdout.read().decode(),
                'stderr': stderr.read().decode(),
                'exit_code': stdout.channel.recv_exit_status()
            }
        except Exception as e:
            return {'error': str(e)}
    
    def deploy_application(self):
        """éƒ¨ç½²æ‡‰ç”¨"""
        commands = [
            # æ›´æ–°ç³»çµ±
            'sudo yum update -y',
            
            # å®‰è£Docker
            'sudo amazon-linux-extras install docker -y',
            'sudo service docker start',
            'sudo usermod -a -G docker ec2-user',
            
            # å®‰è£Docker Compose
            'sudo curl -L "https://github.com/docker/compose/releases/download/1.29.2/docker-compose-$(uname -s)-$(uname -m)" -o /usr/local/bin/docker-compose',
            'sudo chmod +x /usr/local/bin/docker-compose',
            
            # å‰µå»ºæ‡‰ç”¨ç›®éŒ„
            'mkdir -p ~/myapp',
            
            # ä¸‹è¼‰æ‡‰ç”¨æ–‡ä»¶
            'aws s3 cp s3://myapp-artifacts/app.py ~/myapp/',
            'aws s3 cp s3://myapp-artifacts/requirements.txt ~/myapp/',
            'aws s3 cp s3://myapp-artifacts/Dockerfile ~/myapp/',
            'aws s3 cp s3://myapp-artifacts/docker-compose.yml ~/myapp/',
            
            # æ§‹å»ºå’Œé‹è¡Œå®¹å™¨
            'cd ~/myapp && docker-compose up -d'
        ]
        
        for command in commands:
            print(f'åŸ·è¡Œå‘½ä»¤: {command}')
            result = self.execute_command(command)
            
            if 'error' in result:
                print(f'å‘½ä»¤å¤±æ•—: {result["error"]}')
                return False
            
            if result['exit_code'] != 0:
                print(f'å‘½ä»¤å¤±æ•—: {result["stderr"]}')
                return False
            
            print(result['stdout'])
        
        return True
    
    def check_deployment(self) -> bool:
        """æª¢æŸ¥éƒ¨ç½²ç‹€æ…‹"""
        result = self.execute_command('docker ps')
        return 'myapp' in result.get('stdout', '')
    
    def close(self):
        """é—œé–‰SSHé€£æ¥"""
        if self.ssh:
            self.ssh.close()

# ä½¿ç”¨ç¤ºä¾‹
def main():
    # éƒ¨ç½²é…ç½®
    config = {
        'host': 'ec2-xx-xx-xx-xx.us-west-2.compute.amazonaws.com',
        'username': 'ec2-user',
        'key_path': '~/myapp-key.pem'
    }
    
    # å‰µå»ºéƒ¨ç½²ç®¡ç†å™¨
    deployer = DeploymentManager(**config)
    
    try:
        # é€£æ¥åˆ°æœå‹™å™¨
        if not deployer.connect():
            return
        
        # éƒ¨ç½²æ‡‰ç”¨
        print('é–‹å§‹éƒ¨ç½²æ‡‰ç”¨...')
        if deployer.deploy_application():
            print('æ‡‰ç”¨éƒ¨ç½²æˆåŠŸ')
            
            # æª¢æŸ¥éƒ¨ç½²ç‹€æ…‹
            if deployer.check_deployment():
                print('æ‡‰ç”¨æ­£åœ¨é‹è¡Œ')
            else:
                print('æ‡‰ç”¨æœªæ­£å¸¸é‹è¡Œ')
        else:
            print('æ‡‰ç”¨éƒ¨ç½²å¤±æ•—')
    
    finally:
        deployer.close()

if __name__ == '__main__':
    main()
```

## ç›£æ§èˆ‡æ—¥èªŒ

### 1. CloudWatchæ•´åˆ

```python
import boto3
from datetime import datetime, timedelta
from typing import Dict, List

class CloudWatchMonitor:
    def __init__(self, region: str = 'us-west-2'):
        self.cloudwatch = boto3.client('cloudwatch', region_name=region)
        self.logs = boto3.client('logs', region_name=region)
    
    def put_metric(self, namespace: str, metric_name: str,
                   value: float, unit: str = 'Count',
                   dimensions: List[Dict] = None):
        """ç™¼é€è‡ªå®šç¾©æŒ‡æ¨™"""
        try:
            metric_data = {
                'MetricName': metric_name,
                'Value': value,
                'Unit': unit,
                'Timestamp': datetime.utcnow()
            }
            
            if dimensions:
                metric_data['Dimensions'] = dimensions
            
            self.cloudwatch.put_metric_data(
                Namespace=namespace,
                MetricData=[metric_data]
            )
            return True
        except Exception as e:
            print(f'ç™¼é€æŒ‡æ¨™å¤±æ•—: {e}')
            return False
    
    def get_metric_statistics(self, namespace: str, metric_name: str,
                            period: int = 300,
                            hours: int = 1) -> List[Dict]:
        """ç²å–æŒ‡æ¨™çµ±è¨ˆæ•¸æ“š"""
        try:
            end_time = datetime.utcnow()
            start_time = end_time - timedelta(hours=hours)
            
            response = self.cloudwatch.get_metric_statistics(
                Namespace=namespace,
                MetricName=metric_name,
                StartTime=start_time,
                EndTime=end_time,
                Period=period,
                Statistics=['Average', 'Maximum', 'Minimum']
            )
            return response['Datapoints']
        except Exception as e:
            print(f'ç²å–æŒ‡æ¨™çµ±è¨ˆå¤±æ•—: {e}')
            return []
    
    def create_log_group(self, group_name: str) -> bool:
        """å‰µå»ºæ—¥èªŒçµ„"""
        try:
            self.logs.create_log_group(logGroupName=group_name)
            return True
        except Exception as e:
            print(f'å‰µå»ºæ—¥èªŒçµ„å¤±æ•—: {e}')
            return False
    
    def put_log_events(self, group_name: str, stream_name: str,
                      messages: List[str]):
        """ç™¼é€æ—¥èªŒäº‹ä»¶"""
        try:
            # ç¢ºä¿æ—¥èªŒæµå­˜åœ¨
            try:
                self.logs.create_log_stream(
                    logGroupName=group_name,
                    logStreamName=stream_name
                )
            except self.logs.exceptions.ResourceAlreadyExistsException:
                pass
            
            # æº–å‚™æ—¥èªŒäº‹ä»¶
            log_events = [
                {
                    'timestamp': int(datetime.utcnow().timestamp() * 1000),
                    'message': message
                }
                for message in messages
            ]
            
            # ç™¼é€æ—¥èªŒ
            self.logs.put_log_events(
                logGroupName=group_name,
                logStreamName=stream_name,
                logEvents=log_events
            )
            return True
        except Exception as e:
            print(f'ç™¼é€æ—¥èªŒå¤±æ•—: {e}')
            return False
    
    def get_log_events(self, group_name: str, stream_name: str,
                      hours: int = 1) -> List[Dict]:
        """ç²å–æ—¥èªŒäº‹ä»¶"""
        try:
            end_time = int(datetime.utcnow().timestamp() * 1000)
            start_time = end_time - (hours * 3600 * 1000)
            
            response = self.logs.get_log_events(
                logGroupName=group_name,
                logStreamName=stream_name,
                startTime=start_time,
                endTime=end_time
            )
            return response['events']
        except Exception as e:
            print(f'ç²å–æ—¥èªŒå¤±æ•—: {e}')
            return []

# ä½¿ç”¨ç¤ºä¾‹
def monitor_application():
    monitor = CloudWatchMonitor()
    
    # ç™¼é€è‡ªå®šç¾©æŒ‡æ¨™
    monitor.put_metric(
        namespace='MyApp',
        metric_name='RequestCount',
        value=100,
        dimensions=[
            {'Name': 'Environment', 'Value': 'Production'}
        ]
    )
    
    # å‰µå»ºæ—¥èªŒçµ„
    monitor.create_log_group('/myapp/production')
    
    # ç™¼é€æ—¥èªŒ
    monitor.put_log_events(
        group_name='/myapp/production',
        stream_name='application',
        messages=[
            'Application started',
            'Processing request',
            'Request completed'
        ]
    )
    
    # ç²å–æŒ‡æ¨™çµ±è¨ˆ
    stats = monitor.get_metric_statistics(
        namespace='MyApp',
        metric_name='RequestCount'
    )
    print('æŒ‡æ¨™çµ±è¨ˆ:', stats)
    
    # ç²å–æ—¥èªŒ
    logs = monitor.get_log_events(
        group_name='/myapp/production',
        stream_name='application'
    )
    print('æœ€è¿‘æ—¥èªŒ:', logs)

if __name__ == '__main__':
    monitor_application()
```

## ç·´ç¿’é¡Œ

1. **å®¹å™¨åŒ–Webæ‡‰ç”¨**
   å¯¦ç¾ä¸€å€‹å®¹å™¨åŒ–çš„Webæ‡‰ç”¨ï¼š
   - ä½¿ç”¨Flaskæ¡†æ¶
   - é…ç½®Dockerç’°å¢ƒ
   - å¯¦ç¾æ•¸æ“šæŒä¹…åŒ–
   - éƒ¨ç½²åˆ°é›²ç«¯

2. **è‡ªå‹•æ“´å±•ç³»çµ±**
   é–‹ç™¼ä¸€å€‹è‡ªå‹•æ“´å±•ç³»çµ±ï¼š
   - è² è¼‰ç›£æ§
   - è‡ªå‹•æ“´å±•è¦å‰‡
   - è³‡æºç®¡ç†
   - æˆæœ¬å„ªåŒ–

3. **å¤šç’°å¢ƒéƒ¨ç½²**
   å¯¦ç¾å¤šç’°å¢ƒéƒ¨ç½²æ–¹æ¡ˆï¼š
   - ç’°å¢ƒé…ç½®ç®¡ç†
   - éƒ¨ç½²æµç¨‹è‡ªå‹•åŒ–
   - å›æ»¾æ©Ÿåˆ¶
   - ç›£æ§å‘Šè­¦

## å°æé†’ ğŸ’¡

1. å®¹å™¨ç®¡ç†
   - é¡åƒå„ªåŒ–
   - è³‡æºé™åˆ¶
   - ç¶²çµ¡é…ç½®
   - å®‰å…¨è¨­ç½®

2. é›²ç«¯æœå‹™
   - æˆæœ¬æ§åˆ¶
   - æ¬Šé™ç®¡ç†
   - å‚™ä»½ç­–ç•¥
   - ç½é›£æ¢å¾©

3. ç›£æ§å‘Šè­¦
   - æ€§èƒ½ç›£æ§
   - æ—¥èªŒæ”¶é›†
   - å‘Šè­¦é–¾å€¼
   - éŸ¿æ‡‰æ©Ÿåˆ¶

4. æœ€ä½³å¯¦è¸
   - åŸºç¤è¨­æ–½å³ä»£ç¢¼
   - æŒçºŒé›†æˆ/éƒ¨ç½²
   - è‡ªå‹•åŒ–æ¸¬è©¦
   - æ–‡æª”ç¶­è­·

[ä¸Šä¸€ç« ï¼šè‡ªå‹•åŒ–é‹ç¶­](058_è‡ªå‹•åŒ–é‹ç¶­.md) | [ä¸‹ä¸€ç« ï¼šPythonæ€§èƒ½å„ªåŒ–](060_Pythonæ€§èƒ½å„ªåŒ–.md) 