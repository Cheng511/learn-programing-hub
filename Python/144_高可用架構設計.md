[ä¸Šä¸€ç« ï¼šåˆ†å¸ƒå¼ç³»çµ±è¨­è¨ˆ](143_åˆ†å¸ƒå¼ç³»çµ±è¨­è¨ˆ.md) | [ä¸‹ä¸€ç« ï¼šæ€§èƒ½å„ªåŒ–å¯¦è¸](145_æ€§èƒ½å„ªåŒ–å¯¦è¸.md)

# Python é«˜å¯ç”¨æ¶æ§‹è¨­è¨ˆ ğŸ—ï¸

## 1. å†—é¤˜è¨­è¨ˆ

### 1.1 æœå‹™å†—é¤˜

```python
from typing import Dict, List, Optional
import asyncio
import random

class ServiceInstance:
    """æœå‹™å¯¦ä¾‹"""
    def __init__(self,
                 instance_id: str,
                 host: str,
                 port: int):
        self.instance_id = instance_id
        self.host = host
        self.port = port
        self.healthy = True
        self.last_heartbeat = time.time()

class ServiceRegistry:
    """æœå‹™è¨»å†Šä¸­å¿ƒ"""
    def __init__(self):
        self.services: Dict[str, List[ServiceInstance]] = {}
        self.health_check_interval = 5.0
    
    async def register_service(self,
                             service_name: str,
                             instance: ServiceInstance) -> bool:
        """è¨»å†Šæœå‹™"""
        if service_name not in self.services:
            self.services[service_name] = []
        
        # æª¢æŸ¥æ˜¯å¦å·²å­˜åœ¨
        for existing in self.services[service_name]:
            if existing.instance_id == instance.instance_id:
                return False
        
        self.services[service_name].append(instance)
        return True
    
    async def deregister_service(self,
                                service_name: str,
                                instance_id: str) -> bool:
        """è¨»éŠ·æœå‹™"""
        if service_name not in self.services:
            return False
        
        self.services[service_name] = [
            inst for inst in self.services[service_name]
            if inst.instance_id != instance_id
        ]
        return True
    
    async def get_service_instances(self,
                                  service_name: str) -> List[ServiceInstance]:
        """ç²å–æœå‹™å¯¦ä¾‹"""
        return self.services.get(service_name, [])
    
    async def start_health_check(self):
        """å•Ÿå‹•å¥åº·æª¢æŸ¥"""
        while True:
            await self._check_services()
            await asyncio.sleep(self.health_check_interval)
    
    async def _check_services(self):
        """æª¢æŸ¥æœå‹™å¥åº·ç‹€æ…‹"""
        current_time = time.time()
        
        for service_name, instances in self.services.items():
            for instance in instances:
                # æª¢æŸ¥æœ€å¾Œå¿ƒè·³æ™‚é–“
                if current_time - instance.last_heartbeat > 10.0:
                    instance.healthy = False
            
            # ç§»é™¤ä¸å¥åº·çš„å¯¦ä¾‹
            self.services[service_name] = [
                inst for inst in instances
                if inst.healthy
            ]
```

### 1.2 æ•¸æ“šå†—é¤˜

```python
from typing import Any, Dict, List, Optional
import asyncio
import hashlib

class DataNode:
    """æ•¸æ“šç¯€é»"""
    def __init__(self,
                 node_id: str,
                 capacity: int):
        self.node_id = node_id
        self.capacity = capacity
        self.used = 0
        self.data: Dict[str, Any] = {}
    
    def has_capacity(self, size: int) -> bool:
        """æª¢æŸ¥å®¹é‡"""
        return self.used + size <= self.capacity
    
    async def store_data(self,
                        key: str,
                        value: Any,
                        size: int) -> bool:
        """å­˜å„²æ•¸æ“š"""
        if not self.has_capacity(size):
            return False
        
        self.data[key] = value
        self.used += size
        return True
    
    async def get_data(self, key: str) -> Optional[Any]:
        """ç²å–æ•¸æ“š"""
        return self.data.get(key)

class ReplicationManager:
    """è¤‡è£½ç®¡ç†å™¨"""
    def __init__(self,
                 nodes: List[DataNode],
                 replicas: int = 3):
        self.nodes = nodes
        self.replicas = replicas
    
    def _get_node_hash(self,
                      key: str,
                      node: DataNode) -> int:
        """è¨ˆç®—ç¯€é»å“ˆå¸Œå€¼"""
        combined = f"{key}:{node.node_id}"
        return int(hashlib.md5(combined.encode()).hexdigest(), 16)
    
    def _select_nodes(self,
                     key: str,
                     size: int) -> List[DataNode]:
        """é¸æ“‡ç¯€é»"""
        # æ ¹æ“šå“ˆå¸Œå€¼æ’åºç¯€é»
        nodes = sorted(
            self.nodes,
            key=lambda n: self._get_node_hash(key, n)
        )
        
        # é¸æ“‡æœ‰è¶³å¤ å®¹é‡çš„ç¯€é»
        selected = []
        for node in nodes:
            if node.has_capacity(size):
                selected.append(node)
                if len(selected) >= self.replicas:
                    break
        
        return selected
    
    async def store_with_replication(self,
                                   key: str,
                                   value: Any,
                                   size: int) -> bool:
        """è¤‡è£½å­˜å„²"""
        nodes = self._select_nodes(key, size)
        if len(nodes) < self.replicas:
            return False
        
        # ä¸¦è¡Œå­˜å„²åˆ°æ‰€æœ‰ç¯€é»
        tasks = [
            node.store_data(key, value, size)
            for node in nodes
        ]
        
        results = await asyncio.gather(*tasks)
        return all(results)
    
    async def get_with_fallback(self,
                               key: str) -> Optional[Any]:
        """å¸¶æ•…éšœè½‰ç§»çš„è®€å–"""
        nodes = self._select_nodes(key, 0)
        
        # å˜—è©¦å¾æ¯å€‹ç¯€é»è®€å–
        for node in nodes:
            data = await node.get_data(key)
            if data is not None:
                return data
        
        return None
```

## 2. è² è¼‰å‡è¡¡

### 2.1 è² è¼‰å‡è¡¡å™¨

```python
from typing import Dict, List, Optional
import random
import time

class LoadBalancer:
    """è² è¼‰å‡è¡¡å™¨"""
    def __init__(self):
        self.servers: List[ServiceInstance] = []
        self.weights: Dict[str, float] = {}
        self.current_index = 0
    
    def add_server(self,
                  server: ServiceInstance,
                  weight: float = 1.0):
        """æ·»åŠ æœå‹™å™¨"""
        self.servers.append(server)
        self.weights[server.instance_id] = weight
    
    def remove_server(self,
                     instance_id: str):
        """ç§»é™¤æœå‹™å™¨"""
        self.servers = [
            s for s in self.servers
            if s.instance_id != instance_id
        ]
        self.weights.pop(instance_id, None)
    
    def get_server_round_robin(self) -> Optional[ServiceInstance]:
        """è¼ªè©¢ç®—æ³•"""
        if not self.servers:
            return None
        
        server = self.servers[self.current_index]
        self.current_index = (self.current_index + 1) % len(self.servers)
        return server
    
    def get_server_weighted_random(self) -> Optional[ServiceInstance]:
        """åŠ æ¬Šéš¨æ©Ÿç®—æ³•"""
        if not self.servers:
            return None
        
        total_weight = sum(self.weights.values())
        r = random.uniform(0, total_weight)
        
        current_weight = 0
        for server in self.servers:
            current_weight += self.weights[server.instance_id]
            if r <= current_weight:
                return server
        
        return self.servers[-1]
    
    def get_server_least_connections(self,
                                   connections: Dict[str, int]) -> Optional[ServiceInstance]:
        """æœ€å°é€£æ¥æ•¸ç®—æ³•"""
        if not self.servers:
            return None
        
        return min(
            self.servers,
            key=lambda s: connections.get(s.instance_id, 0)
        )

class DynamicLoadBalancer(LoadBalancer):
    """å‹•æ…‹è² è¼‰å‡è¡¡å™¨"""
    def __init__(self):
        super().__init__()
        self.metrics: Dict[str, Dict] = {}
    
    def update_metrics(self,
                      instance_id: str,
                      cpu_usage: float,
                      memory_usage: float,
                      response_time: float):
        """æ›´æ–°æŒ‡æ¨™"""
        self.metrics[instance_id] = {
            'cpu_usage': cpu_usage,
            'memory_usage': memory_usage,
            'response_time': response_time,
            'timestamp': time.time()
        }
    
    def _calculate_score(self,
                        metrics: Dict) -> float:
        """è¨ˆç®—å¾—åˆ†"""
        cpu_weight = 0.4
        memory_weight = 0.3
        response_weight = 0.3
        
        return (
            cpu_weight * (1 - metrics['cpu_usage']) +
            memory_weight * (1 - metrics['memory_usage']) +
            response_weight * (1 / (1 + metrics['response_time']))
        )
    
    def get_server_dynamic(self) -> Optional[ServiceInstance]:
        """å‹•æ…‹è² è¼‰å‡è¡¡"""
        if not self.servers:
            return None
        
        # è¨ˆç®—æ¯å€‹æœå‹™å™¨çš„å¾—åˆ†
        scores = {}
        current_time = time.time()
        
        for server in self.servers:
            metrics = self.metrics.get(server.instance_id)
            if metrics and current_time - metrics['timestamp'] < 60:
                scores[server.instance_id] = self._calculate_score(metrics)
            else:
                scores[server.instance_id] = 0
        
        # é¸æ“‡å¾—åˆ†æœ€é«˜çš„æœå‹™å™¨
        return max(
            self.servers,
            key=lambda s: scores[s.instance_id]
        )
```

## 3. æ•…éšœè½‰ç§»

### 3.1 æ•…éšœæª¢æ¸¬

```python
from typing import Callable, Dict, List, Optional
import asyncio
import time

class HealthChecker:
    """å¥åº·æª¢æŸ¥å™¨"""
    def __init__(self,
                 check_interval: float = 5.0,
                 timeout: float = 1.0,
                 failure_threshold: int = 3):
        self.check_interval = check_interval
        self.timeout = timeout
        self.failure_threshold = failure_threshold
        self.failures: Dict[str, int] = {}
        self.handlers: Dict[str, Callable] = {}
    
    def register_check(self,
                      instance_id: str,
                      check_func: Callable,
                      failure_handler: Callable):
        """è¨»å†Šæª¢æŸ¥"""
        self.handlers[instance_id] = {
            'check': check_func,
            'failure': failure_handler
        }
        self.failures[instance_id] = 0
    
    async def start(self):
        """å•Ÿå‹•å¥åº·æª¢æŸ¥"""
        while True:
            await self._check_all()
            await asyncio.sleep(self.check_interval)
    
    async def _check_all(self):
        """æª¢æŸ¥æ‰€æœ‰å¯¦ä¾‹"""
        for instance_id, handlers in self.handlers.items():
            try:
                # åŸ·è¡Œå¥åº·æª¢æŸ¥
                success = await asyncio.wait_for(
                    handlers['check'](),
                    timeout=self.timeout
                )
                
                if success:
                    self.failures[instance_id] = 0
                else:
                    await self._handle_failure(instance_id)
            except asyncio.TimeoutError:
                await self._handle_failure(instance_id)
    
    async def _handle_failure(self,
                            instance_id: str):
        """è™•ç†æ•…éšœ"""
        self.failures[instance_id] += 1
        
        if self.failures[instance_id] >= self.failure_threshold:
            # èª¿ç”¨æ•…éšœè™•ç†å™¨
            await self.handlers[instance_id]['failure'](instance_id)
```

### 3.2 è‡ªå‹•æ¢å¾©

```python
from typing import Dict, List, Optional
import asyncio

class FailoverManager:
    """æ•…éšœè½‰ç§»ç®¡ç†å™¨"""
    def __init__(self,
                 registry: ServiceRegistry,
                 load_balancer: LoadBalancer):
        self.registry = registry
        self.load_balancer = load_balancer
        self.backup_pools: Dict[str, List[ServiceInstance]] = {}
    
    async def handle_failure(self,
                           service_name: str,
                           failed_instance: ServiceInstance):
        """è™•ç†æ•…éšœ"""
        # å¾è² è¼‰å‡è¡¡å™¨ç§»é™¤å¯¦ä¾‹
        self.load_balancer.remove_server(failed_instance.instance_id)
        
        # å˜—è©¦å•Ÿå‹•å‚™ç”¨å¯¦ä¾‹
        await self._activate_backup(service_name)
        
        # å˜—è©¦æ¢å¾©å¤±æ•—çš„å¯¦ä¾‹
        asyncio.create_task(
            self._try_recover(service_name, failed_instance)
        )
    
    async def _activate_backup(self,
                             service_name: str) -> bool:
        """å•Ÿå‹•å‚™ç”¨å¯¦ä¾‹"""
        if service_name not in self.backup_pools:
            return False
        
        if not self.backup_pools[service_name]:
            return False
        
        # ç²å–å‚™ç”¨å¯¦ä¾‹
        backup = self.backup_pools[service_name].pop(0)
        
        # è¨»å†Šä¸¦æ·»åŠ åˆ°è² è¼‰å‡è¡¡å™¨
        await self.registry.register_service(service_name, backup)
        self.load_balancer.add_server(backup)
        
        return True
    
    async def _try_recover(self,
                          service_name: str,
                          instance: ServiceInstance):
        """å˜—è©¦æ¢å¾©å¯¦ä¾‹"""
        max_attempts = 3
        attempt = 0
        
        while attempt < max_attempts:
            try:
                # å˜—è©¦é‡å•Ÿå¯¦ä¾‹
                success = await self._restart_instance(instance)
                
                if success:
                    # é‡æ–°è¨»å†Šå¯¦ä¾‹
                    await self.registry.register_service(
                        service_name,
                        instance
                    )
                    self.load_balancer.add_server(instance)
                    return True
            except Exception:
                pass
            
            attempt += 1
            await asyncio.sleep(5 * attempt)
        
        return False
    
    async def _restart_instance(self,
                              instance: ServiceInstance) -> bool:
        """é‡å•Ÿå¯¦ä¾‹"""
        # å¯¦ç¾å¯¦ä¾‹é‡å•Ÿé‚è¼¯
        pass
```

## 4. ç›£æ§å‘Šè­¦

### 4.1 æŒ‡æ¨™æ”¶é›†

```python
from typing import Dict, List, Optional
import time
import statistics

class MetricsCollector:
    """æŒ‡æ¨™æ”¶é›†å™¨"""
    def __init__(self):
        self.metrics: Dict[str, List[float]] = {}
        self.window_size = 60  # 1åˆ†é˜çª—å£
    
    def record_metric(self,
                     name: str,
                     value: float):
        """è¨˜éŒ„æŒ‡æ¨™"""
        if name not in self.metrics:
            self.metrics[name] = []
        
        self.metrics[name].append({
            'value': value,
            'timestamp': time.time()
        })
        
        # æ¸…ç†éæœŸæ•¸æ“š
        self._cleanup(name)
    
    def _cleanup(self, name: str):
        """æ¸…ç†éæœŸæ•¸æ“š"""
        current_time = time.time()
        self.metrics[name] = [
            m for m in self.metrics[name]
            if current_time - m['timestamp'] <= self.window_size
        ]
    
    def get_average(self, name: str) -> Optional[float]:
        """ç²å–å¹³å‡å€¼"""
        if name not in self.metrics:
            return None
        
        values = [m['value'] for m in self.metrics[name]]
        return statistics.mean(values) if values else None
    
    def get_percentile(self,
                      name: str,
                      p: float) -> Optional[float]:
        """ç²å–ç™¾åˆ†ä½æ•¸"""
        if name not in self.metrics:
            return None
        
        values = [m['value'] for m in self.metrics[name]]
        if not values:
            return None
        
        return statistics.quantiles(values, n=100)[int(p * 100) - 1]

class AlertManager:
    """å‘Šè­¦ç®¡ç†å™¨"""
    def __init__(self,
                 collector: MetricsCollector):
        self.collector = collector
        self.rules: Dict[str, Dict] = {}
        self.alerts: List[Dict] = []
    
    def add_rule(self,
                 name: str,
                 metric: str,
                 threshold: float,
                 window: int = 60,
                 condition: str = 'above'):
        """æ·»åŠ è¦å‰‡"""
        self.rules[name] = {
            'metric': metric,
            'threshold': threshold,
            'window': window,
            'condition': condition
        }
    
    async def check_rules(self):
        """æª¢æŸ¥è¦å‰‡"""
        for name, rule in self.rules.items():
            value = self.collector.get_average(rule['metric'])
            if value is None:
                continue
            
            triggered = (
                rule['condition'] == 'above' and value > rule['threshold']
            ) or (
                rule['condition'] == 'below' and value < rule['threshold']
            )
            
            if triggered:
                self._create_alert(name, rule, value)
    
    def _create_alert(self,
                     rule_name: str,
                     rule: Dict,
                     value: float):
        """å‰µå»ºå‘Šè­¦"""
        alert = {
            'rule_name': rule_name,
            'metric': rule['metric'],
            'value': value,
            'threshold': rule['threshold'],
            'timestamp': time.time()
        }
        
        self.alerts.append(alert)
```

## ç·´ç¿’é¡Œ ğŸƒâ€â™‚ï¸

1. å¯¦ç¾é«˜å¯ç”¨ç³»çµ±ï¼š
   - æœå‹™è¨»å†Šèˆ‡ç™¼ç¾
   - å¥åº·æª¢æŸ¥æ©Ÿåˆ¶
   - æ•…éšœè½‰ç§»ç­–ç•¥
   - æ•¸æ“šè¤‡è£½æ–¹æ¡ˆ
   - ç›£æ§å‘Šè­¦ç³»çµ±

2. é–‹ç™¼è² è¼‰å‡è¡¡å™¨ï¼š
   - è¼ªè©¢ç®—æ³•
   - åŠ æ¬Šéš¨æ©Ÿ
   - æœ€å°é€£æ¥æ•¸
   - å‹•æ…‹è² è¼‰å‡è¡¡
   - æœƒè©±ä¿æŒ

3. å¯¦ç¾æ•…éšœæ¢å¾©ï¼š
   - æ•…éšœæª¢æ¸¬
   - è‡ªå‹•æ¢å¾©
   - å‚™ä»½ç®¡ç†
   - æ—¥èªŒåˆ†æ
   - æ€§èƒ½å„ªåŒ–

4. å‰µå»ºç›£æ§ç³»çµ±ï¼š
   - æŒ‡æ¨™æ”¶é›†
   - æ•¸æ“šåˆ†æ
   - å‘Šè­¦è¦å‰‡
   - é€šçŸ¥æ©Ÿåˆ¶
   - å¯è¦–åŒ–å±•ç¤º

5. é–‹ç™¼æ¸¬è©¦æ–¹æ¡ˆï¼š
   - å£“åŠ›æ¸¬è©¦
   - æ•…éšœæ³¨å…¥
   - æ€§èƒ½åŸºæº–
   - å¯ç”¨æ€§æ¸¬è©¦
   - æ¢å¾©æ¼”ç·´

## å°çµ ğŸ“

- äº†è§£äº†é«˜å¯ç”¨æ¶æ§‹çš„æ ¸å¿ƒæ¦‚å¿µ
- æŒæ¡äº†å†—é¤˜è¨­è¨ˆçš„å¯¦ç¾æ–¹æ³•
- å­¸æœƒäº†è² è¼‰å‡è¡¡çš„å¤šç¨®ç­–ç•¥
- ç†è§£äº†æ•…éšœè½‰ç§»çš„é‡è¦æ€§
- æŒæ¡äº†ç›£æ§å‘Šè­¦çš„æœ€ä½³å¯¦è¸

## å»¶ä¼¸é–±è®€ ğŸ“š

1. é«˜å¯ç”¨æ¶æ§‹è¨­è¨ˆ
2. è² è¼‰å‡è¡¡æŠ€è¡“
3. åˆ†å¸ƒå¼ç³»çµ±ç›£æ§
4. æ•…éšœæ¢å¾©ç­–ç•¥
5. æ€§èƒ½å„ªåŒ–æŒ‡å—

[ä¸Šä¸€ç« ï¼šåˆ†å¸ƒå¼ç³»çµ±è¨­è¨ˆ](143_åˆ†å¸ƒå¼ç³»çµ±è¨­è¨ˆ.md) | [ä¸‹ä¸€ç« ï¼šæ€§èƒ½å„ªåŒ–å¯¦è¸](145_æ€§èƒ½å„ªåŒ–å¯¦è¸.md) 