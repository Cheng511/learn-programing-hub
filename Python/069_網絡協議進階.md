[ä¸Šä¸€ç« ï¼šç¶²çµ¡å”è­°åŸºç¤](068_ç¶²çµ¡å”è­°åŸºç¤.md) | [ä¸‹ä¸€ç« ï¼šç¶²çµ¡å®‰å…¨åŸºç¤](070_ç¶²çµ¡å®‰å…¨åŸºç¤.md)

# Python ç¶²çµ¡å”è­°é€²éš ğŸŒ

## SMTPå”è­°

### 1. SMTPå®¢æˆ¶ç«¯

```python
import smtplib
from email.mime.text import MIMEText
from email.mime.multipart import MIMEMultipart
from email.mime.application import MIMEApplication
from typing import List, Optional, Dict
import os

class SMTPClient:
    def __init__(self, host: str,
                 port: int = 587,
                 username: str = '',
                 password: str = '',
                 use_tls: bool = True):
        self.host = host
        self.port = port
        self.username = username
        self.password = password
        self.use_tls = use_tls
        self.smtp: Optional[smtplib.SMTP] = None
    
    def connect(self) -> bool:
        """é€£æ¥åˆ°SMTPæœå‹™å™¨"""
        try:
            self.smtp = smtplib.SMTP(self.host, self.port)
            if self.use_tls:
                self.smtp.starttls()
            self.smtp.login(self.username, self.password)
            print(f"Connected to {self.host}:{self.port}")
            return True
        except Exception as e:
            print(f"Connection failed: {e}")
            return False
    
    def send_email(self,
                  to_addrs: List[str],
                  subject: str,
                  body: str,
                  attachments: Optional[List[str]] = None,
                  html_body: Optional[str] = None) -> bool:
        """ç™¼é€é›»å­éƒµä»¶"""
        if not self.smtp:
            raise RuntimeError("Not connected")
        
        try:
            # å‰µå»ºéƒµä»¶
            msg = MIMEMultipart('alternative')
            msg['Subject'] = subject
            msg['From'] = self.username
            msg['To'] = ', '.join(to_addrs)
            
            # æ·»åŠ æ–‡æœ¬å…§å®¹
            msg.attach(MIMEText(body, 'plain'))
            
            # æ·»åŠ HTMLå…§å®¹
            if html_body:
                msg.attach(MIMEText(html_body, 'html'))
            
            # æ·»åŠ é™„ä»¶
            if attachments:
                for file_path in attachments:
                    if os.path.exists(file_path):
                        with open(file_path, 'rb') as f:
                            part = MIMEApplication(f.read())
                            part.add_header(
                                'Content-Disposition',
                                'attachment',
                                filename=os.path.basename(file_path)
                            )
                            msg.attach(part)
            
            # ç™¼é€éƒµä»¶
            self.smtp.send_message(msg)
            return True
        
        except Exception as e:
            print(f"Error sending email: {e}")
            return False
    
    def close(self):
        """é—œé–‰é€£æ¥"""
        if self.smtp:
            self.smtp.quit()

# ä½¿ç”¨ç¤ºä¾‹
def main():
    # å‰µå»ºSMTPå®¢æˆ¶ç«¯
    client = SMTPClient(
        host="smtp.gmail.com",
        username="your-email@gmail.com",
        password="your-app-password",
        use_tls=True
    )
    
    try:
        # é€£æ¥åˆ°æœå‹™å™¨
        if client.connect():
            # ç™¼é€éƒµä»¶
            success = client.send_email(
                to_addrs=["recipient@example.com"],
                subject="Test Email",
                body="This is a test email.",
                html_body="""
                    <html>
                        <body>
                            <h1>Test Email</h1>
                            <p>This is a test email.</p>
                        </body>
                    </html>
                """,
                attachments=["test.txt"]
            )
            
            if success:
                print("Email sent successfully")
            else:
                print("Failed to send email")
    
    finally:
        client.close()

if __name__ == '__main__':
    main()
```

### 2. SMTPæœå‹™å™¨

```python
from aiosmtpd.controller import Controller
from aiosmtpd.smtp import SMTP as SMTPServer
from email import message_from_bytes
from typing import Dict, List, Optional
import asyncio
import logging

class CustomSMTPHandler:
    def __init__(self):
        self.emails: List[Dict] = []
    
    async def handle_RCPT(self, server, session, envelope,
                         address, rcpt_options):
        """è™•ç†æ”¶ä»¶äºº"""
        if not address.endswith('@example.com'):
            return '550 not relaying to that domain'
        envelope.rcpt_tos.append(address)
        return '250 OK'
    
    async def handle_DATA(self, server, session, envelope):
        """è™•ç†éƒµä»¶å…§å®¹"""
        # è§£æéƒµä»¶
        email_message = message_from_bytes(envelope.content)
        
        # æå–éƒµä»¶ä¿¡æ¯
        email_data = {
            'from': envelope.mail_from,
            'to': envelope.rcpt_tos,
            'subject': email_message.get('subject', ''),
            'body': '',
            'attachments': []
        }
        
        # è™•ç†éƒµä»¶å…§å®¹
        for part in email_message.walk():
            if part.get_content_maintype() == 'multipart':
                continue
            
            if part.get_content_maintype() == 'text':
                email_data['body'] = part.get_content()
            elif part.get_content_maintype() == 'application':
                email_data['attachments'].append({
                    'filename': part.get_filename(),
                    'content': part.get_content()
                })
        
        # ä¿å­˜éƒµä»¶
        self.emails.append(email_data)
        
        # è¨˜éŒ„éƒµä»¶
        logging.info(f"Received email from {envelope.mail_from}")
        
        return '250 Message accepted for delivery'

class SMTPServer:
    def __init__(self, host: str = 'localhost',
                 port: int = 2525):
        self.host = host
        self.port = port
        self.controller: Optional[Controller] = None
        self.handler = CustomSMTPHandler()
    
    def start(self):
        """å•Ÿå‹•SMTPæœå‹™å™¨"""
        try:
            # å‰µå»ºæ§åˆ¶å™¨
            self.controller = Controller(
                self.handler,
                hostname=self.host,
                port=self.port
            )
            
            # å•Ÿå‹•æœå‹™å™¨
            self.controller.start()
            print(f"SMTP server running on {self.host}:{self.port}")
            
            # ä¿æŒæœå‹™å™¨é‹è¡Œ
            try:
                while True:
                    asyncio.sleep(1)
            except KeyboardInterrupt:
                print("\nServer shutting down...")
        
        except Exception as e:
            print(f"Error starting server: {e}")
        
        finally:
            if self.controller:
                self.controller.stop()

# ä½¿ç”¨ç¤ºä¾‹
if __name__ == '__main__':
    # é…ç½®æ—¥èªŒ
    logging.basicConfig(level=logging.INFO)
    
    # å•Ÿå‹•æœå‹™å™¨
    server = SMTPServer()
    server.start()
```

## DNSå”è­°

### 1. DNSå®¢æˆ¶ç«¯

```python
import dns.resolver
from typing import List, Dict, Optional
import socket

class DNSClient:
    def __init__(self, nameservers: Optional[List[str]] = None):
        self.resolver = dns.resolver.Resolver()
        if nameservers:
            self.resolver.nameservers = nameservers
    
    def resolve_a(self, domain: str) -> List[str]:
        """è§£æAè¨˜éŒ„"""
        try:
            answers = self.resolver.resolve(domain, 'A')
            return [str(rdata) for rdata in answers]
        except Exception as e:
            print(f"Error resolving A record: {e}")
            return []
    
    def resolve_aaaa(self, domain: str) -> List[str]:
        """è§£æAAAAè¨˜éŒ„"""
        try:
            answers = self.resolver.resolve(domain, 'AAAA')
            return [str(rdata) for rdata in answers]
        except Exception as e:
            print(f"Error resolving AAAA record: {e}")
            return []
    
    def resolve_mx(self, domain: str) -> List[Dict[str, str]]:
        """è§£æMXè¨˜éŒ„"""
        try:
            answers = self.resolver.resolve(domain, 'MX')
            return [
                {
                    'preference': str(rdata.preference),
                    'exchange': str(rdata.exchange)
                }
                for rdata in answers
            ]
        except Exception as e:
            print(f"Error resolving MX record: {e}")
            return []
    
    def resolve_txt(self, domain: str) -> List[str]:
        """è§£æTXTè¨˜éŒ„"""
        try:
            answers = self.resolver.resolve(domain, 'TXT')
            return [str(rdata[0]) for rdata in answers]
        except Exception as e:
            print(f"Error resolving TXT record: {e}")
            return []
    
    def reverse_lookup(self, ip: str) -> Optional[str]:
        """åå‘DNSæŸ¥è©¢"""
        try:
            return socket.gethostbyaddr(ip)[0]
        except Exception as e:
            print(f"Error performing reverse lookup: {e}")
            return None

# ä½¿ç”¨ç¤ºä¾‹
def main():
    # å‰µå»ºDNSå®¢æˆ¶ç«¯
    client = DNSClient()
    
    # æ¸¬è©¦åŸŸå
    domain = "example.com"
    
    # è§£æAè¨˜éŒ„
    print(f"\nA records for {domain}:")
    a_records = client.resolve_a(domain)
    for record in a_records:
        print(f"- {record}")
    
    # è§£æAAAAè¨˜éŒ„
    print(f"\nAAAA records for {domain}:")
    aaaa_records = client.resolve_aaaa(domain)
    for record in aaaa_records:
        print(f"- {record}")
    
    # è§£æMXè¨˜éŒ„
    print(f"\nMX records for {domain}:")
    mx_records = client.resolve_mx(domain)
    for record in mx_records:
        print(f"- Preference: {record['preference']}, "
              f"Exchange: {record['exchange']}")
    
    # è§£æTXTè¨˜éŒ„
    print(f"\nTXT records for {domain}:")
    txt_records = client.resolve_txt(domain)
    for record in txt_records:
        print(f"- {record}")
    
    # åå‘DNSæŸ¥è©¢
    ip = "93.184.216.34"
    print(f"\nReverse lookup for {ip}:")
    hostname = client.reverse_lookup(ip)
    if hostname:
        print(f"- {hostname}")

if __name__ == '__main__':
    main()
```

### 2. DNSæœå‹™å™¨

```python
from dnslib import *
from typing import Dict, List, Optional
import socket
import threading
import time

class DNSServer:
    def __init__(self, host: str = 'localhost',
                 port: int = 53):
        self.host = host
        self.port = port
        self.running = False
        self.records: Dict[str, List[RR]] = {}
    
    def add_record(self, name: str, rtype: str,
                  rdata: str, ttl: int = 300):
        """æ·»åŠ DNSè¨˜éŒ„"""
        if name not in self.records:
            self.records[name] = []
        
        # å‰µå»ºè¨˜éŒ„
        if rtype == 'A':
            record = RR(name, QTYPE.A, rdata=RR.A(rdata), ttl=ttl)
        elif rtype == 'AAAA':
            record = RR(name, QTYPE.AAAA, rdata=RR.AAAA(rdata), ttl=ttl)
        elif rtype == 'MX':
            preference, exchange = rdata.split()
            record = RR(name, QTYPE.MX,
                       rdata=RR.MX(int(preference), exchange),
                       ttl=ttl)
        elif rtype == 'TXT':
            record = RR(name, QTYPE.TXT,
                       rdata=RR.TXT(rdata),
                       ttl=ttl)
        else:
            raise ValueError(f"Unsupported record type: {rtype}")
        
        self.records[name].append(record)
    
    def handle_request(self, data: bytes,
                      address: tuple) -> Optional[bytes]:
        """è™•ç†DNSè«‹æ±‚"""
        try:
            # è§£æè«‹æ±‚
            request = DNSRecord.parse(data)
            
            # å‰µå»ºéŸ¿æ‡‰
            reply = DNSRecord(DNSHeader(id=request.header.id,
                                      qr=1,
                                      aa=1,
                                      ra=1),
                            request.question)
            
            # æŸ¥æ‰¾è¨˜éŒ„
            for question in request.question:
                name = str(question.qname)
                if name in self.records:
                    for record in self.records[name]:
                        if record.rtype == question.qtype:
                            reply.add_answer(record)
            
            return reply.pack()
        
        except Exception as e:
            print(f"Error handling request: {e}")
            return None
    
    def start(self):
        """å•Ÿå‹•DNSæœå‹™å™¨"""
        try:
            # å‰µå»ºUDP socket
            sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
            sock.bind((self.host, self.port))
            
            self.running = True
            print(f"DNS server running on {self.host}:{self.port}")
            
            while self.running:
                try:
                    # æ¥æ”¶è«‹æ±‚
                    data, address = sock.recvfrom(1024)
                    
                    # è™•ç†è«‹æ±‚
                    response = self.handle_request(data, address)
                    if response:
                        sock.sendto(response, address)
                
                except Exception as e:
                    print(f"Error processing request: {e}")
        
        except KeyboardInterrupt:
            print("\nServer shutting down...")
        
        finally:
            self.running = False
            sock.close()

# ä½¿ç”¨ç¤ºä¾‹
def main():
    # å‰µå»ºDNSæœå‹™å™¨
    server = DNSServer()
    
    # æ·»åŠ ç¤ºä¾‹è¨˜éŒ„
    server.add_record("example.com", "A", "93.184.216.34")
    server.add_record("example.com", "AAAA",
                     "2606:2800:220:1:248:1893:25c8:1946")
    server.add_record("example.com", "MX", "10 mail.example.com")
    server.add_record("example.com", "TXT",
                     "v=spf1 include:_spf.example.com ~all")
    
    # å•Ÿå‹•æœå‹™å™¨
    server.start()

if __name__ == '__main__':
    main()
```

## ç·´ç¿’é¡Œ

1. **éƒµä»¶æœå‹™å™¨**
   å¯¦ç¾ä¸€å€‹å®Œæ•´çš„éƒµä»¶æœå‹™å™¨ï¼š
   - æ”¯æŒSMTPå’ŒPOP3
   - å¯¦ç¾éƒµä»¶å­˜å„²
   - æ·»åŠ åƒåœ¾éƒµä»¶éæ¿¾
   - æ”¯æŒé™„ä»¶è™•ç†

2. **DNSä»£ç†æœå‹™å™¨**
   é–‹ç™¼ä¸€å€‹DNSä»£ç†æœå‹™å™¨ï¼š
   - ç·©å­˜DNSæŸ¥è©¢çµæœ
   - å¯¦ç¾è² è¼‰å‡è¡¡
   - æ·»åŠ è¨ªå•æ§åˆ¶
   - ç›£æ§æŸ¥è©¢çµ±è¨ˆ

3. **å”è­°åˆ†æå™¨**
   å‰µå»ºä¸€å€‹ç¶²çµ¡å”è­°åˆ†æå·¥å…·ï¼š
   - æ•ç²ä¸¦è§£ææ•¸æ“šåŒ…
   - è­˜åˆ¥å”è­°é¡å‹
   - æå–å”è­°å…§å®¹
   - ç”Ÿæˆåˆ†æå ±å‘Š

## å°æé†’ ğŸ’¡

1. å”è­°å¯¦ç¾
   - éµå¾ªæ¨™æº–è¦ç¯„
   - è™•ç†ç•°å¸¸æƒ…æ³
   - å¯¦ç¾é‡è©¦æ©Ÿåˆ¶
   - å„ªåŒ–æ€§èƒ½

2. å®‰å…¨æ€§
   - ä½¿ç”¨åŠ å¯†å‚³è¼¸
   - é©—è­‰æ•¸æ“šå®Œæ•´æ€§
   - é˜²æ­¢DNSæ¬ºé¨™
   - é™åˆ¶è¨ªå•æ¬Šé™

3. å¯é æ€§
   - å¯¦ç¾æ•…éšœè½‰ç§»
   - ç›£æ§æœå‹™ç‹€æ…‹
   - è¨˜éŒ„è©³ç´°æ—¥èªŒ
   - å®šæœŸå‚™ä»½æ•¸æ“š

4. èª¿è©¦æŠ€å·§
   - ä½¿ç”¨å”è­°åˆ†æå™¨
   - æ¨¡æ“¬ç¶²çµ¡ç’°å¢ƒ
   - å£“åŠ›æ¸¬è©¦
   - æ€§èƒ½ç›£æ§

[ä¸Šä¸€ç« ï¼šç¶²çµ¡å”è­°åŸºç¤](068_ç¶²çµ¡å”è­°åŸºç¤.md) | [ä¸‹ä¸€ç« ï¼šç¶²çµ¡å®‰å…¨åŸºç¤](070_ç¶²çµ¡å®‰å…¨åŸºç¤.md) 