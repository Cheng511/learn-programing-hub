[ä¸Šä¸€ç« ï¼šè¨ˆç®—æ©Ÿè¦–è¦ºé€²éš](103_è¨ˆç®—æ©Ÿè¦–è¦ºé€²éš.md) | [ä¸‹ä¸€ç« ï¼šæ©Ÿå™¨äººé€²éš](105_æ©Ÿå™¨äººé€²éš.md)

# Python æ©Ÿå™¨äººåŸºç¤ ğŸ¤–

## æ©Ÿå™¨äººæ§åˆ¶åŸºç¤

### 1. é‹å‹•æ§åˆ¶

```python
import numpy as np
from typing import Tuple, List, Optional, Dict
import time
import sys
import os

class RobotController:
    def __init__(self):
        """åˆå§‹åŒ–æ©Ÿå™¨äººæ§åˆ¶å™¨"""
        try:
            # åˆå§‹åŒ–æ©Ÿå™¨äººåƒæ•¸
            self.position = np.array([0.0, 0.0, 0.0])  # x, y, theta
            self.velocity = np.array([0.0, 0.0, 0.0])  # vx, vy, omega
            self.max_velocity = np.array([1.0, 1.0, np.pi/2])  # æœ€å¤§é€Ÿåº¦
            self.max_acceleration = np.array([0.5, 0.5, np.pi/4])  # æœ€å¤§åŠ é€Ÿåº¦
            
            print("Robot controller initialized")
            
        except Exception as e:
            print(f"Error initializing robot controller: {e}")
    
    def set_position(self, position: np.ndarray):
        """è¨­ç½®ä½ç½®"""
        try:
            if len(position) != 3:
                raise ValueError("Position must be a 3D vector")
            
            self.position = position
            print(f"Position set to: {position}")
            
        except Exception as e:
            print(f"Error setting position: {e}")
    
    def set_velocity(self, velocity: np.ndarray):
        """è¨­ç½®é€Ÿåº¦"""
        try:
            if len(velocity) != 3:
                raise ValueError("Velocity must be a 3D vector")
            
            # é™åˆ¶é€Ÿåº¦
            velocity = np.clip(velocity, -self.max_velocity, self.max_velocity)
            self.velocity = velocity
            print(f"Velocity set to: {velocity}")
            
        except Exception as e:
            print(f"Error setting velocity: {e}")
    
    def move_to_position(self, target_position: np.ndarray, duration: float = 1.0):
        """ç§»å‹•åˆ°æŒ‡å®šä½ç½®"""
        try:
            if len(target_position) != 3:
                raise ValueError("Target position must be a 3D vector")
            
            # è¨ˆç®—æ‰€éœ€é€Ÿåº¦
            displacement = target_position - self.position
            required_velocity = displacement / duration
            
            # é™åˆ¶åŠ é€Ÿåº¦
            current_velocity = self.velocity
            max_velocity_change = self.max_acceleration * duration
            velocity_change = np.clip(required_velocity - current_velocity,
                                    -max_velocity_change,
                                    max_velocity_change)
            
            # æ›´æ–°é€Ÿåº¦
            new_velocity = current_velocity + velocity_change
            self.set_velocity(new_velocity)
            
            # æ›´æ–°ä½ç½®
            self.position = target_position
            
            print(f"Moved to position: {target_position}")
            
        except Exception as e:
            print(f"Error moving to position: {e}")
    
    def rotate_to_angle(self, target_angle: float, duration: float = 1.0):
        """æ—‹è½‰åˆ°æŒ‡å®šè§’åº¦"""
        try:
            # è¨ˆç®—è§’åº¦å·®
            angle_diff = target_angle - self.position[2]
            
            # å°‡è§’åº¦å·®é™åˆ¶åœ¨[-pi, pi]ç¯„åœå…§
            while angle_diff > np.pi:
                angle_diff -= 2 * np.pi
            while angle_diff < -np.pi:
                angle_diff += 2 * np.pi
            
            # è¨ˆç®—æ‰€éœ€è§’é€Ÿåº¦
            required_omega = angle_diff / duration
            
            # é™åˆ¶è§’é€Ÿåº¦
            omega = np.clip(required_omega, -self.max_velocity[2], self.max_velocity[2])
            
            # æ›´æ–°è§’é€Ÿåº¦
            self.velocity[2] = omega
            
            # æ›´æ–°è§’åº¦
            self.position[2] = target_angle
            
            print(f"Rotated to angle: {target_angle}")
            
        except Exception as e:
            print(f"Error rotating to angle: {e}")
    
    def follow_path(self, path: List[np.ndarray], duration: float = 1.0):
        """è·Ÿéš¨è·¯å¾‘"""
        try:
            for target_position in path:
                self.move_to_position(target_position, duration)
                time.sleep(duration)
            
            print("Path following completed")
            
        except Exception as e:
            print(f"Error following path: {e}")
    
    def get_state(self) -> Dict:
        """ç²å–æ©Ÿå™¨äººç‹€æ…‹"""
        try:
            state = {
                'position': self.position.copy(),
                'velocity': self.velocity.copy()
            }
            return state
            
        except Exception as e:
            print(f"Error getting state: {e}")
            return {}

# ä½¿ç”¨ç¤ºä¾‹
def main():
    # å‰µå»ºæ©Ÿå™¨äººæ§åˆ¶å™¨
    controller = RobotController()
    
    try:
        # è¨­ç½®åˆå§‹ä½ç½®
        initial_position = np.array([0.0, 0.0, 0.0])
        controller.set_position(initial_position)
        
        # ç§»å‹•åˆ°ç›®æ¨™ä½ç½®
        target_position = np.array([1.0, 1.0, np.pi/4])
        controller.move_to_position(target_position)
        
        # æ—‹è½‰åˆ°ç›®æ¨™è§’åº¦
        target_angle = np.pi/2
        controller.rotate_to_angle(target_angle)
        
        # è·Ÿéš¨è·¯å¾‘
        path = [
            np.array([0.0, 0.0, 0.0]),
            np.array([1.0, 0.0, 0.0]),
            np.array([1.0, 1.0, 0.0]),
            np.array([0.0, 1.0, 0.0]),
            np.array([0.0, 0.0, 0.0])
        ]
        controller.follow_path(path)
        
        # ç²å–æœ€çµ‚ç‹€æ…‹
        final_state = controller.get_state()
        print(f"Final state: {final_state}")
    
    except Exception as e:
        print(f"Error in main: {e}")

if __name__ == '__main__':
    main()
```

### 2. å‚³æ„Ÿå™¨æ§åˆ¶

```python
import numpy as np
from typing import Tuple, List, Optional, Dict
import time
import sys
import os

class SensorController:
    def __init__(self):
        """åˆå§‹åŒ–å‚³æ„Ÿå™¨æ§åˆ¶å™¨"""
        try:
            # åˆå§‹åŒ–å‚³æ„Ÿå™¨åƒæ•¸
            self.sensor_data = {}
            self.sensor_rates = {}
            self.last_update = {}
            
            print("Sensor controller initialized")
            
        except Exception as e:
            print(f"Error initializing sensor controller: {e}")
    
    def add_sensor(self, sensor_id: str, update_rate: float = 10.0):
        """æ·»åŠ å‚³æ„Ÿå™¨"""
        try:
            self.sensor_data[sensor_id] = None
            self.sensor_rates[sensor_id] = update_rate
            self.last_update[sensor_id] = 0.0
            
            print(f"Sensor {sensor_id} added with update rate {update_rate} Hz")
            
        except Exception as e:
            print(f"Error adding sensor: {e}")
    
    def update_sensor(self, sensor_id: str, data: np.ndarray):
        """æ›´æ–°å‚³æ„Ÿå™¨æ•¸æ“š"""
        try:
            if sensor_id not in self.sensor_data:
                raise ValueError(f"Sensor {sensor_id} not found")
            
            current_time = time.time()
            time_since_last_update = current_time - self.last_update[sensor_id]
            
            # æª¢æŸ¥æ›´æ–°ç‡
            if time_since_last_update >= 1.0 / self.sensor_rates[sensor_id]:
                self.sensor_data[sensor_id] = data
                self.last_update[sensor_id] = current_time
                return True
            
            return False
            
        except Exception as e:
            print(f"Error updating sensor: {e}")
            return False
    
    def get_sensor_data(self, sensor_id: str) -> Optional[np.ndarray]:
        """ç²å–å‚³æ„Ÿå™¨æ•¸æ“š"""
        try:
            if sensor_id not in self.sensor_data:
                raise ValueError(f"Sensor {sensor_id} not found")
            
            return self.sensor_data[sensor_id]
            
        except Exception as e:
            print(f"Error getting sensor data: {e}")
            return None
    
    def process_lidar_data(self, data: np.ndarray) -> Dict:
        """è™•ç†æ¿€å…‰é›·é”æ•¸æ“š"""
        try:
            # å‡è¨­æ•¸æ“šæ ¼å¼ç‚º [angle, distance]
            processed_data = {
                'angles': data[:, 0],
                'distances': data[:, 1],
                'points': np.column_stack([
                    data[:, 1] * np.cos(data[:, 0]),
                    data[:, 1] * np.sin(data[:, 0])
                ])
            }
            
            return processed_data
            
        except Exception as e:
            print(f"Error processing lidar data: {e}")
            return {}
    
    def process_camera_data(self, data: np.ndarray) -> Dict:
        """è™•ç†ç›¸æ©Ÿæ•¸æ“š"""
        try:
            # å‡è¨­æ•¸æ“šç‚ºRGBåœ–åƒ
            processed_data = {
                'shape': data.shape,
                'mean': np.mean(data, axis=(0, 1)),
                'std': np.std(data, axis=(0, 1))
            }
            
            return processed_data
            
        except Exception as e:
            print(f"Error processing camera data: {e}")
            return {}
    
    def process_imu_data(self, data: np.ndarray) -> Dict:
        """è™•ç†IMUæ•¸æ“š"""
        try:
            # å‡è¨­æ•¸æ“šæ ¼å¼ç‚º [acc_x, acc_y, acc_z, gyro_x, gyro_y, gyro_z]
            processed_data = {
                'acceleration': data[:3],
                'angular_velocity': data[3:],
                'magnitude': np.linalg.norm(data[:3])
            }
            
            return processed_data
            
        except Exception as e:
            print(f"Error processing IMU data: {e}")
            return {}
    
    def get_all_sensor_data(self) -> Dict:
        """ç²å–æ‰€æœ‰å‚³æ„Ÿå™¨æ•¸æ“š"""
        try:
            all_data = {}
            for sensor_id in self.sensor_data:
                all_data[sensor_id] = self.get_sensor_data(sensor_id)
            return all_data
            
        except Exception as e:
            print(f"Error getting all sensor data: {e}")
            return {}

# ä½¿ç”¨ç¤ºä¾‹
def main():
    # å‰µå»ºå‚³æ„Ÿå™¨æ§åˆ¶å™¨
    controller = SensorController()
    
    try:
        # æ·»åŠ å‚³æ„Ÿå™¨
        controller.add_sensor('lidar', update_rate=10.0)
        controller.add_sensor('camera', update_rate=30.0)
        controller.add_sensor('imu', update_rate=100.0)
        
        # æ¨¡æ“¬å‚³æ„Ÿå™¨æ•¸æ“š
        lidar_data = np.random.rand(360, 2)  # 360å€‹é»ï¼Œæ¯å€‹é»åŒ…å«è§’åº¦å’Œè·é›¢
        camera_data = np.random.rand(480, 640, 3)  # RGBåœ–åƒ
        imu_data = np.random.rand(6)  # IMUæ•¸æ“š
        
        # æ›´æ–°å‚³æ„Ÿå™¨æ•¸æ“š
        controller.update_sensor('lidar', lidar_data)
        controller.update_sensor('camera', camera_data)
        controller.update_sensor('imu', imu_data)
        
        # è™•ç†å‚³æ„Ÿå™¨æ•¸æ“š
        lidar_processed = controller.process_lidar_data(lidar_data)
        camera_processed = controller.process_camera_data(camera_data)
        imu_processed = controller.process_imu_data(imu_data)
        
        print(f"Processed lidar data: {lidar_processed}")
        print(f"Processed camera data: {camera_processed}")
        print(f"Processed IMU data: {imu_processed}")
        
        # ç²å–æ‰€æœ‰å‚³æ„Ÿå™¨æ•¸æ“š
        all_data = controller.get_all_sensor_data()
        print(f"All sensor data: {all_data}")
    
    except Exception as e:
        print(f"Error in main: {e}")

if __name__ == '__main__':
    main()
```

## ç·´ç¿’é¡Œ

1. **é‹å‹•æ§åˆ¶**
   é–‹ç™¼é‹å‹•æ§åˆ¶ï¼š
   - ä½ç½®æ§åˆ¶
   - é€Ÿåº¦æ§åˆ¶
   - è·¯å¾‘è·Ÿéš¨
   - å„ªåŒ–æ€§èƒ½

2. **å‚³æ„Ÿå™¨æ§åˆ¶**
   å‰µå»ºå‚³æ„Ÿå™¨æ§åˆ¶ï¼š
   - æ•¸æ“šæ¡é›†
   - æ•¸æ“šè™•ç†
   - æ•¸æ“šèåˆ
   - å„ªåŒ–æ€§èƒ½

3. **æ©Ÿå™¨äººæ§åˆ¶**
   å¯¦ç¾æ©Ÿå™¨äººæ§åˆ¶ï¼š
   - é‹å‹•è¦åŠƒ
   - å‚³æ„Ÿå™¨èåˆ
   - å„ªåŒ–æ€§èƒ½
   - è™•ç†ç•°å¸¸

## å°æé†’ ğŸ’¡

1. é‹å‹•æ§åˆ¶
   - é¸æ“‡åˆé©æ–¹æ³•
   - å„ªåŒ–åƒæ•¸
   - è™•ç†ç•°å¸¸
   - æä¾›ç›£æ§

2. å‚³æ„Ÿå™¨æ§åˆ¶
   - é¸æ“‡åˆé©æ–¹æ³•
   - å„ªåŒ–æ€§èƒ½
   - è™•ç†ç•°å¸¸
   - æä¾›çµæœ

3. æ©Ÿå™¨äººæ§åˆ¶
   - é¸æ“‡åˆé©ç®—æ³•
   - å„ªåŒ–æ€§èƒ½
   - è™•ç†ç•°å¸¸
   - æä¾›ç›£æ§

4. èª¿è©¦æŠ€å·§
   - ä½¿ç”¨é–‹ç™¼å·¥å…·
   - åˆ†ææ€§èƒ½
   - å„ªåŒ–é—œéµè·¯å¾‘
   - ç›£æ§è™•ç†ç‹€æ…‹

[ä¸Šä¸€ç« ï¼šè¨ˆç®—æ©Ÿè¦–è¦ºé€²éš](103_è¨ˆç®—æ©Ÿè¦–è¦ºé€²éš.md) | [ä¸‹ä¸€ç« ï¼šæ©Ÿå™¨äººé€²éš](105_æ©Ÿå™¨äººé€²éš.md) 