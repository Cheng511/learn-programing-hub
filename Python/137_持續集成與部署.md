[‰∏ä‰∏ÄÁ´†ÔºöDevOpsÂØ¶Ë∏êÂü∫Á§é](136_DevOpsÂØ¶Ë∏êÂü∫Á§é.md) | [‰∏ã‰∏ÄÁ´†ÔºöÂæÆÊúçÂãôÊû∂ÊßãË®≠Ë®à](138_ÂæÆÊúçÂãôÊû∂ÊßãË®≠Ë®à.md)

# Python ÊåÅÁ∫åÈõÜÊàêËàáÈÉ®ÁΩ≤ üîÑ

## 1. CI/CD ÊµÅÊ∞¥Á∑ö

### 1.1 Jenkins ÈõÜÊàê

```python
from jenkinsapi.jenkins import Jenkins
from typing import Dict, List, Optional
import json

class JenkinsPipeline:
    """Jenkins ÊµÅÊ∞¥Á∑öÁÆ°ÁêÜÂô®"""
    def __init__(self,
                 jenkins_url: str,
                 username: str,
                 password: str):
        self.jenkins = Jenkins(
            jenkins_url,
            username=username,
            password=password
        )
    
    def create_pipeline(self,
                       name: str,
                       git_url: str,
                       jenkinsfile_path: str) -> bool:
        """ÂâµÂª∫ÊµÅÊ∞¥Á∑ö"""
        try:
            job_config = f'''<?xml version='1.1' encoding='UTF-8'?>
            <flow-definition plugin="workflow-job">
                <definition class="org.jenkinsci.plugins.workflow.cps.CpsScmFlowDefinition">
                    <scm class="hudson.plugins.git.GitSCM">
                        <userRemoteConfigs>
                            <hudson.plugins.git.UserRemoteConfig>
                                <url>{git_url}</url>
                            </hudson.plugins.git.UserRemoteConfig>
                        </userRemoteConfigs>
                        <branches>
                            <hudson.plugins.git.BranchSpec>
                                <name>*/main</name>
                            </hudson.plugins.git.BranchSpec>
                        </branches>
                    </scm>
                    <scriptPath>{jenkinsfile_path}</scriptPath>
                </definition>
            </flow-definition>'''
            
            self.jenkins.create_job(name, job_config)
            return True
        except Exception as e:
            print(f"Failed to create pipeline: {e}")
            return False
    
    def trigger_build(self,
                     job_name: str,
                     parameters: Optional[Dict] = None) -> bool:
        """Ëß∏ÁôºÊßãÂª∫"""
        try:
            job = self.jenkins[job_name]
            job.invoke(build_params=parameters)
            return True
        except Exception as e:
            print(f"Failed to trigger build: {e}")
            return False
    
    def get_build_status(self,
                        job_name: str,
                        build_number: Optional[int] = None) -> Dict:
        """Áç≤ÂèñÊßãÂª∫ÁãÄÊÖã"""
        try:
            job = self.jenkins[job_name]
            build = job.get_last_build() if build_number is None \
                else job.get_build(build_number)
            
            return {
                "number": build.get_number(),
                "status": build.get_status(),
                "url": build.get_url(),
                "duration": build.get_duration().total_seconds(),
                "timestamp": build.get_timestamp()
            }
        except Exception as e:
            print(f"Failed to get build status: {e}")
            return {}
```

### 1.2 GitLab CI ÈõÜÊàê

```python
import gitlab
from typing import Dict, List

class GitLabCI:
    """GitLab CI ÁÆ°ÁêÜÂô®"""
    def __init__(self,
                 url: str,
                 private_token: str):
        self.gl = gitlab.Gitlab(
            url,
            private_token=private_token
        )
    
    def create_pipeline(self,
                       project_id: int,
                       ref: str = 'main') -> bool:
        """ÂâµÂª∫ÊµÅÊ∞¥Á∑ö"""
        try:
            project = self.gl.projects.get(project_id)
            pipeline = project.pipelines.create({'ref': ref})
            return True
        except Exception as e:
            print(f"Failed to create pipeline: {e}")
            return False
    
    def get_pipeline_status(self,
                          project_id: int,
                          pipeline_id: int) -> Dict:
        """Áç≤ÂèñÊµÅÊ∞¥Á∑öÁãÄÊÖã"""
        try:
            project = self.gl.projects.get(project_id)
            pipeline = project.pipelines.get(pipeline_id)
            
            return {
                "id": pipeline.id,
                "status": pipeline.status,
                "ref": pipeline.ref,
                "sha": pipeline.sha,
                "web_url": pipeline.web_url
            }
        except Exception as e:
            print(f"Failed to get pipeline status: {e}")
            return {}
```

## 2. Ëá™ÂãïÂåñÊ∏¨Ë©¶

### 2.1 ÂñÆÂÖÉÊ∏¨Ë©¶Ê°ÜÊû∂

```python
import unittest
from typing import Any, Callable, List, Type
import coverage

class TestFramework:
    """Ê∏¨Ë©¶Ê°ÜÊû∂ÁÆ°ÁêÜÂô®"""
    def __init__(self):
        self.test_suite = unittest.TestSuite()
        self.cov = coverage.Coverage()
    
    def add_test_case(self,
                      test_case: Type[unittest.TestCase]):
        """Ê∑ªÂä†Ê∏¨Ë©¶Áî®‰æã"""
        self.test_suite.addTests(
            unittest.TestLoader().loadTestsFromTestCase(test_case)
        )
    
    def run_tests(self,
                  verbosity: int = 2) -> bool:
        """ÈÅãË°åÊ∏¨Ë©¶"""
        try:
            # ÂïüÂãïË¶ÜËìãÁéáÁµ±Ë®à
            self.cov.start()
            
            # ÈÅãË°åÊ∏¨Ë©¶
            runner = unittest.TextTestRunner(verbosity=verbosity)
            result = runner.run(self.test_suite)
            
            # ÂÅúÊ≠¢Ë¶ÜËìãÁéáÁµ±Ë®à
            self.cov.stop()
            self.cov.save()
            
            return result.wasSuccessful()
        except Exception as e:
            print(f"Failed to run tests: {e}")
            return False
    
    def generate_coverage_report(self,
                               report_type: str = 'html') -> bool:
        """ÁîüÊàêË¶ÜËìãÁéáÂ†±Âëä"""
        try:
            if report_type == 'html':
                self.cov.html_report()
            elif report_type == 'xml':
                self.cov.xml_report()
            else:
                self.cov.report()
            return True
        except Exception as e:
            print(f"Failed to generate coverage report: {e}")
            return False
```

### 2.2 ÈõÜÊàêÊ∏¨Ë©¶

```python
import docker
import requests
from typing import Dict, List
import time

class IntegrationTest:
    """ÈõÜÊàêÊ∏¨Ë©¶ÁÆ°ÁêÜÂô®"""
    def __init__(self):
        self.client = docker.from_env()
        self.containers = []
    
    def setup_environment(self,
                         services: List[Dict]) -> bool:
        """Ë®≠ÁΩÆÊ∏¨Ë©¶Áí∞Â¢É"""
        try:
            for service in services:
                container = self.client.containers.run(
                    image=service['image'],
                    name=service['name'],
                    ports=service.get('ports', {}),
                    environment=service.get('environment', {}),
                    detach=True
                )
                self.containers.append(container)
            
            # Á≠âÂæÖÊúçÂãôÂïüÂãï
            time.sleep(10)
            return True
        except Exception as e:
            print(f"Failed to setup environment: {e}")
            return False
    
    def run_tests(self,
                  test_cases: List[Dict]) -> Dict[str, bool]:
        """ÈÅãË°åÊ∏¨Ë©¶Áî®‰æã"""
        results = {}
        try:
            for test in test_cases:
                response = requests.request(
                    method=test['method'],
                    url=test['url'],
                    headers=test.get('headers', {}),
                    json=test.get('body', {})
                )
                
                results[test['name']] = (
                    response.status_code == test['expected_status']
                )
            
            return results
        except Exception as e:
            print(f"Failed to run tests: {e}")
            return {}
    
    def cleanup_environment(self):
        """Ê∏ÖÁêÜÊ∏¨Ë©¶Áí∞Â¢É"""
        for container in self.containers:
            try:
                container.stop()
                container.remove()
            except Exception as e:
                print(f"Failed to cleanup container: {e}")
```

## 3. ÈÉ®ÁΩ≤Ëá™ÂãïÂåñ

### 3.1 ÂÆπÂô®ÂåñÈÉ®ÁΩ≤

```python
from kubernetes import client, config
from typing import Dict, List
import yaml

class ContainerDeployment:
    """ÂÆπÂô®ÈÉ®ÁΩ≤ÁÆ°ÁêÜÂô®"""
    def __init__(self):
        config.load_kube_config()
        self.apps_v1 = client.AppsV1Api()
        self.core_v1 = client.CoreV1Api()
    
    def deploy_application(self,
                         config_file: str) -> bool:
        """ÈÉ®ÁΩ≤ÊáâÁî®"""
        try:
            with open(config_file, 'r') as f:
                configs = list(yaml.safe_load_all(f))
            
            for config in configs:
                if config["kind"] == "Deployment":
                    self.apps_v1.create_namespaced_deployment(
                        namespace=config["metadata"]["namespace"],
                        body=config
                    )
                elif config["kind"] == "Service":
                    self.core_v1.create_namespaced_service(
                        namespace=config["metadata"]["namespace"],
                        body=config
                    )
            
            return True
        except Exception as e:
            print(f"Failed to deploy application: {e}")
            return False
    
    def rollback_deployment(self,
                          name: str,
                          namespace: str,
                          revision: int) -> bool:
        """ÂõûÊªæÈÉ®ÁΩ≤"""
        try:
            self.apps_v1.patch_namespaced_deployment(
                name=name,
                namespace=namespace,
                body={
                    "spec": {
                        "rollbackTo": {
                            "revision": revision
                        }
                    }
                }
            )
            return True
        except Exception as e:
            print(f"Failed to rollback deployment: {e}")
            return False
```

### 3.2 ËóçÁ∂†ÈÉ®ÁΩ≤

```python
class BlueGreenDeployment:
    """ËóçÁ∂†ÈÉ®ÁΩ≤ÁÆ°ÁêÜÂô®"""
    def __init__(self):
        config.load_kube_config()
        self.apps_v1 = client.AppsV1Api()
        self.core_v1 = client.CoreV1Api()
    
    def create_deployment(self,
                         name: str,
                         namespace: str,
                         image: str,
                         color: str) -> bool:
        """ÂâµÂª∫ÈÉ®ÁΩ≤"""
        try:
            deployment = client.V1Deployment(
                metadata=client.V1ObjectMeta(
                    name=f"{name}-{color}",
                    namespace=namespace,
                    labels={
                        "app": name,
                        "color": color
                    }
                ),
                spec=client.V1DeploymentSpec(
                    replicas=3,
                    selector=client.V1LabelSelector(
                        match_labels={
                            "app": name,
                            "color": color
                        }
                    ),
                    template=client.V1PodTemplateSpec(
                        metadata=client.V1ObjectMeta(
                            labels={
                                "app": name,
                                "color": color
                            }
                        ),
                        spec=client.V1PodSpec(
                            containers=[
                                client.V1Container(
                                    name=name,
                                    image=image
                                )
                            ]
                        )
                    )
                )
            )
            
            self.apps_v1.create_namespaced_deployment(
                namespace=namespace,
                body=deployment
            )
            return True
        except Exception as e:
            print(f"Failed to create deployment: {e}")
            return False
    
    def switch_traffic(self,
                      name: str,
                      namespace: str,
                      to_color: str) -> bool:
        """ÂàáÊèõÊµÅÈáè"""
        try:
            service = self.core_v1.read_namespaced_service(
                name=name,
                namespace=namespace
            )
            
            service.spec.selector['color'] = to_color
            
            self.core_v1.patch_namespaced_service(
                name=name,
                namespace=namespace,
                body=service
            )
            return True
        except Exception as e:
            print(f"Failed to switch traffic: {e}")
            return False
```

## Á∑¥ÁøíÈ°å üèÉ‚Äç‚ôÇÔ∏è

1. ÂØ¶ÁèæÂÆåÊï¥ÁöÑ Jenkins ÊµÅÊ∞¥Á∑öÔºö
   - ‰ª£Á¢ºÊ™¢Êü•ÈöéÊÆµ
   - ÂñÆÂÖÉÊ∏¨Ë©¶ÈöéÊÆµ
   - ÊßãÂª∫ÈöéÊÆµ
   - ÈÉ®ÁΩ≤ÈöéÊÆµ
   - ÈÄöÁü•ÈöéÊÆµ

2. ÈñãÁôºËá™ÂãïÂåñÊ∏¨Ë©¶Ê°ÜÊû∂Ôºö
   - Ê∏¨Ë©¶Áî®‰æãÁÆ°ÁêÜ
   - Ê∏¨Ë©¶Êï∏ÊìöÊ∫ñÂÇô
   - Ê∏¨Ë©¶Âü∑Ë°å
   - ÁµêÊûúÂ†±Âëä
   - Ë¶ÜËìãÁéáÂàÜÊûê

3. ÂØ¶ÁèæÈÉ®ÁΩ≤Ëá™ÂãïÂåñÁ≥ªÁµ±Ôºö
   - Áí∞Â¢ÉÈÖçÁΩÆ
   - ÊúçÂãôÈÉ®ÁΩ≤
   - ÂÅ•Â∫∑Ê™¢Êü•
   - ÂõûÊªæÊ©üÂà∂
   - Áõ£ÊéßÈõÜÊàê

4. ÂâµÂª∫ GitLab CI ÊµÅÊ∞¥Á∑öÔºö
   - Â§öÈöéÊÆµÈÖçÁΩÆ
   - ‰∏¶Ë°å‰ªªÂãô
   - Ê¢ù‰ª∂Âü∑Ë°å
   - Âà∂ÂìÅÁÆ°ÁêÜ
   - Áí∞Â¢ÉÈÉ®ÁΩ≤

5. ÈñãÁôºËóçÁ∂†ÈÉ®ÁΩ≤Â∑•ÂÖ∑Ôºö
   - ÁâàÊú¨ÁÆ°ÁêÜ
   - ÊµÅÈáèÂàáÊèõ
   - ÂÅ•Â∫∑Ê™¢Êü•
   - Ëá™ÂãïÂõûÊªæ
   - Áõ£ÊéßÈõÜÊàê

## Â∞èÁµê üìù

- ‰∫ÜËß£‰∫Ü CI/CD ÊµÅÊ∞¥Á∑öÁöÑÊßãÂª∫ÊñπÊ≥ï
- ÊéåÊè°‰∫ÜËá™ÂãïÂåñÊ∏¨Ë©¶ÁöÑÂØ¶ÁèæÊäÄË°ì
- Â≠∏ÊúÉ‰∫ÜÂÆπÂô®ÂåñÈÉ®ÁΩ≤ÁöÑÁ≠ñÁï•
- ÁêÜËß£‰∫ÜËóçÁ∂†ÈÉ®ÁΩ≤ÁöÑÂéüÁêÜÂíåÂØ¶Áèæ
- ÊéåÊè°‰∫ÜÊåÅÁ∫åÈõÜÊàêËàáÈÉ®ÁΩ≤ÁöÑÊúÄ‰Ω≥ÂØ¶Ë∏ê

## Âª∂‰º∏Èñ±ËÆÄ üìö

1. Jenkins Pipeline ÊúÄ‰Ω≥ÂØ¶Ë∏ê
2. GitLab CI/CD ÂÆåÂÖ®ÊåáÂçó
3. ÂÆπÂô®ÂåñÈÉ®ÁΩ≤Á≠ñÁï•
4. Ëá™ÂãïÂåñÊ∏¨Ë©¶ÂØ¶Êà∞
5. ÊåÅÁ∫å‰∫§‰ªòÂØ¶Ë∏êÊåáÂçó

[‰∏ä‰∏ÄÁ´†ÔºöDevOpsÂØ¶Ë∏êÂü∫Á§é](136_DevOpsÂØ¶Ë∏êÂü∫Á§é.md) | [‰∏ã‰∏ÄÁ´†ÔºöÂæÆÊúçÂãôÊû∂ÊßãË®≠Ë®à](138_ÂæÆÊúçÂãôÊû∂ÊßãË®≠Ë®à.md) 