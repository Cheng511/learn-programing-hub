[ä¸Šä¸€ç« ï¼šé€²éšç¶²é çˆ¬èŸ²](057_é€²éšç¶²é çˆ¬èŸ².md) | [ä¸‹ä¸€ç« ï¼šé›²ç«¯éƒ¨ç½²èˆ‡æœå‹™](059_é›²ç«¯éƒ¨ç½²èˆ‡æœå‹™.md)

# Python è‡ªå‹•åŒ–é‹ç¶­ ğŸ”§

## ç³»çµ±ç®¡ç†

### 1. æ–‡ä»¶ç³»çµ±æ“ä½œ

```python
import os
import shutil
from pathlib import Path
import glob
from typing import List, Dict
import logging

# è¨­ç½®æ—¥èªŒ
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)

class FileManager:
    def __init__(self, base_path: str):
        self.base_path = Path(base_path)
        self.base_path.mkdir(parents=True, exist_ok=True)
    
    def list_files(self, pattern: str = "*") -> List[Path]:
        """åˆ—å‡ºç¬¦åˆæ¨¡å¼çš„æ–‡ä»¶"""
        return list(self.base_path.glob(pattern))
    
    def create_directory(self, dir_name: str) -> Path:
        """å‰µå»ºç›®éŒ„"""
        new_dir = self.base_path / dir_name
        new_dir.mkdir(parents=True, exist_ok=True)
        logger.info(f'å‰µå»ºç›®éŒ„: {new_dir}')
        return new_dir
    
    def copy_file(self, source: str, destination: str):
        """è¤‡è£½æ–‡ä»¶"""
        src_path = self.base_path / source
        dst_path = self.base_path / destination
        try:
            shutil.copy2(src_path, dst_path)
            logger.info(f'è¤‡è£½æ–‡ä»¶: {src_path} -> {dst_path}')
        except Exception as e:
            logger.error(f'è¤‡è£½æ–‡ä»¶å¤±æ•—: {e}')
    
    def move_file(self, source: str, destination: str):
        """ç§»å‹•æ–‡ä»¶"""
        src_path = self.base_path / source
        dst_path = self.base_path / destination
        try:
            shutil.move(src_path, dst_path)
            logger.info(f'ç§»å‹•æ–‡ä»¶: {src_path} -> {dst_path}')
        except Exception as e:
            logger.error(f'ç§»å‹•æ–‡ä»¶å¤±æ•—: {e}')
    
    def delete_file(self, file_path: str):
        """åˆªé™¤æ–‡ä»¶"""
        path = self.base_path / file_path
        try:
            if path.is_file():
                path.unlink()
            elif path.is_dir():
                shutil.rmtree(path)
            logger.info(f'åˆªé™¤: {path}')
        except Exception as e:
            logger.error(f'åˆªé™¤å¤±æ•—: {e}')
    
    def get_file_info(self, file_path: str) -> Dict:
        """ç²å–æ–‡ä»¶ä¿¡æ¯"""
        path = self.base_path / file_path
        try:
            stat = path.stat()
            return {
                'size': stat.st_size,
                'created': stat.st_ctime,
                'modified': stat.st_mtime,
                'accessed': stat.st_atime
            }
        except Exception as e:
            logger.error(f'ç²å–æ–‡ä»¶ä¿¡æ¯å¤±æ•—: {e}')
            return {}

# ä½¿ç”¨ç¤ºä¾‹
def main():
    fm = FileManager('/path/to/workspace')
    
    # å‰µå»ºç›®éŒ„
    fm.create_directory('logs')
    
    # åˆ—å‡ºæ–‡ä»¶
    files = fm.list_files('*.log')
    print('æ—¥èªŒæ–‡ä»¶:', files)
    
    # è¤‡è£½æ–‡ä»¶
    fm.copy_file('app.log', 'logs/app_backup.log')
    
    # ç²å–æ–‡ä»¶ä¿¡æ¯
    info = fm.get_file_info('logs/app_backup.log')
    print('æ–‡ä»¶ä¿¡æ¯:', info)

if __name__ == '__main__':
    main()
```

### 2. é€²ç¨‹ç®¡ç†

```python
import psutil
import subprocess
from typing import List, Dict
import time

class ProcessManager:
    @staticmethod
    def list_processes() -> List[Dict]:
        """åˆ—å‡ºæ‰€æœ‰é€²ç¨‹"""
        processes = []
        for proc in psutil.process_iter(['pid', 'name', 'cpu_percent', 'memory_percent']):
            try:
                processes.append(proc.info)
            except (psutil.NoSuchProcess, psutil.AccessDenied):
                pass
        return processes
    
    @staticmethod
    def get_process_info(pid: int) -> Dict:
        """ç²å–é€²ç¨‹è©³ç´°ä¿¡æ¯"""
        try:
            proc = psutil.Process(pid)
            return {
                'pid': proc.pid,
                'name': proc.name(),
                'status': proc.status(),
                'cpu_percent': proc.cpu_percent(),
                'memory_percent': proc.memory_percent(),
                'create_time': proc.create_time(),
                'cmdline': proc.cmdline()
            }
        except psutil.NoSuchProcess:
            return {}
    
    @staticmethod
    def kill_process(pid: int) -> bool:
        """çµæŸé€²ç¨‹"""
        try:
            proc = psutil.Process(pid)
            proc.terminate()
            proc.wait(timeout=3)
            return True
        except (psutil.NoSuchProcess, psutil.TimeoutExpired):
            return False
    
    @staticmethod
    def run_command(command: str) -> Dict:
        """é‹è¡Œå‘½ä»¤"""
        try:
            result = subprocess.run(
                command,
                shell=True,
                capture_output=True,
                text=True
            )
            return {
                'returncode': result.returncode,
                'stdout': result.stdout,
                'stderr': result.stderr
            }
        except subprocess.SubprocessError as e:
            return {'error': str(e)}

# ä½¿ç”¨ç¤ºä¾‹
def monitor_processes():
    pm = ProcessManager()
    
    # åˆ—å‡ºæ‰€æœ‰é€²ç¨‹
    processes = pm.list_processes()
    print(f'ç•¶å‰é‹è¡Œçš„é€²ç¨‹æ•¸: {len(processes)}')
    
    # ç›£æ§ç‰¹å®šé€²ç¨‹
    target_pid = 1234
    info = pm.get_process_info(target_pid)
    if info:
        print(f'é€²ç¨‹ä¿¡æ¯: {info}')
    
    # é‹è¡Œå‘½ä»¤
    result = pm.run_command('ls -l')
    print('å‘½ä»¤è¼¸å‡º:', result['stdout'])

if __name__ == '__main__':
    monitor_processes()
```

## æ—¥èªŒè™•ç†

### 1. æ—¥èªŒæ”¶é›†èˆ‡åˆ†æ

```python
import re
from datetime import datetime
from typing import List, Dict
import pandas as pd
from collections import defaultdict

class LogAnalyzer:
    def __init__(self, log_file: str):
        self.log_file = log_file
        self.log_pattern = r'(\d{4}-\d{2}-\d{2} \d{2}:\d{2}:\d{2}) \[(\w+)\] (.+)'
    
    def parse_log(self) -> List[Dict]:
        """è§£ææ—¥èªŒæ–‡ä»¶"""
        logs = []
        with open(self.log_file, 'r') as f:
            for line in f:
                match = re.match(self.log_pattern, line)
                if match:
                    timestamp, level, message = match.groups()
                    logs.append({
                        'timestamp': datetime.strptime(timestamp, '%Y-%m-%d %H:%M:%S'),
                        'level': level,
                        'message': message
                    })
        return logs
    
    def analyze_logs(self) -> Dict:
        """åˆ†ææ—¥èªŒ"""
        logs = self.parse_log()
        df = pd.DataFrame(logs)
        
        analysis = {
            'total_entries': len(logs),
            'level_counts': df['level'].value_counts().to_dict(),
            'hourly_distribution': df.groupby(df['timestamp'].dt.hour).size().to_dict(),
            'latest_entry': df.iloc[-1].to_dict() if not df.empty else None
        }
        
        return analysis
    
    def search_logs(self, keyword: str) -> List[Dict]:
        """æœç´¢æ—¥èªŒ"""
        logs = self.parse_log()
        return [log for log in logs if keyword.lower() in log['message'].lower()]
    
    def generate_report(self) -> str:
        """ç”Ÿæˆå ±å‘Š"""
        analysis = self.analyze_logs()
        
        report = [
            "æ—¥èªŒåˆ†æå ±å‘Š",
            "=" * 20,
            f"ç¸½æ¢ç›®æ•¸: {analysis['total_entries']}",
            "\næ—¥èªŒç´šåˆ¥åˆ†å¸ƒ:",
        ]
        
        for level, count in analysis['level_counts'].items():
            report.append(f"- {level}: {count}")
        
        report.append("\næ¯å°æ™‚åˆ†å¸ƒ:")
        for hour, count in sorted(analysis['hourly_distribution'].items()):
            report.append(f"- {hour:02d}:00: {count}")
        
        if analysis['latest_entry']:
            report.append("\næœ€æ–°æ—¥èªŒ:")
            report.append(f"æ™‚é–“: {analysis['latest_entry']['timestamp']}")
            report.append(f"ç´šåˆ¥: {analysis['latest_entry']['level']}")
            report.append(f"æ¶ˆæ¯: {analysis['latest_entry']['message']}")
        
        return "\n".join(report)

# ä½¿ç”¨ç¤ºä¾‹
def analyze_log_file():
    analyzer = LogAnalyzer('app.log')
    
    # ç”Ÿæˆå ±å‘Š
    report = analyzer.generate_report()
    print(report)
    
    # æœç´¢éŒ¯èª¤
    errors = analyzer.search_logs('error')
    print(f'\næ‰¾åˆ° {len(errors)} å€‹éŒ¯èª¤')
    for error in errors:
        print(f"{error['timestamp']}: {error['message']}")

if __name__ == '__main__':
    analyze_log_file()
```

### 2. æ—¥èªŒè¼ªè½‰

```python
import logging
from logging.handlers import RotatingFileHandler
import time
from pathlib import Path

class LogRotator:
    def __init__(self, log_dir: str, app_name: str):
        self.log_dir = Path(log_dir)
        self.log_dir.mkdir(parents=True, exist_ok=True)
        self.app_name = app_name
        
        self.setup_logger()
    
    def setup_logger(self):
        """è¨­ç½®æ—¥èªŒè¨˜éŒ„å™¨"""
        log_file = self.log_dir / f'{self.app_name}.log'
        
        # å‰µå»ºè¨˜éŒ„å™¨
        self.logger = logging.getLogger(self.app_name)
        self.logger.setLevel(logging.INFO)
        
        # è¨­ç½®è¼ªè½‰è™•ç†å™¨
        handler = RotatingFileHandler(
            log_file,
            maxBytes=1024 * 1024,  # 1MB
            backupCount=5
        )
        
        # è¨­ç½®æ ¼å¼
        formatter = logging.Formatter(
            '%(asctime)s - %(name)s - %(levelname)s - %(message)s'
        )
        handler.setFormatter(formatter)
        
        self.logger.addHandler(handler)
    
    def log(self, level: str, message: str):
        """è¨˜éŒ„æ—¥èªŒ"""
        if level.upper() == 'DEBUG':
            self.logger.debug(message)
        elif level.upper() == 'INFO':
            self.logger.info(message)
        elif level.upper() == 'WARNING':
            self.logger.warning(message)
        elif level.upper() == 'ERROR':
            self.logger.error(message)
        elif level.upper() == 'CRITICAL':
            self.logger.critical(message)

# ä½¿ç”¨ç¤ºä¾‹
def simulate_logging():
    rotator = LogRotator('logs', 'myapp')
    
    # æ¨¡æ“¬æ—¥èªŒè¨˜éŒ„
    for i in range(1000):
        rotator.log('INFO', f'é€™æ˜¯ç¬¬ {i} æ¢æ—¥èªŒæ¶ˆæ¯')
        if i % 100 == 0:
            rotator.log('ERROR', f'ç™¼ç”ŸéŒ¯èª¤ {i}')
        time.sleep(0.01)

if __name__ == '__main__':
    simulate_logging()
```

## ç³»çµ±ç›£æ§

### 1. è³‡æºç›£æ§

```python
import psutil
import time
from typing import Dict
import json
from pathlib import Path

class SystemMonitor:
    def __init__(self, output_dir: str = 'monitoring'):
        self.output_dir = Path(output_dir)
        self.output_dir.mkdir(parents=True, exist_ok=True)
    
    def get_system_stats(self) -> Dict:
        """ç²å–ç³»çµ±ç‹€æ…‹"""
        return {
            'cpu_percent': psutil.cpu_percent(interval=1),
            'memory': dict(psutil.virtual_memory()._asdict()),
            'disk': {
                path: dict(psutil.disk_usage(path)._asdict())
                for path in psutil.disk_partitions()
            },
            'network': dict(psutil.net_io_counters()._asdict()),
            'timestamp': time.time()
        }
    
    def monitor(self, interval: int = 60, duration: int = 3600):
        """æŒçºŒç›£æ§ç³»çµ±"""
        start_time = time.time()
        stats_file = self.output_dir / f'stats_{int(start_time)}.json'
        
        stats = []
        while time.time() - start_time < duration:
            current_stats = self.get_system_stats()
            stats.append(current_stats)
            
            # ä¿å­˜çµ±è¨ˆæ•¸æ“š
            with open(stats_file, 'w') as f:
                json.dump(stats, f, indent=2)
            
            time.sleep(interval)
    
    def analyze_stats(self, stats_file: Path) -> Dict:
        """åˆ†æçµ±è¨ˆæ•¸æ“š"""
        with open(stats_file) as f:
            stats = json.load(f)
        
        cpu_usage = [s['cpu_percent'] for s in stats]
        memory_usage = [s['memory']['percent'] for s in stats]
        
        return {
            'cpu': {
                'avg': sum(cpu_usage) / len(cpu_usage),
                'max': max(cpu_usage),
                'min': min(cpu_usage)
            },
            'memory': {
                'avg': sum(memory_usage) / len(memory_usage),
                'max': max(memory_usage),
                'min': min(memory_usage)
            },
            'duration': stats[-1]['timestamp'] - stats[0]['timestamp']
        }

# ä½¿ç”¨ç¤ºä¾‹
def monitor_system():
    monitor = SystemMonitor()
    
    # ç›£æ§1å°æ™‚ï¼Œæ¯åˆ†é˜è¨˜éŒ„ä¸€æ¬¡
    print('é–‹å§‹ç³»çµ±ç›£æ§...')
    monitor.monitor(interval=60, duration=3600)
    
    # åˆ†æçµæœ
    stats_files = list(monitor.output_dir.glob('stats_*.json'))
    if stats_files:
        latest_stats = stats_files[-1]
        analysis = monitor.analyze_stats(latest_stats)
        print('\nç›£æ§çµæœåˆ†æ:')
        print(f"CPU ä½¿ç”¨ç‡: å¹³å‡ {analysis['cpu']['avg']:.1f}%")
        print(f"å…§å­˜ä½¿ç”¨ç‡: å¹³å‡ {analysis['memory']['avg']:.1f}%")
        print(f"ç›£æ§æ™‚é•·: {analysis['duration'] / 3600:.1f} å°æ™‚")

if __name__ == '__main__':
    monitor_system()
```

### 2. å‘Šè­¦ç³»çµ±

```python
import smtplib
from email.mime.text import MIMEText
from email.mime.multipart import MIMEMultipart
import json
from typing import Dict, List
import time
import requests

class AlertSystem:
    def __init__(self, config_file: str):
        with open(config_file) as f:
            self.config = json.load(f)
        
        self.thresholds = self.config['thresholds']
        self.alert_history = []
    
    def check_thresholds(self, metrics: Dict) -> List[Dict]:
        """æª¢æŸ¥æ˜¯å¦è¶…éé–¾å€¼"""
        alerts = []
        
        # CPUä½¿ç”¨ç‡
        if metrics['cpu_percent'] > self.thresholds['cpu']:
            alerts.append({
                'type': 'CPU',
                'value': metrics['cpu_percent'],
                'threshold': self.thresholds['cpu']
            })
        
        # å…§å­˜ä½¿ç”¨ç‡
        if metrics['memory']['percent'] > self.thresholds['memory']:
            alerts.append({
                'type': 'Memory',
                'value': metrics['memory']['percent'],
                'threshold': self.thresholds['memory']
            })
        
        # ç£ç›¤ä½¿ç”¨ç‡
        for path, usage in metrics['disk'].items():
            if usage['percent'] > self.thresholds['disk']:
                alerts.append({
                    'type': 'Disk',
                    'path': path,
                    'value': usage['percent'],
                    'threshold': self.thresholds['disk']
                })
        
        return alerts
    
    def send_email_alert(self, alerts: List[Dict]):
        """ç™¼é€éƒµä»¶å‘Šè­¦"""
        if not alerts:
            return
        
        msg = MIMEMultipart()
        msg['Subject'] = 'ç³»çµ±å‘Šè­¦é€šçŸ¥'
        msg['From'] = self.config['email']['sender']
        msg['To'] = self.config['email']['recipient']
        
        body = "ç³»çµ±æª¢æ¸¬åˆ°ä»¥ä¸‹å‘Šè­¦:\n\n"
        for alert in alerts:
            body += f"- {alert['type']} ä½¿ç”¨ç‡: {alert['value']}% "
            body += f"(é–¾å€¼: {alert['threshold']}%)\n"
        
        msg.attach(MIMEText(body, 'plain'))
        
        try:
            with smtplib.SMTP(self.config['email']['smtp_server']) as server:
                server.starttls()
                server.login(
                    self.config['email']['username'],
                    self.config['email']['password']
                )
                server.send_message(msg)
        except Exception as e:
            print(f'ç™¼é€éƒµä»¶å¤±æ•—: {e}')
    
    def send_webhook_alert(self, alerts: List[Dict]):
        """ç™¼é€Webhookå‘Šè­¦"""
        if not alerts or 'webhook_url' not in self.config:
            return
        
        payload = {
            'text': 'ç³»çµ±å‘Šè­¦é€šçŸ¥',
            'alerts': alerts
        }
        
        try:
            response = requests.post(
                self.config['webhook_url'],
                json=payload,
                timeout=5
            )
            response.raise_for_status()
        except requests.exceptions.RequestException as e:
            print(f'ç™¼é€Webhookå¤±æ•—: {e}')
    
    def process_alerts(self, metrics: Dict):
        """è™•ç†å‘Šè­¦"""
        alerts = self.check_thresholds(metrics)
        
        if alerts:
            self.alert_history.append({
                'timestamp': time.time(),
                'alerts': alerts
            })
            
            # ç™¼é€å‘Šè­¦
            self.send_email_alert(alerts)
            self.send_webhook_alert(alerts)
    
    def get_alert_history(self, hours: int = 24) -> List[Dict]:
        """ç²å–å‘Šè­¦æ­·å²"""
        cutoff_time = time.time() - hours * 3600
        return [
            alert for alert in self.alert_history
            if alert['timestamp'] > cutoff_time
        ]

# ä½¿ç”¨ç¤ºä¾‹
def main():
    # é…ç½®æ–‡ä»¶ç¤ºä¾‹
    config = {
        'thresholds': {
            'cpu': 80,
            'memory': 90,
            'disk': 85
        },
        'email': {
            'sender': 'alert@example.com',
            'recipient': 'admin@example.com',
            'smtp_server': 'smtp.example.com',
            'username': 'alert@example.com',
            'password': 'password'
        },
        'webhook_url': 'https://webhook.example.com/alert'
    }
    
    # ä¿å­˜é…ç½®
    with open('alert_config.json', 'w') as f:
        json.dump(config, f, indent=2)
    
    # å‰µå»ºå‘Šè­¦ç³»çµ±
    alert_system = AlertSystem('alert_config.json')
    
    # æ¨¡æ“¬ç›£æ§
    monitor = SystemMonitor()
    while True:
        metrics = monitor.get_system_stats()
        alert_system.process_alerts(metrics)
        time.sleep(60)

if __name__ == '__main__':
    main()
```

## ç·´ç¿’é¡Œ

1. **æ—¥èªŒåˆ†æå·¥å…·**
   å¯¦ç¾ä¸€å€‹æ—¥èªŒåˆ†æå·¥å…·ï¼š
   - è§£æå¤šç¨®æ—¥èªŒæ ¼å¼
   - çµ±è¨ˆéŒ¯èª¤é »ç‡
   - ç”Ÿæˆåˆ†æå ±å‘Š
   - è¨­ç½®å‘Šè­¦è¦å‰‡

2. **ç³»çµ±ç›£æ§å„€è¡¨æ¿**
   é–‹ç™¼ä¸€å€‹Webç›£æ§å„€è¡¨æ¿ï¼š
   - å¯¦æ™‚è³‡æºç›£æ§
   - æ­·å²æ•¸æ“šåœ–è¡¨
   - å‘Šè­¦é…ç½®ç•Œé¢
   - ç›£æ§å ±å‘Šå°å‡º

3. **è‡ªå‹•åŒ–éƒ¨ç½²è…³æœ¬**
   å¯¦ç¾ä¸€å€‹è‡ªå‹•åŒ–éƒ¨ç½²ç³»çµ±ï¼š
   - ä»£ç¢¼æ›´æ–°
   - ç’°å¢ƒé…ç½®
   - æœå‹™é‡å•Ÿ
   - éƒ¨ç½²å›æ»¾

## å°æé†’ ğŸ’¡

1. ç³»çµ±å®‰å…¨
   - æ¬Šé™æ§åˆ¶
   - æ•¸æ“šåŠ å¯†
   - å®‰å…¨å¯©è¨ˆ
   - å‚™ä»½æ¢å¾©

2. æ€§èƒ½å„ªåŒ–
   - è³‡æºç›£æ§
   - æ€§èƒ½åˆ†æ
   - å„ªåŒ–é…ç½®
   - è² è¼‰å‡è¡¡

3. å¯é æ€§
   - éŒ¯èª¤è™•ç†
   - æ•…éšœè½‰ç§»
   - ç›£æ§å‘Šè­¦
   - è‡ªå‹•æ¢å¾©

4. æœ€ä½³å¯¦è¸
   - æ–‡æª”å®Œå–„
   - ä»£ç¢¼ç‰ˆæœ¬æ§åˆ¶
   - å®šæœŸç¶­è­·
   - æ‡‰æ€¥é æ¡ˆ

[ä¸Šä¸€ç« ï¼šé€²éšç¶²é çˆ¬èŸ²](057_é€²éšç¶²é çˆ¬èŸ².md) | [ä¸‹ä¸€ç« ï¼šé›²ç«¯éƒ¨ç½²èˆ‡æœå‹™](059_é›²ç«¯éƒ¨ç½²èˆ‡æœå‹™.md) 