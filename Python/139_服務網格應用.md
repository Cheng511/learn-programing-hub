[ä¸Šä¸€ç« ï¼šå¾®æœå‹™æ¶æ§‹è¨­è¨ˆ](138_å¾®æœå‹™æ¶æ§‹è¨­è¨ˆ.md) | [ä¸‹ä¸€ç« ï¼šäº‹ä»¶é©…å‹•æ¶æ§‹](140_äº‹ä»¶é©…å‹•æ¶æ§‹.md)

# Python æœå‹™ç¶²æ ¼æ‡‰ç”¨ ğŸŒ

## 1. Istio é›†æˆ

### 1.1 æœå‹™ä»£ç†é…ç½®

```python
from kubernetes import client, config
from typing import Dict, List, Optional
import yaml

class IstioManager:
    """Istio ç®¡ç†å™¨"""
    def __init__(self):
        config.load_kube_config()
        self.custom_api = client.CustomObjectsApi()
    
    def apply_virtual_service(self,
                            name: str,
                            namespace: str,
                            hosts: List[str],
                            http_routes: List[Dict]) -> bool:
        """æ‡‰ç”¨è™›æ“¬æœå‹™"""
        try:
            virtual_service = {
                "apiVersion": "networking.istio.io/v1alpha3",
                "kind": "VirtualService",
                "metadata": {
                    "name": name,
                    "namespace": namespace
                },
                "spec": {
                    "hosts": hosts,
                    "http": http_routes
                }
            }
            
            self.custom_api.create_namespaced_custom_object(
                group="networking.istio.io",
                version="v1alpha3",
                namespace=namespace,
                plural="virtualservices",
                body=virtual_service
            )
            return True
        except Exception as e:
            print(f"Failed to apply virtual service: {e}")
            return False
    
    def apply_destination_rule(self,
                             name: str,
                             namespace: str,
                             host: str,
                             subsets: List[Dict]) -> bool:
        """æ‡‰ç”¨ç›®æ¨™è¦å‰‡"""
        try:
            destination_rule = {
                "apiVersion": "networking.istio.io/v1alpha3",
                "kind": "DestinationRule",
                "metadata": {
                    "name": name,
                    "namespace": namespace
                },
                "spec": {
                    "host": host,
                    "subsets": subsets
                }
            }
            
            self.custom_api.create_namespaced_custom_object(
                group="networking.istio.io",
                version="v1alpha3",
                namespace=namespace,
                plural="destinationrules",
                body=destination_rule
            )
            return True
        except Exception as e:
            print(f"Failed to apply destination rule: {e}")
            return False
```

### 1.2 æµé‡ç®¡ç†

```python
class TrafficManager:
    """æµé‡ç®¡ç†å™¨"""
    def __init__(self):
        self.istio = IstioManager()
    
    def setup_canary_routing(self,
                           service_name: str,
                           namespace: str,
                           stable_version: str,
                           canary_version: str,
                           canary_weight: int = 10) -> bool:
        """è¨­ç½®é‡‘çµ²é›€è·¯ç”±"""
        try:
            # å‰µå»ºè™›æ“¬æœå‹™
            http_routes = [{
                "route": [
                    {
                        "destination": {
                            "host": service_name,
                            "subset": "stable"
                        },
                        "weight": 100 - canary_weight
                    },
                    {
                        "destination": {
                            "host": service_name,
                            "subset": "canary"
                        },
                        "weight": canary_weight
                    }
                ]
            }]
            
            self.istio.apply_virtual_service(
                f"{service_name}-vsvc",
                namespace,
                [service_name],
                http_routes
            )
            
            # å‰µå»ºç›®æ¨™è¦å‰‡
            subsets = [
                {
                    "name": "stable",
                    "labels": {
                        "version": stable_version
                    }
                },
                {
                    "name": "canary",
                    "labels": {
                        "version": canary_version
                    }
                }
            ]
            
            self.istio.apply_destination_rule(
                f"{service_name}-dstrule",
                namespace,
                service_name,
                subsets
            )
            
            return True
        except Exception as e:
            print(f"Failed to setup canary routing: {e}")
            return False
```

## 2. å¯è§€æ¸¬æ€§

### 2.1 åˆ†å¸ƒå¼è¿½è¸ª

```python
from opentelemetry import trace
from opentelemetry.exporter.jaeger.thrift import JaegerExporter
from opentelemetry.sdk.trace import TracerProvider
from opentelemetry.sdk.trace.export import BatchSpanProcessor
from typing import Dict, Optional

class TracingManager:
    """è¿½è¸ªç®¡ç†å™¨"""
    def __init__(self,
                 service_name: str,
                 agent_host: str = "localhost",
                 agent_port: int = 6831):
        # è¨­ç½®è¿½è¸ªæä¾›è€…
        trace.set_tracer_provider(TracerProvider())
        
        # é…ç½® Jaeger å°å‡ºå™¨
        jaeger_exporter = JaegerExporter(
            agent_host_name=agent_host,
            agent_port=agent_port
        )
        
        # æ·»åŠ æ‰¹è™•ç†å™¨
        span_processor = BatchSpanProcessor(jaeger_exporter)
        trace.get_tracer_provider().add_span_processor(span_processor)
        
        self.tracer = trace.get_tracer(service_name)
    
    def create_span(self,
                   name: str,
                   parent_context: Optional[trace.SpanContext] = None,
                   attributes: Optional[Dict] = None):
        """å‰µå»ºè¿½è¸ªæ®µ"""
        context = trace.set_span_in_context(parent_context) if parent_context \
            else None
        
        return self.tracer.start_span(
            name,
            context=context,
            attributes=attributes
        )
    
    def inject_context(self,
                      headers: Dict,
                      context: Optional[trace.SpanContext] = None):
        """æ³¨å…¥è¿½è¸ªä¸Šä¸‹æ–‡"""
        if not context:
            context = trace.get_current_span().get_span_context()
        
        carrier = {}
        trace.inject(carrier)
        headers.update(carrier)
```

### 2.2 æŒ‡æ¨™æ”¶é›†

```python
from prometheus_client import Counter, Gauge, Histogram, start_http_server
from typing import Dict, Optional

class MetricsCollector:
    """æŒ‡æ¨™æ”¶é›†å™¨"""
    def __init__(self,
                 service_name: str,
                 port: int = 8000):
        self.service_name = service_name
        
        # è«‹æ±‚è¨ˆæ•¸å™¨
        self.request_counter = Counter(
            f"{service_name}_requests_total",
            "Total number of requests",
            ["method", "endpoint", "status"]
        )
        
        # éŸ¿æ‡‰æ™‚é–“ç›´æ–¹åœ–
        self.response_time = Histogram(
            f"{service_name}_response_time_seconds",
            "Response time in seconds",
            ["method", "endpoint"]
        )
        
        # ä¸¦ç™¼è«‹æ±‚é‡
        self.concurrent_requests = Gauge(
            f"{service_name}_concurrent_requests",
            "Number of concurrent requests",
            ["endpoint"]
        )
        
        # å•Ÿå‹•æŒ‡æ¨™æœå‹™å™¨
        start_http_server(port)
    
    def record_request(self,
                      method: str,
                      endpoint: str,
                      status: str):
        """è¨˜éŒ„è«‹æ±‚"""
        self.request_counter.labels(
            method=method,
            endpoint=endpoint,
            status=status
        ).inc()
    
    def record_response_time(self,
                           method: str,
                           endpoint: str,
                           duration: float):
        """è¨˜éŒ„éŸ¿æ‡‰æ™‚é–“"""
        self.response_time.labels(
            method=method,
            endpoint=endpoint
        ).observe(duration)
    
    def track_concurrent_requests(self,
                                endpoint: str):
        """è¿½è¸ªä¸¦ç™¼è«‹æ±‚"""
        return self.concurrent_requests.labels(endpoint=endpoint).track_inprogress()
```

## 3. å®‰å…¨ç®¡ç†

### 3.1 èªè­‰æˆæ¬Š

```python
from typing import Dict, List, Optional
import jwt
from datetime import datetime, timedelta

class SecurityManager:
    """å®‰å…¨ç®¡ç†å™¨"""
    def __init__(self,
                 secret_key: str,
                 token_expiration: int = 3600):
        self.secret_key = secret_key
        self.token_expiration = token_expiration
    
    def generate_jwt(self,
                    subject: str,
                    claims: Dict) -> str:
        """ç”Ÿæˆ JWT"""
        try:
            payload = {
                "sub": subject,
                "exp": datetime.utcnow() + timedelta(
                    seconds=self.token_expiration
                ),
                "iat": datetime.utcnow(),
                **claims
            }
            
            return jwt.encode(
                payload,
                self.secret_key,
                algorithm="HS256"
            )
        except Exception as e:
            print(f"Failed to generate JWT: {e}")
            return ""
    
    def verify_jwt(self,
                   token: str) -> Optional[Dict]:
        """é©—è­‰ JWT"""
        try:
            return jwt.decode(
                token,
                self.secret_key,
                algorithms=["HS256"]
            )
        except jwt.InvalidTokenError as e:
            print(f"Invalid token: {e}")
            return None
```

### 3.2 mTLS é…ç½®

```python
class MTLSConfig:
    """mTLS é…ç½®ç®¡ç†å™¨"""
    def __init__(self):
        self.istio = IstioManager()
    
    def enable_mtls(self,
                    namespace: str,
                    mode: str = "STRICT") -> bool:
        """å•Ÿç”¨ mTLS"""
        try:
            peer_authentication = {
                "apiVersion": "security.istio.io/v1beta1",
                "kind": "PeerAuthentication",
                "metadata": {
                    "name": f"{namespace}-mtls",
                    "namespace": namespace
                },
                "spec": {
                    "mtls": {
                        "mode": mode
                    }
                }
            }
            
            self.istio.custom_api.create_namespaced_custom_object(
                group="security.istio.io",
                version="v1beta1",
                namespace=namespace,
                plural="peerauthentications",
                body=peer_authentication
            )
            return True
        except Exception as e:
            print(f"Failed to enable mTLS: {e}")
            return False
    
    def configure_destination_rule(self,
                                 name: str,
                                 namespace: str,
                                 host: str) -> bool:
        """é…ç½®ç›®æ¨™è¦å‰‡"""
        try:
            destination_rule = {
                "apiVersion": "networking.istio.io/v1alpha3",
                "kind": "DestinationRule",
                "metadata": {
                    "name": name,
                    "namespace": namespace
                },
                "spec": {
                    "host": host,
                    "trafficPolicy": {
                        "tls": {
                            "mode": "ISTIO_MUTUAL"
                        }
                    }
                }
            }
            
            self.istio.custom_api.create_namespaced_custom_object(
                group="networking.istio.io",
                version="v1alpha3",
                namespace=namespace,
                plural="destinationrules",
                body=destination_rule
            )
            return True
        except Exception as e:
            print(f"Failed to configure destination rule: {e}")
            return False
```

## ç·´ç¿’é¡Œ ğŸƒâ€â™‚ï¸

1. å¯¦ç¾å®Œæ•´çš„æœå‹™ç¶²æ ¼éƒ¨ç½²ï¼š
   - Istio å®‰è£é…ç½®
   - Sidecar æ³¨å…¥
   - æµé‡ç®¡ç†è¦å‰‡
   - å®‰å…¨ç­–ç•¥è¨­ç½®
   - ç›£æ§é›†æˆ

2. é–‹ç™¼æµé‡ç®¡ç†å·¥å…·ï¼š
   - è·¯ç”±è¦å‰‡é…ç½®
   - è² è¼‰å‡è¡¡ç­–ç•¥
   - æ•…éšœæ³¨å…¥
   - æµé‡é¡åƒ
   - è¶…æ™‚é‡è©¦

3. å¯¦ç¾å¯è§€æ¸¬æ€§ç³»çµ±ï¼š
   - åˆ†å¸ƒå¼è¿½è¸ª
   - æŒ‡æ¨™ç›£æ§
   - æ—¥èªŒèšåˆ
   - æ€§èƒ½åˆ†æ
   - å‘Šè­¦é…ç½®

4. å‰µå»ºå®‰å…¨ç®¡ç†æ¡†æ¶ï¼š
   - èº«ä»½èªè­‰
   - è¨ªå•æ§åˆ¶
   - mTLS é…ç½®
   - å¯†é‘°ç®¡ç†
   - å®‰å…¨å¯©è¨ˆ

5. é–‹ç™¼æœå‹™ç¶²æ ¼æ§åˆ¶é¢æ¿ï¼š
   - æœå‹™æ‹“æ’²
   - æµé‡è¦–åœ–
   - æ€§èƒ½æŒ‡æ¨™
   - é…ç½®ç®¡ç†
   - å•é¡Œè¨ºæ–·

## å°çµ ğŸ“

- äº†è§£äº†æœå‹™ç¶²æ ¼çš„æ ¸å¿ƒæ¦‚å¿µ
- æŒæ¡äº† Istio çš„é…ç½®å’Œä½¿ç”¨
- å­¸æœƒäº†æµé‡ç®¡ç†çš„å¯¦ç¾æ–¹æ³•
- ç†è§£äº†å¯è§€æ¸¬æ€§çš„é‡è¦æ€§
- æŒæ¡äº†æœå‹™ç¶²æ ¼çš„å®‰å…¨ç®¡ç†

## å»¶ä¼¸é–±è®€ ğŸ“š

1. Istio å¯¦æˆ°æŒ‡å—
2. æœå‹™ç¶²æ ¼æ¶æ§‹æ¨¡å¼
3. é›¶ä¿¡ä»»å®‰å…¨æ¶æ§‹
4. å¯è§€æ¸¬æ€§å·¥ç¨‹å¯¦è¸
5. é›²åŸç”Ÿç¶²çµ¡å®‰å…¨

[ä¸Šä¸€ç« ï¼šå¾®æœå‹™æ¶æ§‹è¨­è¨ˆ](138_å¾®æœå‹™æ¶æ§‹è¨­è¨ˆ.md) | [ä¸‹ä¸€ç« ï¼šäº‹ä»¶é©…å‹•æ¶æ§‹](140_äº‹ä»¶é©…å‹•æ¶æ§‹.md) 