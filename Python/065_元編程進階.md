[ä¸Šä¸€ç« ï¼šå…ƒç·¨ç¨‹åŸºç¤](064_å…ƒç·¨ç¨‹åŸºç¤.md) | [ä¸‹ä¸€ç« ï¼šSocketç·¨ç¨‹åŸºç¤](066_Socketç·¨ç¨‹åŸºç¤.md)

# Python å…ƒç·¨ç¨‹é€²éš ğŸ”®

## é€²éšå…ƒé¡æŠ€è¡“

### 1. æŠ½è±¡åŸºé¡å…ƒé¡

```python
from abc import ABCMeta, abstractmethod
from typing import Dict, Any, Type

class PluginMeta(ABCMeta):
    plugins: Dict[str, Type] = {}
    
    def __new__(mcs, name, bases, namespace):
        cls = super().__new__(mcs, name, bases, namespace)
        if hasattr(cls, 'plugin_name'):
            mcs.plugins[cls.plugin_name] = cls
        return cls
    
    @classmethod
    def get_plugin(mcs, name: str) -> Type:
        return mcs.plugins[name]

class Plugin(metaclass=PluginMeta):
    @abstractmethod
    def execute(self, *args, **kwargs) -> Any:
        pass

# å…·é«”æ’ä»¶å¯¦ç¾
class TextPlugin(Plugin):
    plugin_name = 'text'
    
    def execute(self, text: str) -> str:
        return text.upper()

class NumberPlugin(Plugin):
    plugin_name = 'number'
    
    def execute(self, number: int) -> int:
        return number * 2

# ä½¿ç”¨ç¤ºä¾‹
def process_data(plugin_name: str, data: Any) -> Any:
    plugin_cls = PluginMeta.get_plugin(plugin_name)
    plugin = plugin_cls()
    return plugin.execute(data)

# æ¸¬è©¦
print(process_data('text', 'hello'))  # HELLO
print(process_data('number', 5))      # 10
```

### 2. è‡ªå®šç¾©å±¬æ€§è¨ªå•

```python
class LazyAttribute:
    def __init__(self, func):
        self.func = func
        self.name = func.__name__
    
    def __get__(self, instance, owner):
        if instance is None:
            return self
        value = self.func(instance)
        setattr(instance, self.name, value)
        return value

class MetaLazy(type):
    def __new__(mcs, name, bases, namespace):
        for key, value in namespace.items():
            if callable(value) and hasattr(value, '_lazy'):
                namespace[key] = LazyAttribute(value)
        return super().__new__(mcs, name, bases, namespace)

def lazy_property(func):
    func._lazy = True
    return func

# ä½¿ç”¨ç¤ºä¾‹
class ExpensiveCalculation(metaclass=MetaLazy):
    def __init__(self, data):
        self.data = data
    
    @lazy_property
    def result(self):
        print("Calculating result...")
        import time
        time.sleep(1)  # æ¨¡æ“¬è€—æ™‚è¨ˆç®—
        return sum(x * x for x in self.data)

# æ¸¬è©¦
calc = ExpensiveCalculation([1, 2, 3, 4, 5])
print("Object created")
print(f"First access: {calc.result}")  # æœƒåŸ·è¡Œè¨ˆç®—
print(f"Second access: {calc.result}") # ç›´æ¥è¿”å›ç·©å­˜å€¼
```

## å‹•æ…‹ä»£ç¢¼åŸ·è¡Œé€²éš

### 1. å®‰å…¨çš„ä»£ç¢¼åŸ·è¡Œ

```python
import ast
from typing import Dict, Any

class CodeValidator(ast.NodeVisitor):
    def __init__(self):
        self.errors = []
    
    def visit_Call(self, node):
        if isinstance(node.func, ast.Name):
            if node.func.id in ['eval', 'exec', '__import__']:
                self.errors.append(
                    f"Forbidden function call: {node.func.id}"
                )
        self.generic_visit(node)
    
    def visit_Import(self, node):
        self.errors.append("Import statements are not allowed")
    
    def visit_ImportFrom(self, node):
        self.errors.append("Import statements are not allowed")

def safe_eval(code: str, globals_dict: Dict[str, Any] = None) -> Any:
    """å®‰å…¨åœ°åŸ·è¡ŒPythonä»£ç¢¼"""
    try:
        # è§£æä»£ç¢¼
        tree = ast.parse(code, mode='eval')
        
        # é©—è­‰ä»£ç¢¼å®‰å…¨æ€§
        validator = CodeValidator()
        validator.visit(tree)
        
        if validator.errors:
            raise ValueError("\n".join(validator.errors))
        
        # ç·¨è­¯å’ŒåŸ·è¡Œä»£ç¢¼
        compiled_code = compile(tree, '<string>', 'eval')
        return eval(compiled_code, globals_dict or {}, {})
    
    except SyntaxError as e:
        raise ValueError(f"Syntax error: {e}")
    except Exception as e:
        raise ValueError(f"Evaluation error: {e}")

# ä½¿ç”¨ç¤ºä¾‹
try:
    # å®‰å…¨çš„è¨ˆç®—
    result = safe_eval("2 + 2 * 3")
    print(f"Safe calculation: {result}")
    
    # ä¸å®‰å…¨çš„æ“ä½œ
    result = safe_eval("__import__('os').system('dir')")
except ValueError as e:
    print(f"Error: {e}")
```

### 2. å‹•æ…‹ä»£ç¢¼ç”Ÿæˆå™¨

```python
from typing import List, Dict, Any
import ast
import inspect

class CodeGenerator:
    def __init__(self):
        self.imports: List[str] = []
        self.functions: List[str] = []
        self.classes: List[str] = []
    
    def add_import(self, module: str, names: List[str] = None):
        if names:
            self.imports.append(f"from {module} import {', '.join(names)}")
        else:
            self.imports.append(f"import {module}")
    
    def add_function(self, name: str, args: List[str],
                    body: List[str], decorators: List[str] = None):
        func = []
        if decorators:
            func.extend(f"@{d}" for d in decorators)
        
        signature = f"def {name}({', '.join(args)}):"
        func.append(signature)
        func.extend(f"    {line}" for line in body)
        self.functions.append("\n".join(func))
    
    def add_class(self, name: str, bases: List[str],
                 methods: Dict[str, List[str]],
                 decorators: List[str] = None):
        cls = []
        if decorators:
            cls.extend(f"@{d}" for d in decorators)
        
        bases_str = f"({', '.join(bases)})" if bases else ""
        cls.append(f"class {name}{bases_str}:")
        
        for method_name, body in methods.items():
            cls.append(f"    def {method_name}(self):")
            cls.extend(f"        {line}" for line in body)
        
        self.classes.append("\n".join(cls))
    
    def generate(self) -> str:
        """ç”Ÿæˆå®Œæ•´çš„ä»£ç¢¼"""
        parts = []
        
        # æ·»åŠ å°å…¥èªå¥
        if self.imports:
            parts.extend(self.imports)
            parts.append("")
        
        # æ·»åŠ å‡½æ•¸å®šç¾©
        if self.functions:
            parts.extend(self.functions)
            parts.append("")
        
        # æ·»åŠ é¡å®šç¾©
        if self.classes:
            parts.extend(self.classes)
        
        return "\n".join(parts)

# ä½¿ç”¨ç¤ºä¾‹
generator = CodeGenerator()

# æ·»åŠ å°å…¥
generator.add_import("dataclasses", ["dataclass"])
generator.add_import("typing", ["List", "Optional"])

# æ·»åŠ é¡
generator.add_class(
    name="Person",
    bases=["object"],
    decorators=["@dataclass"],
    methods={
        "__init__": [
            "self.name: str = name",
            "self.age: int = age"
        ],
        "greet": [
            'return f"Hello, {self.name}!"'
        ]
    }
)

# ç”Ÿæˆä»£ç¢¼
code = generator.generate()
print("Generated code:")
print(code)

# åŸ·è¡Œç”Ÿæˆçš„ä»£ç¢¼
exec(code)
person = Person("Alice", 30)
print(person.greet())
```

## å…ƒç·¨ç¨‹æ¨¡å¼

### 1. è¨»å†Šæ¨¡å¼

```python
from typing import Dict, Type, Any
from functools import wraps

class Registry:
    def __init__(self):
        self._handlers: Dict[str, Type] = {}
    
    def register(self, name: str = None):
        def decorator(cls: Type) -> Type:
            nonlocal name
            key = name or cls.__name__
            self._handlers[key] = cls
            return cls
        return decorator
    
    def get_handler(self, name: str) -> Type:
        if name not in self._handlers:
            raise KeyError(f"No handler registered for {name}")
        return self._handlers[name]
    
    def create(self, name: str, *args, **kwargs) -> Any:
        handler = self.get_handler(name)
        return handler(*args, **kwargs)

# ä½¿ç”¨ç¤ºä¾‹
handlers = Registry()

@handlers.register()
class JSONHandler:
    def process(self, data: dict) -> str:
        import json
        return json.dumps(data)

@handlers.register()
class XMLHandler:
    def process(self, data: dict) -> str:
        import xml.etree.ElementTree as ET
        root = ET.Element("root")
        for key, value in data.items():
            child = ET.SubElement(root, key)
            child.text = str(value)
        return ET.tostring(root, encoding='unicode')

# æ¸¬è©¦
data = {"name": "John", "age": 30}
json_handler = handlers.create("JSONHandler")
xml_handler = handlers.create("XMLHandler")

print(json_handler.process(data))
print(xml_handler.process(data))
```

### 2. é…ç½®ç®¡ç†æ¨¡å¼

```python
from typing import Any, Dict, Optional
import json
from pathlib import Path

class ConfigField:
    def __init__(self, field_type: type,
                 required: bool = True,
                 default: Any = None):
        self.field_type = field_type
        self.required = required
        self.default = default
        self.name = None
    
    def __set_name__(self, owner, name):
        self.name = name
    
    def __get__(self, instance, owner):
        if instance is None:
            return self
        return instance._values.get(self.name, self.default)
    
    def __set__(self, instance, value):
        if value is not None and not isinstance(value, self.field_type):
            try:
                value = self.field_type(value)
            except (ValueError, TypeError):
                raise TypeError(
                    f"{self.name} must be of type {self.field_type.__name__}"
                )
        instance._values[self.name] = value

class ConfigMeta(type):
    def __new__(mcs, name, bases, namespace):
        fields = {}
        for key, value in namespace.items():
            if isinstance(value, ConfigField):
                fields[key] = value
        
        namespace['_fields'] = fields
        return super().__new__(mcs, name, bases, namespace)

class Config(metaclass=ConfigMeta):
    def __init__(self):
        self._values: Dict[str, Any] = {}
    
    @classmethod
    def load_file(cls, path: Path) -> 'Config':
        instance = cls()
        
        if path.exists():
            with open(path) as f:
                data = json.load(f)
            
            for name, field in cls._fields.items():
                if name in data:
                    setattr(instance, name, data[name])
                elif field.required and field.default is None:
                    raise ValueError(f"Missing required field: {name}")
        
        return instance
    
    def save_file(self, path: Path):
        with open(path, 'w') as f:
            json.dump(self._values, f, indent=2)
    
    def __str__(self):
        items = [f"{k}={v!r}" for k, v in self._values.items()]
        return f"{self.__class__.__name__}({', '.join(items)})"

# ä½¿ç”¨ç¤ºä¾‹
class AppConfig(Config):
    host = ConfigField(str, default="localhost")
    port = ConfigField(int, default=8080)
    debug = ConfigField(bool, default=False)
    secret_key = ConfigField(str, required=True)
    database_url = ConfigField(str, required=True)

# å‰µå»ºç¤ºä¾‹é…ç½®æ–‡ä»¶
config_data = {
    "host": "example.com",
    "port": 443,
    "debug": True,
    "secret_key": "your-secret-key",
    "database_url": "postgresql://user:pass@localhost/db"
}

config_path = Path("config.json")
with open(config_path, 'w') as f:
    json.dump(config_data, f)

# åŠ è¼‰é…ç½®
config = AppConfig.load_file(config_path)
print(config)

# ä¿®æ”¹é…ç½®
config.debug = False
config.save_file(config_path)
```

## å¯¦æˆ°ç¤ºä¾‹

### 1. APIè·¯ç”±è£é£¾å™¨

```python
from typing import Callable, Dict, Any, List, Optional
from functools import wraps
import inspect

class APIRouter:
    def __init__(self):
        self.routes: Dict[str, Dict[str, Callable]] = {}
        self.middlewares: List[Callable] = []
    
    def route(self, path: str, methods: List[str] = None):
        methods = methods or ['GET']
        
        def decorator(func: Callable) -> Callable:
            for method in methods:
                if path not in self.routes:
                    self.routes[path] = {}
                self.routes[path][method.upper()] = func
            return func
        return decorator
    
    def middleware(self, func: Callable) -> Callable:
        self.middlewares.append(func)
        return func
    
    async def handle_request(self, path: str,
                           method: str,
                           **kwargs) -> Any:
        if path not in self.routes:
            raise ValueError(f"No route for path: {path}")
        
        method_handlers = self.routes[path]
        if method.upper() not in method_handlers:
            raise ValueError(
                f"Method {method} not allowed for path: {path}"
            )
        
        handler = method_handlers[method.upper()]
        
        # æ‡‰ç”¨ä¸­é–“ä»¶
        result = kwargs
        for middleware in self.middlewares:
            result = await middleware(result)
        
        # èª¿ç”¨è™•ç†å‡½æ•¸
        return await handler(**result)

# ä½¿ç”¨ç¤ºä¾‹
router = APIRouter()

@router.middleware
async def auth_middleware(data: Dict[str, Any]) -> Dict[str, Any]:
    if 'token' not in data:
        raise ValueError("Missing authentication token")
    # é©—è­‰token...
    return data

@router.route('/users', methods=['GET'])
async def get_users(**kwargs):
    return {"users": ["user1", "user2"]}

@router.route('/users', methods=['POST'])
async def create_user(**kwargs):
    return {"message": "User created"}

# æ¸¬è©¦
async def main():
    # æˆåŠŸçš„è«‹æ±‚
    try:
        result = await router.handle_request(
            '/users',
            'GET',
            token='valid-token'
        )
        print(f"Success: {result}")
    except ValueError as e:
        print(f"Error: {e}")
    
    # å¤±æ•—çš„è«‹æ±‚
    try:
        result = await router.handle_request(
            '/users',
            'GET'
        )
        print(f"Success: {result}")
    except ValueError as e:
        print(f"Error: {e}")

# é‹è¡Œæ¸¬è©¦
import asyncio
asyncio.run(main())
```

### 2. ORMæŸ¥è©¢æ§‹å»ºå™¨

```python
from typing import List, Any, Type, Dict, Optional
import sqlite3

class Field:
    def __init__(self, field_type: Type,
                 primary_key: bool = False,
                 nullable: bool = True):
        self.field_type = field_type
        self.primary_key = primary_key
        self.nullable = nullable
        self.name = None
    
    def __set_name__(self, owner, name):
        self.name = name

class ModelMeta(type):
    def __new__(mcs, name, bases, namespace):
        if name == 'Model':
            return super().__new__(mcs, name, bases, namespace)
        
        # æ”¶é›†å­—æ®µä¿¡æ¯
        fields = {}
        for key, value in namespace.items():
            if isinstance(value, Field):
                fields[key] = value
        
        namespace['_fields'] = fields
        namespace['_table_name'] = name.lower()
        
        # å‰µå»ºæŸ¥è©¢æ§‹å»ºå™¨
        def select(cls, *fields) -> 'QueryBuilder':
            return QueryBuilder(cls).select(*fields)
        
        def where(cls, **conditions) -> 'QueryBuilder':
            return QueryBuilder(cls).where(**conditions)
        
        namespace['select'] = classmethod(select)
        namespace['where'] = classmethod(where)
        
        return super().__new__(mcs, name, bases, namespace)

class QueryBuilder:
    def __init__(self, model_cls: Type['Model']):
        self.model_cls = model_cls
        self.selected_fields: List[str] = []
        self.conditions: Dict[str, Any] = {}
        self.order_by_field: Optional[str] = None
        self.order_desc: bool = False
        self.limit_val: Optional[int] = None
        self.offset_val: Optional[int] = None
    
    def select(self, *fields) -> 'QueryBuilder':
        self.selected_fields = fields or self.model_cls._fields.keys()
        return self
    
    def where(self, **conditions) -> 'QueryBuilder':
        self.conditions.update(conditions)
        return self
    
    def order_by(self, field: str, desc: bool = False) -> 'QueryBuilder':
        self.order_by_field = field
        self.order_desc = desc
        return self
    
    def limit(self, limit: int, offset: int = 0) -> 'QueryBuilder':
        self.limit_val = limit
        self.offset_val = offset
        return self
    
    def build_query(self) -> tuple[str, list]:
        # æ§‹å»ºSELECTå­å¥
        fields = ', '.join(self.selected_fields)
        query = f"SELECT {fields} FROM {self.model_cls._table_name}"
        
        # æ§‹å»ºWHEREå­å¥
        params = []
        if self.conditions:
            conditions = []
            for key, value in self.conditions.items():
                conditions.append(f"{key} = ?")
                params.append(value)
            query += " WHERE " + " AND ".join(conditions)
        
        # æ·»åŠ ORDER BY
        if self.order_by_field:
            query += f" ORDER BY {self.order_by_field}"
            if self.order_desc:
                query += " DESC"
        
        # æ·»åŠ LIMITå’ŒOFFSET
        if self.limit_val is not None:
            query += f" LIMIT {self.limit_val}"
            if self.offset_val:
                query += f" OFFSET {self.offset_val}"
        
        return query, params
    
    def all(self) -> List['Model']:
        query, params = self.build_query()
        cursor = self.model_cls._connection.execute(query, params)
        return [
            self.model_cls(**dict(zip(self.selected_fields, row)))
            for row in cursor.fetchall()
        ]
    
    def first(self) -> Optional['Model']:
        self.limit(1)
        results = self.all()
        return results[0] if results else None

class Model(metaclass=ModelMeta):
    _connection: sqlite3.Connection = None
    
    def __init__(self, **kwargs):
        for name, field in self._fields.items():
            value = kwargs.get(name)
            if value is None and not field.nullable:
                raise ValueError(f"Field {name} cannot be null")
            setattr(self, name, value)
    
    @classmethod
    def set_connection(cls, connection: sqlite3.Connection):
        cls._connection = connection
    
    @classmethod
    def create_table(cls):
        fields = []
        for name, field in cls._fields.items():
            field_def = f"{name} {field.field_type.__name__.upper()}"
            if field.primary_key:
                field_def += " PRIMARY KEY"
            if not field.nullable:
                field_def += " NOT NULL"
            fields.append(field_def)
        
        query = f"CREATE TABLE IF NOT EXISTS {cls._table_name} "
        query += f"({', '.join(fields)})"
        
        cls._connection.execute(query)
        cls._connection.commit()
    
    def save(self):
        fields = []
        values = []
        for name, field in self._fields.items():
            value = getattr(self, name)
            if value is not None or not field.nullable:
                fields.append(name)
                values.append(value)
        
        placeholders = ', '.join(['?' for _ in values])
        query = f"INSERT INTO {self._table_name} "
        query += f"({', '.join(fields)}) VALUES ({placeholders})"
        
        self._connection.execute(query, values)
        self._connection.commit()

# ä½¿ç”¨ç¤ºä¾‹
class User(Model):
    id = Field(int, primary_key=True)
    name = Field(str, nullable=False)
    email = Field(str)
    age = Field(int)

# è¨­ç½®æ•¸æ“šåº«é€£æ¥
conn = sqlite3.connect(':memory:')
User.set_connection(conn)

# å‰µå»ºè¡¨
User.create_table()

# æ’å…¥æ•¸æ“š
user1 = User(id=1, name="John", email="john@example.com", age=30)
user2 = User(id=2, name="Alice", email="alice@example.com", age=25)
user1.save()
user2.save()

# æŸ¥è©¢ç¤ºä¾‹
# æŸ¥è©¢æ‰€æœ‰ç”¨æˆ¶
all_users = User.select().all()
print("All users:", all_users)

# æ¢ä»¶æŸ¥è©¢
john = User.where(name="John").first()
print("John:", john)

# è¤‡é›œæŸ¥è©¢
young_users = (
    User.select('name', 'age')
    .where(age=25)
    .order_by('name')
    .limit(10)
    .all()
)
print("Young users:", young_users)
```

## ç·´ç¿’é¡Œ

1. **å…ƒé¡ç¹¼æ‰¿ç³»çµ±**
   å¯¦ç¾ä¸€å€‹åŸºæ–¼å…ƒé¡çš„ç¹¼æ‰¿ç³»çµ±ï¼š
   - æ”¯æŒå¤šé‡ç¹¼æ‰¿
   - è™•ç†æ–¹æ³•è§£æé †åº
   - å¯¦ç¾æ¥å£æª¢æŸ¥
   - æ·»åŠ é¡å‹é©—è­‰

2. **DSLæ§‹å»ºå™¨**
   å‰µå»ºä¸€å€‹é ˜åŸŸç‰¹å®šèªè¨€æ§‹å»ºå™¨ï¼š
   - å®šç¾©èªæ³•è¦å‰‡
   - å¯¦ç¾è§£æå™¨
   - ç”ŸæˆåŸ·è¡Œä»£ç¢¼
   - æä¾›éŒ¯èª¤è™•ç†

3. **æ’ä»¶ç³»çµ±**
   é–‹ç™¼ä¸€å€‹æ’ä»¶ç®¡ç†ç³»çµ±ï¼š
   - å‹•æ…‹åŠ è¼‰æ’ä»¶
   - ç®¡ç†ä¾è³´é—œä¿‚
   - æä¾›ç”Ÿå‘½é€±æœŸ
   - å¯¦ç¾ç†±æ’æ‹”

## å°æé†’ ğŸ’¡

1. å…ƒç·¨ç¨‹æ‡‰ç”¨
   - è¬¹æ…ä½¿ç”¨åå°„
   - æ³¨æ„æ€§èƒ½å½±éŸ¿
   - ä¿æŒä»£ç¢¼å¯è®€
   - æä¾›å®Œæ•´æ–‡æª”

2. ä»£ç¢¼ç”Ÿæˆ
   - é©—è­‰ç”Ÿæˆçš„ä»£ç¢¼
   - è™•ç†ç•°å¸¸æƒ…æ³
   - è€ƒæ…®å®‰å…¨å•é¡Œ
   - å„ªåŒ–ç”Ÿæˆæ•ˆç‡

3. æœ€ä½³å¯¦è¸
   - éµå¾ªSOLIDåŸå‰‡
   - é¿å…éåº¦æŠ½è±¡
   - ä¿æŒç°¡å–®æ˜äº†
   - ç·¨å¯«å–®å…ƒæ¸¬è©¦

4. æ€§èƒ½è€ƒæ…®
   - ç·©å­˜å…ƒæ•¸æ“š
   - æ¸›å°‘å‹•æ…‹ç”Ÿæˆ
   - å„ªåŒ–æŸ¥æ‰¾éç¨‹
   - ç›£æ§è³‡æºä½¿ç”¨

[ä¸Šä¸€ç« ï¼šå…ƒç·¨ç¨‹åŸºç¤](064_å…ƒç·¨ç¨‹åŸºç¤.md) | [ä¸‹ä¸€ç« ï¼šSocketç·¨ç¨‹åŸºç¤](066_Socketç·¨ç¨‹åŸºç¤.md) 