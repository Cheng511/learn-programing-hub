[ä¸Šä¸€ç« ï¼šç¶²çµ¡å®‰å…¨åŸºç¤](070_ç¶²çµ¡å®‰å…¨åŸºç¤.md) | [ä¸‹ä¸€ç« ï¼šç¶²çµ¡æ”»é˜²åŸºç¤](072_ç¶²çµ¡æ”»é˜²åŸºç¤.md)

# Python ç¶²çµ¡å®‰å…¨é€²éš ğŸ”’

## æ•¸å­—ç°½å

### 1. RSAæ•¸å­—ç°½å

```python
from cryptography.hazmat.primitives import hashes, serialization
from cryptography.hazmat.primitives.asymmetric import padding, rsa
from cryptography.hazmat.backends import default_backend
from typing import Tuple, Optional
import base64

class RSASignature:
    def __init__(self):
        """åˆå§‹åŒ–ç°½åå™¨"""
        self.private_key = None
        self.public_key = None
        self.generate_key_pair()
    
    def generate_key_pair(self):
        """ç”Ÿæˆå¯†é‘°å°"""
        # ç”Ÿæˆç§é‘°
        self.private_key = rsa.generate_private_key(
            public_exponent=65537,
            key_size=2048,
            backend=default_backend()
        )
        
        # ç”Ÿæˆå…¬é‘°
        self.public_key = self.private_key.public_key()
    
    def get_public_key_pem(self) -> str:
        """ç²å–PEMæ ¼å¼çš„å…¬é‘°"""
        return self.public_key.public_bytes(
            encoding=serialization.Encoding.PEM,
            format=serialization.PublicFormat.SubjectPublicKeyInfo
        ).decode()
    
    def get_private_key_pem(self) -> str:
        """ç²å–PEMæ ¼å¼çš„ç§é‘°"""
        return self.private_key.private_bytes(
            encoding=serialization.Encoding.PEM,
            format=serialization.PrivateFormat.PKCS8,
            encryption_algorithm=serialization.NoEncryption()
        ).decode()
    
    def sign(self, message: str) -> str:
        """ç°½åæ¶ˆæ¯"""
        try:
            # å°‡æ¶ˆæ¯è½‰æ›ç‚ºå­—ç¯€
            message_bytes = message.encode()
            
            # å‰µå»ºç°½å
            signature = self.private_key.sign(
                message_bytes,
                padding.PSS(
                    mgf=padding.MGF1(hashes.SHA256()),
                    salt_length=padding.PSS.MAX_LENGTH
                ),
                hashes.SHA256()
            )
            
            # å°‡ç°½åè½‰æ›ç‚ºBase64å­—ç¬¦ä¸²
            return base64.b64encode(signature).decode()
        
        except Exception as e:
            print(f"Signing error: {e}")
            return ""
    
    def verify(self, message: str, signature: str) -> bool:
        """é©—è­‰ç°½å"""
        try:
            # å°‡ç°½åè½‰æ›ç‚ºå­—ç¯€
            signature_bytes = base64.b64decode(signature)
            
            # é©—è­‰ç°½å
            self.public_key.verify(
                signature_bytes,
                message.encode(),
                padding.PSS(
                    mgf=padding.MGF1(hashes.SHA256()),
                    salt_length=padding.PSS.MAX_LENGTH
                ),
                hashes.SHA256()
            )
            return True
        
        except Exception as e:
            print(f"Verification error: {e}")
            return False

# ä½¿ç”¨ç¤ºä¾‹
def main():
    # å‰µå»ºç°½åå™¨
    signer = RSASignature()
    
    # ç²å–å¯†é‘°
    public_key = signer.get_public_key_pem()
    private_key = signer.get_private_key_pem()
    
    print("Public Key:")
    print(public_key)
    print("\nPrivate Key:")
    print(private_key)
    
    # æ¸¬è©¦ç°½å
    message = "Hello, World!"
    print(f"\nOriginal message: {message}")
    
    signature = signer.sign(message)
    print(f"Signature: {signature}")
    
    # é©—è­‰ç°½å
    is_valid = signer.verify(message, signature)
    print(f"Signature valid: {is_valid}")
    
    # æ¸¬è©¦ç¯¡æ”¹æ¶ˆæ¯
    tampered_message = "Hello, World! (tampered)"
    is_valid = signer.verify(tampered_message, signature)
    print(f"Tampered message signature valid: {is_valid}")

if __name__ == '__main__':
    main()
```

### 2. DSAæ•¸å­—ç°½å

```python
from cryptography.hazmat.primitives import hashes, serialization
from cryptography.hazmat.primitives.asymmetric import dsa
from cryptography.hazmat.backends import default_backend
from typing import Tuple, Optional
import base64

class DSASignature:
    def __init__(self):
        """åˆå§‹åŒ–ç°½åå™¨"""
        self.private_key = None
        self.public_key = None
        self.generate_key_pair()
    
    def generate_key_pair(self):
        """ç”Ÿæˆå¯†é‘°å°"""
        # ç”Ÿæˆç§é‘°
        self.private_key = dsa.generate_private_key(
            key_size=2048,
            backend=default_backend()
        )
        
        # ç”Ÿæˆå…¬é‘°
        self.public_key = self.private_key.public_key()
    
    def get_public_key_pem(self) -> str:
        """ç²å–PEMæ ¼å¼çš„å…¬é‘°"""
        return self.public_key.public_bytes(
            encoding=serialization.Encoding.PEM,
            format=serialization.PublicFormat.SubjectPublicKeyInfo
        ).decode()
    
    def get_private_key_pem(self) -> str:
        """ç²å–PEMæ ¼å¼çš„ç§é‘°"""
        return self.private_key.private_bytes(
            encoding=serialization.Encoding.PEM,
            format=serialization.PrivateFormat.PKCS8,
            encryption_algorithm=serialization.NoEncryption()
        ).decode()
    
    def sign(self, message: str) -> str:
        """ç°½åæ¶ˆæ¯"""
        try:
            # å°‡æ¶ˆæ¯è½‰æ›ç‚ºå­—ç¯€
            message_bytes = message.encode()
            
            # å‰µå»ºç°½å
            signature = self.private_key.sign(
                message_bytes,
                hashes.SHA256()
            )
            
            # å°‡ç°½åè½‰æ›ç‚ºBase64å­—ç¬¦ä¸²
            return base64.b64encode(signature).decode()
        
        except Exception as e:
            print(f"Signing error: {e}")
            return ""
    
    def verify(self, message: str, signature: str) -> bool:
        """é©—è­‰ç°½å"""
        try:
            # å°‡ç°½åè½‰æ›ç‚ºå­—ç¯€
            signature_bytes = base64.b64decode(signature)
            
            # é©—è­‰ç°½å
            self.public_key.verify(
                signature_bytes,
                message.encode(),
                hashes.SHA256()
            )
            return True
        
        except Exception as e:
            print(f"Verification error: {e}")
            return False

# ä½¿ç”¨ç¤ºä¾‹
def main():
    # å‰µå»ºç°½åå™¨
    signer = DSASignature()
    
    # ç²å–å¯†é‘°
    public_key = signer.get_public_key_pem()
    private_key = signer.get_private_key_pem()
    
    print("Public Key:")
    print(public_key)
    print("\nPrivate Key:")
    print(private_key)
    
    # æ¸¬è©¦ç°½å
    message = "Hello, World!"
    print(f"\nOriginal message: {message}")
    
    signature = signer.sign(message)
    print(f"Signature: {signature}")
    
    # é©—è­‰ç°½å
    is_valid = signer.verify(message, signature)
    print(f"Signature valid: {is_valid}")
    
    # æ¸¬è©¦ç¯¡æ”¹æ¶ˆæ¯
    tampered_message = "Hello, World! (tampered)"
    is_valid = signer.verify(tampered_message, signature)
    print(f"Tampered message signature valid: {is_valid}")

if __name__ == '__main__':
    main()
```

## è­‰æ›¸ç®¡ç†

### 1. X.509è­‰æ›¸ç”Ÿæˆ

```python
from cryptography import x509
from cryptography.x509.oid import NameOID
from cryptography.hazmat.primitives import hashes, serialization
from cryptography.hazmat.primitives.asymmetric import rsa
from cryptography.hazmat.backends import default_backend
from datetime import datetime, timedelta
import os

class CertificateGenerator:
    def __init__(self):
        """åˆå§‹åŒ–è­‰æ›¸ç”Ÿæˆå™¨"""
        self.private_key = None
        self.public_key = None
        self.generate_key_pair()
    
    def generate_key_pair(self):
        """ç”Ÿæˆå¯†é‘°å°"""
        # ç”Ÿæˆç§é‘°
        self.private_key = rsa.generate_private_key(
            public_exponent=65537,
            key_size=2048,
            backend=default_backend()
        )
        
        # ç”Ÿæˆå…¬é‘°
        self.public_key = self.private_key.public_key()
    
    def generate_certificate(self,
                           common_name: str,
                           organization: str,
                           country: str,
                           days_valid: int = 365) -> Tuple[str, str]:
        """ç”ŸæˆX.509è­‰æ›¸"""
        try:
            # å‰µå»ºè­‰æ›¸ä¸»é«”
            subject = issuer = x509.Name([
                x509.NameAttribute(NameOID.COMMON_NAME, common_name),
                x509.NameAttribute(NameOID.ORGANIZATION_NAME, organization),
                x509.NameAttribute(NameOID.COUNTRY_NAME, country),
            ])
            
            # å‰µå»ºè­‰æ›¸
            cert = x509.CertificateBuilder().subject_name(
                subject
            ).issuer_name(
                issuer
            ).public_key(
                self.public_key
            ).serial_number(
                x509.random_serial_number()
            ).not_valid_before(
                datetime.utcnow()
            ).not_valid_after(
                datetime.utcnow() + timedelta(days=days_valid)
            ).add_extension(
                x509.SubjectAlternativeName([x509.DNSName(common_name)]),
                critical=False,
            ).sign(self.private_key, hashes.SHA256())
            
            # å°‡è­‰æ›¸å’Œç§é‘°è½‰æ›ç‚ºPEMæ ¼å¼
            cert_pem = cert.public_bytes(serialization.Encoding.PEM).decode()
            key_pem = self.private_key.private_bytes(
                encoding=serialization.Encoding.PEM,
                format=serialization.PrivateFormat.PKCS8,
                encryption_algorithm=serialization.NoEncryption()
            ).decode()
            
            return cert_pem, key_pem
        
        except Exception as e:
            print(f"Certificate generation error: {e}")
            return "", ""
    
    def save_certificate(self, cert_pem: str, key_pem: str,
                        cert_file: str, key_file: str):
        """ä¿å­˜è­‰æ›¸å’Œç§é‘°"""
        try:
            # ä¿å­˜è­‰æ›¸
            with open(cert_file, 'w') as f:
                f.write(cert_pem)
            
            # ä¿å­˜ç§é‘°
            with open(key_file, 'w') as f:
                f.write(key_pem)
            
            print(f"Certificate saved to {cert_file}")
            print(f"Private key saved to {key_file}")
        
        except Exception as e:
            print(f"Error saving certificate: {e}")

# ä½¿ç”¨ç¤ºä¾‹
def main():
    # å‰µå»ºè­‰æ›¸ç”Ÿæˆå™¨
    generator = CertificateGenerator()
    
    # ç”Ÿæˆè­‰æ›¸
    cert_pem, key_pem = generator.generate_certificate(
        common_name="example.com",
        organization="Example Organization",
        country="US"
    )
    
    if cert_pem and key_pem:
        # ä¿å­˜è­‰æ›¸å’Œç§é‘°
        generator.save_certificate(
            cert_pem,
            key_pem,
            "server.crt",
            "server.key"
        )
        
        # æ‰“å°è­‰æ›¸ä¿¡æ¯
        cert = x509.load_pem_x509_certificate(
            cert_pem.encode(),
            default_backend()
        )
        
        print("\nCertificate Information:")
        print(f"Subject: {cert.subject}")
        print(f"Issuer: {cert.issuer}")
        print(f"Serial Number: {cert.serial_number}")
        print(f"Valid From: {cert.not_valid_before}")
        print(f"Valid Until: {cert.not_valid_after}")

if __name__ == '__main__':
    main()
```

### 2. è­‰æ›¸é©—è­‰

```python
from cryptography import x509
from cryptography.hazmat.backends import default_backend
from cryptography.hazmat.primitives import hashes
from cryptography.hazmat.primitives.asymmetric import padding
from typing import Dict, Optional
import datetime

class CertificateVerifier:
    def __init__(self, trusted_certs: Optional[list] = None):
        """åˆå§‹åŒ–è­‰æ›¸é©—è­‰å™¨"""
        self.trusted_certs = trusted_certs or []
    
    def load_certificate(self, cert_pem: str) -> Optional[x509.Certificate]:
        """åŠ è¼‰è­‰æ›¸"""
        try:
            return x509.load_pem_x509_certificate(
                cert_pem.encode(),
                default_backend()
            )
        except Exception as e:
            print(f"Error loading certificate: {e}")
            return None
    
    def verify_certificate(self, cert: x509.Certificate) -> Dict[str, bool]:
        """é©—è­‰è­‰æ›¸"""
        results = {
            'valid': True,
            'not_expired': True,
            'trusted': False,
            'valid_signature': True
        }
        
        try:
            # æª¢æŸ¥è­‰æ›¸æ˜¯å¦éæœŸ
            now = datetime.datetime.utcnow()
            if now < cert.not_valid_before or now > cert.not_valid_after:
                results['not_expired'] = False
                results['valid'] = False
            
            # æª¢æŸ¥è­‰æ›¸æ˜¯å¦å—ä¿¡ä»»
            for trusted_cert in self.trusted_certs:
                if cert.issuer == trusted_cert.subject:
                    results['trusted'] = True
                    break
            
            if not results['trusted']:
                results['valid'] = False
            
            # é©—è­‰è­‰æ›¸ç°½å
            try:
                trusted_cert = next(
                    c for c in self.trusted_certs
                    if c.subject == cert.issuer
                )
                trusted_cert.public_key().verify(
                    cert.signature,
                    cert.tbs_certificate_bytes,
                    padding.PKCS1v15(),
                    cert.signature_hash_algorithm
                )
            except Exception:
                results['valid_signature'] = False
                results['valid'] = False
        
        except Exception as e:
            print(f"Certificate verification error: {e}")
            results['valid'] = False
        
        return results
    
    def get_certificate_info(self, cert: x509.Certificate) -> Dict:
        """ç²å–è­‰æ›¸ä¿¡æ¯"""
        return {
            'subject': dict(x[0] for x in cert.subject),
            'issuer': dict(x[0] for x in cert.issuer),
            'serial_number': cert.serial_number,
            'not_valid_before': cert.not_valid_before,
            'not_valid_after': cert.not_valid_after,
            'version': cert.version,
            'signature_algorithm': cert.signature_hash_algorithm.name,
            'extensions': [
                {
                    'oid': ext.oid.dotted_string,
                    'value': ext.value
                }
                for ext in cert.extensions
            ]
        }

# ä½¿ç”¨ç¤ºä¾‹
def main():
    # å‰µå»ºè­‰æ›¸é©—è­‰å™¨
    verifier = CertificateVerifier()
    
    # åŠ è¼‰è­‰æ›¸
    with open('server.crt', 'r') as f:
        cert_pem = f.read()
    
    cert = verifier.load_certificate(cert_pem)
    if cert:
        # ç²å–è­‰æ›¸ä¿¡æ¯
        cert_info = verifier.get_certificate_info(cert)
        print("\nCertificate Information:")
        for key, value in cert_info.items():
            print(f"{key}: {value}")
        
        # é©—è­‰è­‰æ›¸
        results = verifier.verify_certificate(cert)
        print("\nVerification Results:")
        for key, value in results.items():
            print(f"{key}: {value}")

if __name__ == '__main__':
    main()
```

## ç·´ç¿’é¡Œ

1. **è­‰æ›¸ç®¡ç†ç³»çµ±**
   å¯¦ç¾ä¸€å€‹è­‰æ›¸ç®¡ç†ç³»çµ±ï¼š
   - ç”Ÿæˆè‡ªç°½åè­‰æ›¸
   - ç®¡ç†è­‰æ›¸éˆ
   - å¯¦ç¾è­‰æ›¸æ’¤éŠ·
   - ç›£æ§è­‰æ›¸ç‹€æ…‹

2. **å®‰å…¨é€šä¿¡å”è­°**
   é–‹ç™¼ä¸€å€‹å®‰å…¨é€šä¿¡å”è­°ï¼š
   - å¯¦ç¾ç«¯åˆ°ç«¯åŠ å¯†
   - ä½¿ç”¨æ•¸å­—ç°½å
   - æ”¯æŒè­‰æ›¸é©—è­‰
   - é˜²æ­¢é‡æ”¾æ”»æ“Š

3. **å¯†é‘°ç®¡ç†ç³»çµ±**
   å‰µå»ºä¸€å€‹å¯†é‘°ç®¡ç†ç³»çµ±ï¼š
   - ç”Ÿæˆå¯†é‘°å°
   - å®‰å…¨å­˜å„²å¯†é‘°
   - å¯¦ç¾å¯†é‘°è¼ªæ›
   - ç›£æ§å¯†é‘°ä½¿ç”¨

## å°æé†’ ğŸ’¡

1. å®‰å…¨å¯¦ç¾
   - ä½¿ç”¨å¼·åŠ å¯†ç®—æ³•
   - æ­£ç¢ºç®¡ç†å¯†é‘°
   - å®šæœŸæ›´æ–°è­‰æ›¸
   - ä¿è­·æ•æ„Ÿæ•¸æ“š

2. æ€§èƒ½è€ƒæ…®
   - å„ªåŒ–åŠ å¯†éç¨‹
   - ç·©å­˜è­‰æ›¸ä¿¡æ¯
   - æ¸›å°‘é©—è­‰é–‹éŠ·
   - æ§åˆ¶è³‡æºä½¿ç”¨

3. å¯é æ€§
   - è™•ç†ç•°å¸¸æƒ…æ³
   - å¯¦ç¾æ•…éšœæ¢å¾©
   - è¨˜éŒ„è©³ç´°æ—¥èªŒ
   - å®šæœŸå‚™ä»½æ•¸æ“š

4. èª¿è©¦æŠ€å·§
   - ä½¿ç”¨å®‰å…¨å·¥å…·
   - åˆ†æè­‰æ›¸éˆ
   - æ¨¡æ“¬æ”»æ“Šå ´æ™¯
   - å£“åŠ›æ¸¬è©¦

[ä¸Šä¸€ç« ï¼šç¶²çµ¡å®‰å…¨åŸºç¤](070_ç¶²çµ¡å®‰å…¨åŸºç¤.md) | [ä¸‹ä¸€ç« ï¼šç¶²çµ¡æ”»é˜²åŸºç¤](072_ç¶²çµ¡æ”»é˜²åŸºç¤.md) 