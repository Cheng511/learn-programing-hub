[ä¸Šä¸€ç« ï¼šä¸¦ç™¼ç·¨ç¨‹åŸºç¤](082_ä¸¦ç™¼ç·¨ç¨‹åŸºç¤.md) | [ä¸‹ä¸€ç« ï¼šé€²ç¨‹ç·¨ç¨‹åŸºç¤](084_é€²ç¨‹ç·¨ç¨‹åŸºç¤.md)

# Python ä¸¦ç™¼ç·¨ç¨‹é€²éš ğŸ”„

## ç•°æ­¥ç·¨ç¨‹

### 1. ç•°æ­¥ä»»å‹™ç®¡ç†å™¨

```python
import asyncio
import time
from typing import List, Dict, Any, Callable, Optional
import sys
import os
from concurrent.futures import ThreadPoolExecutor

class AsyncTaskManager:
    def __init__(self, max_workers: int = None):
        """åˆå§‹åŒ–ç•°æ­¥ä»»å‹™ç®¡ç†å™¨"""
        self.max_workers = max_workers or (os.cpu_count() or 1) * 2
        self.executor = ThreadPoolExecutor(max_workers=self.max_workers)
        self.tasks: Dict[str, asyncio.Task] = {}
        self.results: Dict[str, Any] = {}
        self.loop = asyncio.get_event_loop()
    
    async def submit_task(self, task_id: str, func: Callable, *args, **kwargs):
        """æäº¤ç•°æ­¥ä»»å‹™"""
        # å‰µå»ºä»»å‹™
        task = asyncio.create_task(self._execute_task(task_id, func, *args, **kwargs))
        self.tasks[task_id] = task
    
    async def _execute_task(self, task_id: str, func: Callable, *args, **kwargs):
        """åŸ·è¡Œç•°æ­¥ä»»å‹™"""
        try:
            # åœ¨ç·šç¨‹æ± ä¸­åŸ·è¡ŒåŒæ­¥å‡½æ•¸
            result = await self.loop.run_in_executor(
                self.executor,
                func,
                *args,
                **kwargs
            )
            self.results[task_id] = result
        except Exception as e:
            self.results[task_id] = e
    
    async def get_result(self, task_id: str) -> Any:
        """ç²å–ä»»å‹™çµæœ"""
        if task_id in self.tasks:
            await self.tasks[task_id]
            result = self.results[task_id]
            if isinstance(result, Exception):
                raise result
            return result
        raise KeyError(f"Task {task_id} not found")
    
    async def cancel_task(self, task_id: str):
        """å–æ¶ˆä»»å‹™"""
        if task_id in self.tasks:
            self.tasks[task_id].cancel()
            try:
                await self.tasks[task_id]
            except asyncio.CancelledError:
                pass
    
    async def wait_for_all_tasks(self):
        """ç­‰å¾…æ‰€æœ‰ä»»å‹™å®Œæˆ"""
        if self.tasks:
            await asyncio.gather(*self.tasks.values())
    
    def close(self):
        """é—œé–‰ä»»å‹™ç®¡ç†å™¨"""
        self.executor.shutdown()

# ä½¿ç”¨ç¤ºä¾‹
def process_item(item: int) -> int:
    """è™•ç†å–®å€‹é …ç›®"""
    time.sleep(0.1)  # æ¨¡æ“¬è™•ç†æ™‚é–“
    return item * item

async def main():
    # å‰µå»ºä»»å‹™ç®¡ç†å™¨
    manager = AsyncTaskManager(max_workers=4)
    
    try:
        # æäº¤å–®å€‹ä»»å‹™
        print("Submitting single task:")
        await manager.submit_task("task1", process_item, 5)
        result = await manager.get_result("task1")
        print(f"Result: {result}")
        
        # æäº¤å¤šå€‹ä»»å‹™
        print("\nSubmitting multiple tasks:")
        for i in range(5):
            await manager.submit_task(f"task{i+2}", process_item, i)
        
        # ç²å–æ‰€æœ‰çµæœ
        for i in range(5):
            result = await manager.get_result(f"task{i+2}")
            print(f"Task {i+2} result: {result}")
        
        # ç­‰å¾…æ‰€æœ‰ä»»å‹™å®Œæˆ
        await manager.wait_for_all_tasks()
    
    finally:
        # é—œé–‰ä»»å‹™ç®¡ç†å™¨
        manager.close()

if __name__ == '__main__':
    asyncio.run(main())
```

### 2. ç•°æ­¥äº‹ä»¶ç®¡ç†å™¨

```python
import asyncio
import time
from typing import List, Dict, Any, Callable, Optional
import sys
import os
from collections import defaultdict

class AsyncEventManager:
    def __init__(self):
        """åˆå§‹åŒ–ç•°æ­¥äº‹ä»¶ç®¡ç†å™¨"""
        self.event_handlers: Dict[str, List[Callable]] = defaultdict(list)
        self.event_queue = asyncio.Queue()
        self.is_running = False
        self.loop = asyncio.get_event_loop()
    
    async def start(self):
        """å•Ÿå‹•äº‹ä»¶ç®¡ç†å™¨"""
        self.is_running = True
        asyncio.create_task(self._process_events())
    
    async def stop(self):
        """åœæ­¢äº‹ä»¶ç®¡ç†å™¨"""
        self.is_running = False
        await self.event_queue.put(None)
    
    def add_event_handler(self, event_type: str, handler: Callable):
        """æ·»åŠ äº‹ä»¶è™•ç†å™¨"""
        self.event_handlers[event_type].append(handler)
    
    def remove_event_handler(self, event_type: str, handler: Callable):
        """ç§»é™¤äº‹ä»¶è™•ç†å™¨"""
        if event_type in self.event_handlers:
            self.event_handlers[event_type].remove(handler)
    
    async def emit_event(self, event_type: str, data: Any = None):
        """ç™¼é€äº‹ä»¶"""
        await self.event_queue.put((event_type, data))
    
    async def _process_events(self):
        """è™•ç†äº‹ä»¶"""
        while self.is_running:
            try:
                event = await self.event_queue.get()
                if event is None:
                    break
                
                event_type, data = event
                
                # åŸ·è¡Œäº‹ä»¶è™•ç†å™¨
                if event_type in self.event_handlers:
                    for handler in self.event_handlers[event_type]:
                        try:
                            if asyncio.iscoroutinefunction(handler):
                                await handler(data)
                            else:
                                handler(data)
                        except Exception as e:
                            print(f"Error in event handler: {e}")
                
                self.event_queue.task_done()
            
            except asyncio.CancelledError:
                break
    
    async def wait_for_event(self, event_type: str, timeout: float = None) -> Any:
        """ç­‰å¾…ç‰¹å®šäº‹ä»¶"""
        future = asyncio.Future()
        
        def handler(data):
            if not future.done():
                future.set_result(data)
        
        self.add_event_handler(event_type, handler)
        
        try:
            return await asyncio.wait_for(future, timeout)
        finally:
            self.remove_event_handler(event_type, handler)
    
    async def wait_for_events(self, event_types: List[str], timeout: float = None) -> Dict[str, Any]:
        """ç­‰å¾…å¤šå€‹äº‹ä»¶"""
        results = {}
        remaining = set(event_types)
        
        async def handler(event_type: str, data: Any):
            if event_type in remaining:
                results[event_type] = data
                remaining.remove(event_type)
        
        for event_type in event_types:
            self.add_event_handler(event_type, lambda data: handler(event_type, data))
        
        try:
            if timeout:
                await asyncio.wait_for(
                    asyncio.gather(*[
                        self.wait_for_event(event_type)
                        for event_type in event_types
                    ]),
                    timeout
                )
            else:
                await asyncio.gather(*[
                    self.wait_for_event(event_type)
                    for event_type in event_types
                ])
        finally:
            for event_type in event_types:
                self.remove_event_handler(event_type, handler)
        
        return results

# ä½¿ç”¨ç¤ºä¾‹
async def event_handler(data: Any):
    """äº‹ä»¶è™•ç†å™¨"""
    print(f"Received event data: {data}")

async def main():
    # å‰µå»ºäº‹ä»¶ç®¡ç†å™¨
    manager = AsyncEventManager()
    
    try:
        # å•Ÿå‹•äº‹ä»¶ç®¡ç†å™¨
        await manager.start()
        
        # æ·»åŠ äº‹ä»¶è™•ç†å™¨
        manager.add_event_handler("test_event", event_handler)
        
        # ç™¼é€äº‹ä»¶
        print("Emitting event:")
        await manager.emit_event("test_event", "Hello, World!")
        
        # ç­‰å¾…äº‹ä»¶
        print("\nWaiting for event:")
        data = await manager.wait_for_event("test_event")
        print(f"Received data: {data}")
        
        # ç­‰å¾…å¤šå€‹äº‹ä»¶
        print("\nWaiting for multiple events:")
        await manager.emit_event("event1", "Event 1 data")
        await manager.emit_event("event2", "Event 2 data")
        
        results = await manager.wait_for_events(["event1", "event2"])
        print(f"Received results: {results}")
        
        # ç­‰å¾…ä¸€æ®µæ™‚é–“
        await asyncio.sleep(1)
    
    finally:
        # åœæ­¢äº‹ä»¶ç®¡ç†å™¨
        await manager.stop()

if __name__ == '__main__':
    asyncio.run(main())
```

## ç·´ç¿’é¡Œ

1. **ç•°æ­¥ä»»å‹™ç®¡ç†å™¨**
   é–‹ç™¼ä¸€å€‹ç•°æ­¥ä»»å‹™ç®¡ç†å™¨ï¼š
   - æ”¯æŒä»»å‹™èª¿åº¦
   - è™•ç†ä»»å‹™å–æ¶ˆ
   - å„ªåŒ–è³‡æºä½¿ç”¨
   - æä¾›éŒ¯èª¤è™•ç†

2. **ç•°æ­¥äº‹ä»¶ç®¡ç†å™¨**
   å‰µå»ºä¸€å€‹ç•°æ­¥äº‹ä»¶ç®¡ç†å™¨ï¼š
   - æ”¯æŒäº‹ä»¶è¨‚é–±
   - è™•ç†äº‹ä»¶éæ¿¾
   - å„ªåŒ–äº‹ä»¶è™•ç†
   - æä¾›èª¿è©¦åŠŸèƒ½

3. **ç•°æ­¥æ¡†æ¶**
   å¯¦ç¾ä¸€å€‹ç•°æ­¥æ¡†æ¶ï¼š
   - æ”¯æŒå¤šç¨®ç•°æ­¥æ¨¡å‹
   - æä¾›é«˜ç´šAPI
   - å„ªåŒ–æ€§èƒ½
   - è™•ç†è¤‡é›œå ´æ™¯

## å°æé†’ ğŸ’¡

1. ç•°æ­¥ç·¨ç¨‹
   - é¸æ“‡åˆé©æ¨¡å‹
   - è™•ç†å”ç¨‹
   - å„ªåŒ–äº‹ä»¶å¾ªç’°
   - é¿å…é˜»å¡æ“ä½œ

2. äº‹ä»¶è™•ç†
   - è¨­è¨ˆäº‹ä»¶ç³»çµ±
   - è™•ç†äº‹ä»¶å‚³é
   - å„ªåŒ–äº‹ä»¶è™•ç†
   - é¿å…äº‹ä»¶æ´©æ¼

3. æ€§èƒ½å„ªåŒ–
   - æ¸›å°‘é–‹éŠ·
   - å„ªåŒ–èª¿åº¦
   - å¹³è¡¡è² è¼‰
   - æé«˜ååé‡

4. èª¿è©¦æŠ€å·§
   - ä½¿ç”¨èª¿è©¦å·¥å…·
   - åˆ†ææ€§èƒ½ç“¶é ¸
   - å„ªåŒ–é—œéµè·¯å¾‘
   - ç›£æ§ç³»çµ±è³‡æº

[ä¸Šä¸€ç« ï¼šä¸¦ç™¼ç·¨ç¨‹åŸºç¤](082_ä¸¦ç™¼ç·¨ç¨‹åŸºç¤.md) | [ä¸‹ä¸€ç« ï¼šé€²ç¨‹ç·¨ç¨‹åŸºç¤](084_é€²ç¨‹ç·¨ç¨‹åŸºç¤.md) 