[ä¸Šä¸€ç« ï¼šç¶²çµ¡å”è­°é€²éš](069_ç¶²çµ¡å”è­°é€²éš.md) | [ä¸‹ä¸€ç« ï¼šç¶²çµ¡å®‰å…¨é€²éš](071_ç¶²çµ¡å®‰å…¨é€²éš.md)

# Python ç¶²çµ¡å®‰å…¨åŸºç¤ ğŸ”’

## åŠ å¯†åŸºç¤

### 1. å°ç¨±åŠ å¯†

```python
from cryptography.fernet import Fernet
from typing import Optional
import base64
from cryptography.hazmat.primitives import hashes
from cryptography.hazmat.primitives.kdf.pbkdf2 import PBKDF2HMAC

class SymmetricEncryption:
    def __init__(self, key: Optional[bytes] = None):
        """åˆå§‹åŒ–åŠ å¯†å™¨"""
        if key is None:
            # ç”Ÿæˆéš¨æ©Ÿå¯†é‘°
            self.key = Fernet.generate_key()
        else:
            self.key = key
        self.cipher_suite = Fernet(self.key)
    
    @staticmethod
    def generate_key_from_password(password: str,
                                 salt: Optional[bytes] = None) -> bytes:
        """å¾å¯†ç¢¼ç”Ÿæˆå¯†é‘°"""
        if salt is None:
            salt = os.urandom(16)
        
        # ä½¿ç”¨PBKDF2ç”Ÿæˆå¯†é‘°
        kdf = PBKDF2HMAC(
            algorithm=hashes.SHA256(),
            length=32,
            salt=salt,
            iterations=100000,
        )
        key = base64.urlsafe_b64encode(kdf.derive(password.encode()))
        return key
    
    def encrypt(self, data: str) -> str:
        """åŠ å¯†æ•¸æ“š"""
        try:
            # å°‡å­—ç¬¦ä¸²è½‰æ›ç‚ºå­—ç¯€
            data_bytes = data.encode()
            
            # åŠ å¯†æ•¸æ“š
            encrypted_data = self.cipher_suite.encrypt(data_bytes)
            
            # å°‡åŠ å¯†å¾Œçš„æ•¸æ“šè½‰æ›ç‚ºBase64å­—ç¬¦ä¸²
            return encrypted_data.decode()
        
        except Exception as e:
            print(f"Encryption error: {e}")
            return ""
    
    def decrypt(self, encrypted_data: str) -> str:
        """è§£å¯†æ•¸æ“š"""
        try:
            # å°‡Base64å­—ç¬¦ä¸²è½‰æ›ç‚ºå­—ç¯€
            encrypted_bytes = encrypted_data.encode()
            
            # è§£å¯†æ•¸æ“š
            decrypted_data = self.cipher_suite.decrypt(encrypted_bytes)
            
            # å°‡è§£å¯†å¾Œçš„æ•¸æ“šè½‰æ›ç‚ºå­—ç¬¦ä¸²
            return decrypted_data.decode()
        
        except Exception as e:
            print(f"Decryption error: {e}")
            return ""

# ä½¿ç”¨ç¤ºä¾‹
def main():
    # ä½¿ç”¨å¯†ç¢¼ç”Ÿæˆå¯†é‘°
    password = "my-secret-password"
    key = SymmetricEncryption.generate_key_from_password(password)
    
    # å‰µå»ºåŠ å¯†å™¨
    crypto = SymmetricEncryption(key)
    
    # æ¸¬è©¦åŠ å¯†å’Œè§£å¯†
    original_text = "Hello, World!"
    print(f"Original text: {original_text}")
    
    encrypted_text = crypto.encrypt(original_text)
    print(f"Encrypted text: {encrypted_text}")
    
    decrypted_text = crypto.decrypt(encrypted_text)
    print(f"Decrypted text: {decrypted_text}")
    
    # é©—è­‰çµæœ
    print(f"Encryption successful: {original_text == decrypted_text}")

if __name__ == '__main__':
    main()
```

### 2. éå°ç¨±åŠ å¯†

```python
from cryptography.hazmat.primitives import serialization
from cryptography.hazmat.primitives.asymmetric import rsa, padding
from cryptography.hazmat.backends import default_backend
from typing import Tuple, Optional
import base64

class AsymmetricEncryption:
    def __init__(self):
        """åˆå§‹åŒ–åŠ å¯†å™¨"""
        self.private_key = None
        self.public_key = None
        self.generate_key_pair()
    
    def generate_key_pair(self):
        """ç”Ÿæˆå¯†é‘°å°"""
        # ç”Ÿæˆç§é‘°
        self.private_key = rsa.generate_private_key(
            public_exponent=65537,
            key_size=2048,
            backend=default_backend()
        )
        
        # ç”Ÿæˆå…¬é‘°
        self.public_key = self.private_key.public_key()
    
    def get_public_key_pem(self) -> str:
        """ç²å–PEMæ ¼å¼çš„å…¬é‘°"""
        return self.public_key.public_bytes(
            encoding=serialization.Encoding.PEM,
            format=serialization.PublicFormat.SubjectPublicKeyInfo
        ).decode()
    
    def get_private_key_pem(self) -> str:
        """ç²å–PEMæ ¼å¼çš„ç§é‘°"""
        return self.private_key.private_bytes(
            encoding=serialization.Encoding.PEM,
            format=serialization.PrivateFormat.PKCS8,
            encryption_algorithm=serialization.NoEncryption()
        ).decode()
    
    def encrypt(self, data: str) -> str:
        """ä½¿ç”¨å…¬é‘°åŠ å¯†æ•¸æ“š"""
        try:
            # å°‡å­—ç¬¦ä¸²è½‰æ›ç‚ºå­—ç¯€
            data_bytes = data.encode()
            
            # åŠ å¯†æ•¸æ“š
            encrypted_data = self.public_key.encrypt(
                data_bytes,
                padding.OAEP(
                    mgf=padding.MGF1(algorithm=hashes.SHA256()),
                    algorithm=hashes.SHA256(),
                    label=None
                )
            )
            
            # å°‡åŠ å¯†å¾Œçš„æ•¸æ“šè½‰æ›ç‚ºBase64å­—ç¬¦ä¸²
            return base64.b64encode(encrypted_data).decode()
        
        except Exception as e:
            print(f"Encryption error: {e}")
            return ""
    
    def decrypt(self, encrypted_data: str) -> str:
        """ä½¿ç”¨ç§é‘°è§£å¯†æ•¸æ“š"""
        try:
            # å°‡Base64å­—ç¬¦ä¸²è½‰æ›ç‚ºå­—ç¯€
            encrypted_bytes = base64.b64decode(encrypted_data)
            
            # è§£å¯†æ•¸æ“š
            decrypted_data = self.private_key.decrypt(
                encrypted_bytes,
                padding.OAEP(
                    mgf=padding.MGF1(algorithm=hashes.SHA256()),
                    algorithm=hashes.SHA256(),
                    label=None
                )
            )
            
            # å°‡è§£å¯†å¾Œçš„æ•¸æ“šè½‰æ›ç‚ºå­—ç¬¦ä¸²
            return decrypted_data.decode()
        
        except Exception as e:
            print(f"Decryption error: {e}")
            return ""

# ä½¿ç”¨ç¤ºä¾‹
def main():
    # å‰µå»ºåŠ å¯†å™¨
    crypto = AsymmetricEncryption()
    
    # ç²å–å¯†é‘°
    public_key = crypto.get_public_key_pem()
    private_key = crypto.get_private_key_pem()
    
    print("Public Key:")
    print(public_key)
    print("\nPrivate Key:")
    print(private_key)
    
    # æ¸¬è©¦åŠ å¯†å’Œè§£å¯†
    original_text = "Hello, World!"
    print(f"\nOriginal text: {original_text}")
    
    encrypted_text = crypto.encrypt(original_text)
    print(f"Encrypted text: {encrypted_text}")
    
    decrypted_text = crypto.decrypt(encrypted_text)
    print(f"Decrypted text: {decrypted_text}")
    
    # é©—è­‰çµæœ
    print(f"Encryption successful: {original_text == decrypted_text}")

if __name__ == '__main__':
    main()
```

## å“ˆå¸Œå‡½æ•¸

### 1. å¯†ç¢¼å“ˆå¸Œ

```python
import hashlib
import os
from typing import Tuple
import bcrypt

class PasswordHasher:
    @staticmethod
    def hash_password(password: str) -> Tuple[str, str]:
        """ä½¿ç”¨bcryptå“ˆå¸Œå¯†ç¢¼"""
        # ç”Ÿæˆé¹½å€¼
        salt = bcrypt.gensalt()
        
        # å“ˆå¸Œå¯†ç¢¼
        hashed = bcrypt.hashpw(password.encode(), salt)
        
        return hashed.decode(), salt.decode()
    
    @staticmethod
    def verify_password(password: str,
                       hashed_password: str) -> bool:
        """é©—è­‰å¯†ç¢¼"""
        try:
            return bcrypt.checkpw(
                password.encode(),
                hashed_password.encode()
            )
        except Exception as e:
            print(f"Password verification error: {e}")
            return False
    
    @staticmethod
    def hash_file(file_path: str) -> str:
        """è¨ˆç®—æ–‡ä»¶çš„SHA-256å“ˆå¸Œå€¼"""
        try:
            sha256_hash = hashlib.sha256()
            
            with open(file_path, "rb") as f:
                for byte_block in iter(lambda: f.read(4096), b""):
                    sha256_hash.update(byte_block)
            
            return sha256_hash.hexdigest()
        
        except Exception as e:
            print(f"File hashing error: {e}")
            return ""

# ä½¿ç”¨ç¤ºä¾‹
def main():
    # æ¸¬è©¦å¯†ç¢¼å“ˆå¸Œ
    password = "my-secret-password"
    print(f"Original password: {password}")
    
    hashed_password, salt = PasswordHasher.hash_password(password)
    print(f"Hashed password: {hashed_password}")
    print(f"Salt: {salt}")
    
    # é©—è­‰å¯†ç¢¼
    is_valid = PasswordHasher.verify_password(
        password,
        hashed_password
    )
    print(f"Password valid: {is_valid}")
    
    # æ¸¬è©¦éŒ¯èª¤å¯†ç¢¼
    wrong_password = "wrong-password"
    is_valid = PasswordHasher.verify_password(
        wrong_password,
        hashed_password
    )
    print(f"Wrong password valid: {is_valid}")
    
    # æ¸¬è©¦æ–‡ä»¶å“ˆå¸Œ
    file_path = "test.txt"
    with open(file_path, "w") as f:
        f.write("Hello, World!")
    
    file_hash = PasswordHasher.hash_file(file_path)
    print(f"\nFile hash: {file_hash}")

if __name__ == '__main__':
    main()
```

### 2. æ¶ˆæ¯èªè­‰ç¢¼

```python
import hmac
import hashlib
from typing import Optional

class MessageAuthenticator:
    def __init__(self, key: Optional[bytes] = None):
        """åˆå§‹åŒ–æ¶ˆæ¯èªè­‰å™¨"""
        self.key = key or os.urandom(32)
    
    def generate_mac(self, message: str) -> str:
        """ç”Ÿæˆæ¶ˆæ¯èªè­‰ç¢¼"""
        try:
            # å‰µå»ºHMACå°è±¡
            hmac_obj = hmac.new(
                self.key,
                message.encode(),
                hashlib.sha256
            )
            
            # ç”ŸæˆMAC
            return hmac_obj.hexdigest()
        
        except Exception as e:
            print(f"MAC generation error: {e}")
            return ""
    
    def verify_mac(self, message: str, mac: str) -> bool:
        """é©—è­‰æ¶ˆæ¯èªè­‰ç¢¼"""
        try:
            # ç”ŸæˆMAC
            expected_mac = self.generate_mac(message)
            
            # æ¯”è¼ƒMAC
            return hmac.compare_digest(expected_mac, mac)
        
        except Exception as e:
            print(f"MAC verification error: {e}")
            return False

# ä½¿ç”¨ç¤ºä¾‹
def main():
    # å‰µå»ºæ¶ˆæ¯èªè­‰å™¨
    authenticator = MessageAuthenticator()
    
    # æ¸¬è©¦æ¶ˆæ¯
    message = "Hello, World!"
    print(f"Original message: {message}")
    
    # ç”ŸæˆMAC
    mac = authenticator.generate_mac(message)
    print(f"MAC: {mac}")
    
    # é©—è­‰MAC
    is_valid = authenticator.verify_mac(message, mac)
    print(f"MAC valid: {is_valid}")
    
    # æ¸¬è©¦ç¯¡æ”¹æ¶ˆæ¯
    tampered_message = "Hello, World! (tampered)"
    is_valid = authenticator.verify_mac(tampered_message, mac)
    print(f"Tampered message MAC valid: {is_valid}")

if __name__ == '__main__':
    main()
```

## SSL/TLS

### 1. SSLå®¢æˆ¶ç«¯

```python
import ssl
import socket
from typing import Optional, Dict
import certifi
import os

class SSLClient:
    def __init__(self, host: str,
                 port: int = 443,
                 cert_path: Optional[str] = None):
        self.host = host
        self.port = port
        self.cert_path = cert_path or certifi.where()
        self.context = self.create_ssl_context()
        self.socket: Optional[socket.socket] = None
    
    def create_ssl_context(self) -> ssl.SSLContext:
        """å‰µå»ºSSLä¸Šä¸‹æ–‡"""
        context = ssl.create_default_context()
        context.check_hostname = True
        context.verify_mode = ssl.CERT_REQUIRED
        context.load_verify_locations(self.cert_path)
        return context
    
    def connect(self) -> bool:
        """å»ºç«‹SSLé€£æ¥"""
        try:
            # å‰µå»ºsocket
            self.socket = socket.create_connection(
                (self.host, self.port)
            )
            
            # åŒ…è£socket
            self.socket = self.context.wrap_socket(
                self.socket,
                server_hostname=self.host
            )
            
            print(f"Connected to {self.host}:{self.port}")
            return True
        
        except Exception as e:
            print(f"Connection failed: {e}")
            return False
    
    def send_request(self, request: str) -> Optional[str]:
        """ç™¼é€è«‹æ±‚ä¸¦æ¥æ”¶éŸ¿æ‡‰"""
        if not self.socket:
            raise RuntimeError("Not connected")
        
        try:
            # ç™¼é€è«‹æ±‚
            self.socket.send(request.encode())
            
            # æ¥æ”¶éŸ¿æ‡‰
            response = b""
            while True:
                data = self.socket.recv(4096)
                if not data:
                    break
                response += data
            
            return response.decode()
        
        except Exception as e:
            print(f"Request error: {e}")
            return None
    
    def get_certificate_info(self) -> Dict:
        """ç²å–è­‰æ›¸ä¿¡æ¯"""
        if not self.socket:
            raise RuntimeError("Not connected")
        
        try:
            cert = self.socket.getpeercert()
            return {
                'subject': dict(x[0] for x in cert['subject']),
                'issuer': dict(x[0] for x in cert['issuer']),
                'version': cert['version'],
                'expires': cert['notAfter'],
                'serial': cert['serialNumber']
            }
        
        except Exception as e:
            print(f"Certificate info error: {e}")
            return {}
    
    def close(self):
        """é—œé–‰é€£æ¥"""
        if self.socket:
            self.socket.close()

# ä½¿ç”¨ç¤ºä¾‹
def main():
    # å‰µå»ºSSLå®¢æˆ¶ç«¯
    client = SSLClient("example.com")
    
    try:
        # é€£æ¥åˆ°æœå‹™å™¨
        if client.connect():
            # ç²å–è­‰æ›¸ä¿¡æ¯
            cert_info = client.get_certificate_info()
            print("\nCertificate Information:")
            for key, value in cert_info.items():
                print(f"{key}: {value}")
            
            # ç™¼é€HTTPSè«‹æ±‚
            request = (
                "GET / HTTP/1.1\r\n"
                f"Host: {client.host}\r\n"
                "Connection: close\r\n"
                "\r\n"
            )
            
            response = client.send_request(request)
            if response:
                print("\nResponse:")
                print(response[:200])  # åªæ‰“å°å‰200å€‹å­—ç¬¦
    
    finally:
        client.close()

if __name__ == '__main__':
    main()
```

### 2. SSLæœå‹™å™¨

```python
import ssl
import socket
from typing import Optional, Dict
import os

class SSLServer:
    def __init__(self, host: str = 'localhost',
                 port: int = 8443,
                 cert_file: str = 'server.crt',
                 key_file: str = 'server.key'):
        self.host = host
        self.port = port
        self.cert_file = cert_file
        self.key_file = key_file
        self.context = self.create_ssl_context()
        self.socket: Optional[socket.socket] = None
        self.running = False
    
    def create_ssl_context(self) -> ssl.SSLContext:
        """å‰µå»ºSSLä¸Šä¸‹æ–‡"""
        context = ssl.create_default_context(ssl.Purpose.CLIENT_AUTH)
        context.load_cert_chain(
            certfile=self.cert_file,
            keyfile=self.key_file
        )
        return context
    
    def handle_client(self, client_socket: socket.socket):
        """è™•ç†å®¢æˆ¶ç«¯é€£æ¥"""
        try:
            # æ¥æ”¶æ•¸æ“š
            data = client_socket.recv(4096)
            if not data:
                return
            
            # è™•ç†è«‹æ±‚
            request = data.decode()
            print(f"Received request:\n{request}")
            
            # ç™¼é€éŸ¿æ‡‰
            response = (
                "HTTP/1.1 200 OK\r\n"
                "Content-Type: text/plain\r\n"
                "Connection: close\r\n"
                "\r\n"
                "Hello, Secure World!"
            )
            client_socket.send(response.encode())
        
        except Exception as e:
            print(f"Error handling client: {e}")
        
        finally:
            client_socket.close()
    
    def start(self):
        """å•Ÿå‹•SSLæœå‹™å™¨"""
        try:
            # å‰µå»ºsocket
            self.socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            self.socket.setsockopt(
                socket.SOL_SOCKET,
                socket.SO_REUSEADDR,
                1
            )
            
            # ç¶å®šåœ°å€
            self.socket.bind((self.host, self.port))
            self.socket.listen(5)
            
            self.running = True
            print(f"SSL server running on {self.host}:{self.port}")
            
            while self.running:
                try:
                    # æ¥å—é€£æ¥
                    client_socket, address = self.socket.accept()
                    print(f"New connection from {address}")
                    
                    # åŒ…è£socket
                    client_socket = self.context.wrap_socket(
                        client_socket,
                        server_side=True
                    )
                    
                    # è™•ç†å®¢æˆ¶ç«¯
                    self.handle_client(client_socket)
                
                except Exception as e:
                    print(f"Error accepting connection: {e}")
        
        except KeyboardInterrupt:
            print("\nServer shutting down...")
        
        finally:
            self.running = False
            if self.socket:
                self.socket.close()

# ä½¿ç”¨ç¤ºä¾‹
if __name__ == '__main__':
    # ç”Ÿæˆè‡ªç°½åè­‰æ›¸
    if not os.path.exists('server.crt') or not os.path.exists('server.key'):
        os.system('openssl req -x509 -newkey rsa:2048 -keyout server.key '
                 '-out server.crt -days 365 -nodes -subj "/CN=localhost"')
    
    # å•Ÿå‹•æœå‹™å™¨
    server = SSLServer()
    server.start()
```

## ç·´ç¿’é¡Œ

1. **å®‰å…¨èŠå¤©å®¤**
   å¯¦ç¾ä¸€å€‹åŠ å¯†çš„èŠå¤©å®¤ï¼š
   - ä½¿ç”¨SSL/TLSåŠ å¯†é€šä¿¡
   - å¯¦ç¾ç”¨æˆ¶èªè­‰
   - æ”¯æŒç«¯åˆ°ç«¯åŠ å¯†
   - é˜²æ­¢ä¸­é–“äººæ”»æ“Š

2. **æ–‡ä»¶åŠ å¯†å·¥å…·**
   é–‹ç™¼ä¸€å€‹æ–‡ä»¶åŠ å¯†å·¥å…·ï¼š
   - æ”¯æŒå°ç¨±å’Œéå°ç¨±åŠ å¯†
   - å¯¦ç¾æ–‡ä»¶å®Œæ•´æ€§é©—è­‰
   - æ·»åŠ å¯†ç¢¼ä¿è­·
   - æ”¯æŒå¤§æ–‡ä»¶è™•ç†

3. **å®‰å…¨ä»£ç†æœå‹™å™¨**
   å‰µå»ºä¸€å€‹å®‰å…¨çš„ä»£ç†æœå‹™å™¨ï¼š
   - æ”¯æŒHTTPSä»£ç†
   - å¯¦ç¾è¨ªå•æ§åˆ¶
   - æ·»åŠ æµé‡åŠ å¯†
   - ç›£æ§ç•°å¸¸æµé‡

## å°æé†’ ğŸ’¡

1. åŠ å¯†å¯¦ç¾
   - ä½¿ç”¨å®‰å…¨çš„ç®—æ³•
   - æ­£ç¢ºç®¡ç†å¯†é‘°
   - å®šæœŸæ›´æ–°å¯†é‘°
   - ä¿è­·æ•æ„Ÿæ•¸æ“š

2. å®‰å…¨è€ƒæ…®
   - é˜²æ­¢é‡æ”¾æ”»æ“Š
   - å¯¦ç¾è­‰æ›¸é©—è­‰
   - æ§åˆ¶è¨ªå•æ¬Šé™
   - ç›£æ§ç•°å¸¸è¡Œç‚º

3. æ€§èƒ½å„ªåŒ–
   - ä½¿ç”¨ç¡¬ä»¶åŠ é€Ÿ
   - å„ªåŒ–åŠ å¯†éç¨‹
   - ç·©å­˜å¸¸ç”¨æ•¸æ“š
   - æ§åˆ¶è³‡æºä½¿ç”¨

4. èª¿è©¦æŠ€å·§
   - ä½¿ç”¨å®‰å…¨å·¥å…·
   - åˆ†æåŠ å¯†æµé‡
   - æ¨¡æ“¬æ”»æ“Šå ´æ™¯
   - å£“åŠ›æ¸¬è©¦

[ä¸Šä¸€ç« ï¼šç¶²çµ¡å”è­°é€²éš](069_ç¶²çµ¡å”è­°é€²éš.md) | [ä¸‹ä¸€ç« ï¼šç¶²çµ¡å®‰å…¨é€²éš](071_ç¶²çµ¡å®‰å…¨é€²éš.md) 